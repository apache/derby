/*

   Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.autoGeneratedJdbc30

   Copyright 2002, 2005 The Apache Software Foundation or its licensors, as applicable.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

package org.apache.derbyTesting.functionTests.tests.jdbcapi;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.SQLException;

import org.apache.derby.tools.ij;
import org.apache.derby.tools.JDBCDisplayUtil;

import org.apache.derbyTesting.functionTests.util.TestUtil;

/**
 * Test the new Auto Generated Keys feature in jdbc 30 for Statement and PreparedStatement.
 *
 * @author mamta
 */

public class autoGeneratedJdbc30 { 

	private static String[] testObjects= {"table t11","table t21","table t31"};


	private static boolean HAVE_DRIVER_MANAGER_CLASS;

	static{
		try{
			Class.forName("java.sql.DriverManager");
			HAVE_DRIVER_MANAGER_CLASS = true;
		}
		catch(ClassNotFoundException e){
			//Used for JSR169
			HAVE_DRIVER_MANAGER_CLASS = false;
		}
	}
	
	public static void main(String[] args) {

		Connection con = null;
		Statement  s;
		PreparedStatement  ps;

		System.out.println("Test autoGeneratedJdbc30 starting");

		try
		{
			ij.getPropertyArg(args);
			con = ij.startJBMS();

			s = con.createStatement();
			/* Create the tables and do any other set-up */
			setUpTest(s);
			con.setAutoCommit(false);

			positiveTests(con);

			if(HAVE_DRIVER_MANAGER_CLASS)
				doTest1920(s, con);

			negativeTests(con);

			s = con.createStatement();
			TestUtil.cleanUpTest(s, testObjects);
			con.commit();
			con.close();
		}
		catch (SQLException e) {
			JDBCDisplayUtil.ShowSQLException(System.out,e);
		}
		catch (Throwable e) {
			System.out.println("FAIL -- unexpected exception:");
			e.printStackTrace(System.out);
		}

		System.out.println("Test autoGeneratedJdbc30 finished");
	}

	public static String MyMethodWithNoInsert() throws SQLException {
		System.out.println("Inside server-side method with no insert statement");
		Connection conn = DriverManager.getConnection("jdbc:default:connection");
		Statement s = conn.createStatement();
		s.executeQuery("select * from t11");
		return "true";
	}

	public static String MyMethodWithInsert() throws SQLException {
		System.out.println("Inside server-side method with couple insert statement with various combination of auto generated keys flag");
		Connection conn = DriverManager.getConnection("jdbc:default:connection");
		Statement s = conn.createStatement();
		s.execute("insert into t11(c11) values(999)", Statement.RETURN_GENERATED_KEYS);
		dumpRS(s.getGeneratedKeys());
		s.execute("insert into t11(c11) values(999)", Statement.NO_GENERATED_KEYS);
		try {
			dumpRS(s.getGeneratedKeys());
		} catch (SQLException e) {
			dumpExpectedSQLExceptions(e);
		}
		dumpRS(s.executeQuery("select * from t11"));
		return "true";
	}

	public static int count(Connection con, Statement s) throws SQLException {
		int count = 0;
		ResultSet rs = s.executeQuery("select count(*) from t11");
		rs.next();
		count = rs.getInt(1);
		rs.close();
		return count;
	}

	//Set up the test by creating the table used by the rest of the test.
	public static void setUpTest(Statement s)
					throws SQLException {
		try {
			// first drop to make sure there's nothing there
			s.execute("drop table t11");
			s.execute("drop table t21");
			s.execute("drop table t31");
		} catch (SQLException se) {
			// assume failure because there really wasn't anything there 
		}

		/* Create a table */
		// set by increment not yet supported for create table...
		// does not matter for purpose of this test.
		// s.execute("create table t11 (c11 int, c12 int default set increment by 1)");
		s.execute("create table t11 (c11 int, c12 int generated always as identity)");
		s.execute("alter table t11 alter c12 set increment by 1");
		s.execute("create table t21 (c21 int not null unique, c22 char(5))");
		s.execute("insert into t21 values(21, 'true')");
		s.execute("insert into t21 values(22, 'true')");
		s.execute("create table t31 (c31 int, c32 int generated always as identity, c33 int default 2)");
		s.execute("alter table t31 alter c32 set increment by 1");
	}

	public static void dumpExpectedSQLExceptions (SQLException se) {
		System.out.println("PASS -- expected exception");
		while (se != null)
		{
			System.out.println("SQLSTATE("+se.getSQLState()+"): "+se.getMessage());
			se = se.getNextException();
        }
    }


	// lifted from the metadata test	
	public static void dumpRS(ResultSet s) throws SQLException 
	{
		if (s == null)
		{
			System.out.println("<NULL>");
			return;
		}

		ResultSetMetaData rsmd = s.getMetaData();

		// Get the number of columns in the result set
		int numCols = rsmd.getColumnCount();

		if (numCols <= 0) 
		{
			System.out.println("(no columns!)");
			return;
		}

		StringBuffer heading = new StringBuffer("\t ");
		StringBuffer underline = new StringBuffer("\t ");

		int len;
		// Display column headings
		for (int i=1; i<=numCols; i++) 
		{
			if (i > 1) 
			{
				heading.append(",");
				underline.append(" ");
			}
			len = heading.length();
			heading.append(rsmd.getColumnLabel(i));
			len = heading.length() - len;
			for (int j = len; j > 0; j--)
			{
				underline.append("-");
			}
		}
		System.out.println(heading.toString());
		System.out.println(underline.toString());
		
	
		StringBuffer row = new StringBuffer();
		// Display data, fetching until end of the result set
		while (s.next()) 
		{
			row.append("\t{");
			// Loop through each column, getting the
			// column data and displaying
			for (int i=1; i<=numCols; i++) 
			{
				if (i > 1) row.append(",");
				row.append(s.getString(i));
			}
			row.append("}\n");
		}
		System.out.println(row.toString());
		s.close();
	}

	public static void disabledTestsBecauseOfBug5580(Statement s, Connection con, PreparedStatement ps) throws SQLException
	{
			// re-enable following test whenever bug 5580 fixed
			//Test11 - insert select with columnIndexes[] array - bug 5580
			System.out.println("Test11 - insert select with columnIndexes[] array");
			int colPositions[] = new int[1];
      colPositions[0] = 1;
			s.execute("insert into t11(c11) select c21 from t21", colPositions);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test11ps - insert select with columnIndexes[] array");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			// BUG 4836 Hey, actually fetch a generated column!!!!!!!!!!!!!
			colPositions[0] = 2;
			s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			//Verify data in the table
			if(count(con,s) != 12) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test12 - insert select with columnIndexes[] array with duplicate column positions
			System.out.println("Test12 - insert select with columnIndexes[] array with duplicate column positions");
			colPositions = new int[2];
      colPositions[0] = 1;
      colPositions[1] = 1;
			s.execute("insert into t11(c11) select c21 from t21", colPositions);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test12ps - insert select with columnIndexes[] array with duplicate column positions");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			//Verify data in the table
			if(count(con,s) != 8) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test13 - insert select with columnIndexes[] array with invalid column position
			System.out.println("Test13 - insert select with columnIndexes[] array with invalid column position");
      colPositions[0] = 3;
			try {
				s.execute("insert into t11(c11) select c21 from t21", colPositions);
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
        dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			System.out.println("Test13ps - insert select with columnIndexes[] array with invalid column position");
			try {
				ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
				ps.execute();
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				ps.executeUpdate();
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			//Verify data in the table
			if(count(con,s) != 0) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test14 - insert select with columnNames[] array
			System.out.println("Test14 - insert select with columnNames[] array");
			String colNames[] = new String[1];
      colNames[0] = "C11";
			s.execute("insert into t11(c11) select c21 from t21", colNames);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test14ps - insert select with columnNames[] array");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			// BUG 4836 Hey, actually fetch a generated column!!!!!!!!!!!!!
			colNames[0] = "C12";
			s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
			dumpRS(s.getGeneratedKeys());
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			//Verify data in the table
			if(count(con,s) != 12) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test15 - insert select with columnNames[] array with duplicate column names
			System.out.println("Test15 - insert select with columnNames[] array with duplicate column names");
			colNames = new String[2];
      colNames[0] = "C11";
      colNames[1] = "C11";
			s.execute("insert into t11(c11) select c21 from t21", colNames);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test15ps - insert select with columnNames[] array with duplicate column names");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			//Verify data in the table
			if(count(con,s) != 8) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test16 - insert select with columnNames[] array with invalid column name
			colNames = new String[1];
			System.out.println("Test16 - insert select with columnNames[] array with invalid column name");
      colNames[0] = "C13";
			try {
				s.execute("insert into t11(c11) select c21 from t21", colNames);
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			System.out.println("Test16ps - insert select with columnNames[] array with invalid column name");
			try {
				ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
				ps.execute();
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				ps.executeUpdate();
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			//Verify data in the table
			if(count(con,s) != 0) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test17 - insert select with null columnIndexes[] internally switches to Statement.NO_GENERATED_KEYS
			System.out.println("Test17 - insert select with null columnIndexes[] internally switches to Statement.NO_GENERATED_KEYS");
			colPositions = null;
			s.execute("insert into t11(c11) select c21 from t21", colPositions);
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			System.out.println("Test17ps - insert select with null columnIndexes[] internally switches to Statement.NO_GENERATED_KEYS");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
			ps.execute();
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			ps.executeUpdate();
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			//Verify data in the table
			if(count(con,s) != 8) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test18 - insert select with null columnNames[] internally switches to Statement.NO_GENERATED_KEYS
			System.out.println("Test18 - insert select with null columnNames[] internally switches to Statement.NO_GENERATED_KEYS");
			colNames = null;
			s.execute("insert into t11(c11) select c21 from t21", colNames);
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
			try {
				dumpRS(s.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			System.out.println("Test18ps - insert select with null columnNames[] internally switches to Statement.NO_GENERATED_KEYS");
			ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
			ps.execute();
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}
			ps.executeUpdate();
			try {
				dumpRS(ps.getGeneratedKeys());
			} catch (SQLException e) {
				dumpExpectedSQLExceptions(e);
			}

			//Verify data in the table
			if(count(con,s) != 8) {
				System.out.println("Test failed");
				return;
			}
			s.execute("delete from t11");

			//Test19a - insert values with column position order which doesn't match column positions in the actual table
			//The column positions correspond to columns in the table and not the columns in the insert statement
			System.out.println("Test19a - insert values with column position order which doesn't match column positions in the actual table");
			colPositions = new int[1];
			colPositions[0] = 1;
			s.execute("insert into t21(c22,c21) values('true', 23)", colPositions);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t21(c22,c21) values('true', 23)", colPositions);
			dumpRS(s.getGeneratedKeys());

			//Test19aps - insert values with column position order which doesn't match column positions in the actual table
			System.out.println("Test19aps - insert values with column position order which doesn't match column positions in the actual table");
			ps = con.prepareStatement("insert into t21(c22,c21) values('true', 23)", colPositions);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			//Verify data in the table
			dumpRS(s.executeQuery("select count(*) from t21"));
			s.execute("delete from t11");
	}

	private static void positiveTests(Connection conn) throws SQLException
	{
			System.out.println("Test 1 - request for generated keys resultset on a brand new statement with no sql executed on it yet");
			System.out.println("We will get a resultset with no rows because it is a non-insert sql");
			Statement s = conn.createStatement();
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test2 - request for generated keys on a statement which does select from a table ie a non-insert sql");
			s.execute("select * from t11", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We will get a resultset with no rows because it is a non-insert sql");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			PreparedStatement ps = conn.prepareStatement("select * from t11", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 3 - insert multiple rows into a table with autogenerated key and request generated keys resultset");
			System.out.println(" We will get a row with NULL value because this insert sql inserted more than one row and ");
			System.out.println(" there was no prior one-row insert into a table with autogenerated key");
			s.execute("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 4 - request for generated keys after doing an insert into a table with no auto generated keys");
			System.out.println(" And there has been no one-row insert into a table with auto-generated keys yet.");
			s.execute("insert into t21 values(23, 'true')", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with one row of NULL value from getGeneratedKeys");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t21 values(24, 'true')", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(25, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(26, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 5a - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys");
			s.execute("insert into t11(c11) select c21 from t21", Statement.RETURN_GENERATED_KEYS);
			System.out.println("Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t11(c11) select c21 from t21", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t11(c11) select c21 from t21", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 5b - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys");
			s.execute("insert into t11(c11) select c21 from t21 where 1=2", Statement.RETURN_GENERATED_KEYS);
			System.out.println("Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t11(c11) select c21 from t21 where 1=2", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t11(c11) select c21 from t21 where 1=2", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 5c - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys");
			s.execute("insert into t11(c11) select c21 from t21 where c21=23", Statement.RETURN_GENERATED_KEYS);
			System.out.println("Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t11(c11) select c21 from t21 where c21=23", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t11(c11) select c21 from t21 where c21=23", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 6 - request for generated keys after doing a one-row insert into a table with auto generated keys");
			s.execute("insert into t11(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with one row of non-NULL value");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t11(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t11(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 7 - Now try again inserting multiple rows into a table with autogenerated key and request generated keys resultset");
			System.out.println(" This time we will get a row of non-NULL value because there has been a prior one-row insert into table with auto-generated key ");
			s.execute("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t31(c31) values (99), (98), (97)", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 8 - create a new statement and request for generated keys on it after doing an insert into ");
			System.out.println(" a table with no auto generated keys");
			Statement s1 = conn.createStatement();
			s1.execute("insert into t21 values(27, 'true')", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with one row of non-NULL value");
			dumpRS(s1.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s1.executeUpdate("insert into t21 values(28, 'true')", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s1.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(29, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(30, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 9 - request for generated keys on a statement which does a update ");
			s.execute("update t11 set c11=1", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with no rows from getGeneratedKeys because we executed a non-insert sql");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("update t11 set c11=1", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("update t11 set c11=1", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 10 - request for generated keys on a statement which does a delete ");
			s.execute("delete from t11", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with no rows from getGeneratedKeys because we executed a non-insert sql");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("delete from t11", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("delete from t11", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 11 - do a commit and request for generated keys on a statement which does insert into a table with ");
			System.out.println(" no auto generated keys (previous transaction had a one-row insert on a table with auto-generated keys)");
			conn.commit();
			s.execute("insert into t21 values(31, 'true')", Statement.RETURN_GENERATED_KEYS);
			System.out.println("expected to see resultset with one row of NULL value but instead get one row of non-NULL value from getGeneratedKeys");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t21 values(32, 'true')", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(33, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(34, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 12 - do a rollback and request for generated keys on a statement which does insert into a table with ");
			System.out.println(" no auto generated keys (previous transaction had a one-row insert on a table with auto-generated keys)");
			conn.rollback();
			s.execute("insert into t21 values(35, 'true')", Statement.RETURN_GENERATED_KEYS);
			System.out.println("had expected to see resultset with one row of NULL value but instead get one row of non-NULL value from getGeneratedKeys");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with Statement.executeUpdate. It should behave the same");
			s.executeUpdate("insert into t21 values(36, 'true')", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.execute. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(37, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			System.out.println("Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same");
			ps = conn.prepareStatement("insert into t21 values(38, 'true')", Statement.RETURN_GENERATED_KEYS);
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 13 - try savepoint rollback and see what happens to auto generated keys resultset");
			Savepoint savepoint1;
			System.out.println("Inside the savepoint unit, issue a one-row insert into a table with auto generated keys");
			savepoint1 = conn.setSavepoint();
			s.execute("insert into t11(c11) values (99)", Statement.RETURN_GENERATED_KEYS);
			System.out.println("We should get a resultset with one row of non-NULL value");
			dumpRS(s.getGeneratedKeys());
			System.out.println("Now rollback the savepoint unit, and make sure that autogenerated keys resultset still holds on to ");
			System.out.println(" value that got set inside the rolled back savepoint unit");
			conn.rollback(savepoint1);
			s.execute("insert into t21 values(39, 'true')", Statement.RETURN_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());

			System.out.println("Test 14 - Look at metadata of a getGeneratedKeys resultset");
			s = conn.createStatement();
			s.execute("insert into t31(c31) values (99)", Statement.RETURN_GENERATED_KEYS);
			ResultSet rs = s.getGeneratedKeys();
			ResultSetMetaData rsmd = rs.getMetaData();
			System.out.println("The resultset will have one column only");
			System.out.println("Found " + rsmd.getColumnCount() + " column in the resultset");
			System.out.println("Type of the column is " + rsmd.getColumnTypeName(1));
			System.out.println("Precision of the column is " + rsmd.getPrecision(1));
			System.out.println("Scale of the column is " + rsmd.getScale(1));
			dumpRS(rs);

			System.out.println("Test 15 - Can not see the auto generated keys if insert is with NO_GENERATED_KEYS");
			s = conn.createStatement();
			s.execute("insert into t31(c31) values (99)", Statement.NO_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t31(c31) values (99)", Statement.NO_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			ps = conn.prepareStatement("insert into t31(c31) values (99)", Statement.NO_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 16 - Can not see the auto generated keys if insert is done jdbc 2.0 way ie with no generated key feature");
			s.execute("insert into t31(c31) values (99)");
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("insert into t31(c31) values (99)");
			dumpRS(s.getGeneratedKeys());
			ps = conn.prepareStatement("insert into t31(c31) values (99)");
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 17 - non-insert with NO_GENERATED_KEYS");
			s = conn.createStatement();
			s.execute("update t31 set c31=98", Statement.NO_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("update t31 set c31=98", Statement.NO_GENERATED_KEYS);
			dumpRS(s.getGeneratedKeys());
			ps = conn.prepareStatement("update t31 set c31=98", Statement.NO_GENERATED_KEYS);
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());

			System.out.println("Test 18 - non-insert is done jdbc 2.0 way ie with no generated key feature");
			s.execute("delete from t31");
			dumpRS(s.getGeneratedKeys());
			s.executeUpdate("delete from t31");
			dumpRS(s.getGeneratedKeys());
			ps = conn.prepareStatement("delete from t31");
			ps.execute();
			dumpRS(ps.getGeneratedKeys());
			ps.executeUpdate();
			dumpRS(ps.getGeneratedKeys());
			
	}

	public static void negativeTests(Connection con) throws SQLException
	{
			Statement s = con.createStatement();
			PreparedStatement ps;
			//Test21 - insert select with columnIndexes[] array
			System.out.println("Test21 - insert select with columnIndexes[] array should fail");
			int colPositions[] = new int[1];
      colPositions[0] = 1;
			try {
				System.out.println("Try passing array with Statement.execute");
				s.execute("insert into t11(c11) select c21 from t21", colPositions);
				System.out.println("ERROR: shouldn't be able to pass array with Statement.execute");

			} catch (SQLException e) {
				if ((e.getMessage() != null &&
					 e.getMessage().indexOf("Driver not capable") >= 0)
					|| (e.getSQLState() != null &&
						(e.getSQLState().startsWith("0A"))))
					System.out.println("PASS - expected exception - Feature not implemented");
				else System.out.println("Unexpected FAILURE at " +e);

			}
			try {
				System.out.println("Try passing array with Statement.executeUpdate");
				s.executeUpdate("insert into t11(c11) select c21 from t21", colPositions);
				System.out.println("ERROR: shouldn't be able to pass array with Statement.executeUpdate");
			} catch (SQLException e) {
				if (e.getSQLState() == null || e.getSQLState().startsWith("0A"))
					dumpExpectedSQLExceptions(e);
				else
					JDBCDisplayUtil.ShowSQLException(System.out,e);
			}

			System.out.println("Test21ps - insert select with columnIndexes[] array should fail");
			try {
				System.out.println("Try passing array with Connection.prepareStatement");
				ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colPositions);
				System.out.println("ERROR: shouldn't be able to pass array with Connection.prepareStatement");
			} catch (SQLException e) {
				if (e.getSQLState() == null || e.getSQLState().startsWith("0A"))
					dumpExpectedSQLExceptions(e);
				else
					JDBCDisplayUtil.ShowSQLException(System.out,e);
			}

			//Test22 - insert select with columnNames[] array
			System.out.println("Test22 - insert select with columnNames[] array should fail");
			String colNames[] = new String[1];
      colNames[0] = "C11";
			try {
				System.out.println("Try passing array with Statement.execute");
				s.execute("insert into t11(c11) select c21 from t21", colNames);
				System.out.println("ERROR: shouldn't be able to pass array with Statement.execute");
			} catch (SQLException e) {
				if (e.getSQLState() == null || e.getSQLState().startsWith("0A"))
					dumpExpectedSQLExceptions(e);
				else
					JDBCDisplayUtil.ShowSQLException(System.out,e);
			}
			try {
				System.out.println("Try passing array with Statement.executeUpdate");
				s.executeUpdate("insert into t11(c11) select c21 from t21", colNames);
				System.out.println("ERROR: shouldn't be able to pass array with Statement.executeUpdate");
			} catch (SQLException e) {
				if (e.getSQLState() == null || e.getSQLState().startsWith("0A"))
					dumpExpectedSQLExceptions(e);
				else
					JDBCDisplayUtil.ShowSQLException(System.out,e);
			}

			System.out.println("Test22ps - insert select with columnNames[] array should fail");
			try {
				System.out.println("Try passing array with Connection.prepareStatement");
				ps = con.prepareStatement("insert into t11(c11) select c21 from t21", colNames);
				System.out.println("ERROR: shouldn't be able to pass array with Connection.prepareStatement");
			} catch (SQLException e) {
				if (e.getSQLState() == null || e.getSQLState().startsWith("0A"))
					dumpExpectedSQLExceptions(e);
				else
					JDBCDisplayUtil.ShowSQLException(System.out,e);
			}
		con.rollback();
	}

	public static void doTest1920(Statement s, Connection con) throws SQLException
	{
			//Test19 - bug 4838 no auto generated key resultset generated for INSERT with
			//generated keys if server-side methods are invoked.
			//Adding the tests to try server side methods which toggle the auto generated flag
			//and make sure we don't loose the client side setting in the process
			System.out.println("Test19 - fix the no auto generated key resultset generated for INSERT with " +
			"generated keys if server-side methods are invoked");
			s.execute("CREATE FUNCTION MMWNI() RETURNS VARCHAR(20) LANGUAGE JAVA EXTERNAL NAME 'org.apache.derbyTesting.functionTests.tests.jdbcapi.autoGeneratedJdbc30.MyMethodWithNoInsert' PARAMETER STYLE JAVA READS SQL DATA");
			con.commit();
			s.execute("insert into t21 values(40,MMWNI())", Statement.RETURN_GENERATED_KEYS);
			System.out.println("Back to client side looking for auto generated keys");
			dumpRS(s.getGeneratedKeys());

			//Verify data in the table
			dumpRS(s.executeQuery("select count(*) from t21"));
			s.execute("delete from t11");

			s.execute("DROP FUNCTION MMWNI");
			con.commit();
			s.close();

			// Test 20 - BUG 4837 garbage collection of the generated key result sets was closing the activation.
			System.out.println("Test20 - bug 4837garbage collection of the generated key result sets was closing the activation.");
			PreparedStatement ps = con.prepareStatement("insert into t11(c11) values(?)", Statement.RETURN_GENERATED_KEYS);

			for (int i = 0; i < 100; i++) {
				ps.setInt(1, 100+i);
				ps.executeUpdate();

				ResultSet rs = ps.getGeneratedKeys();
				while (rs.next()) {
					rs.getInt(1);
				}
				rs.close();
				con.commit();

				System.runFinalization();
				System.gc();
				System.runFinalization();
				System.gc();
			}
	}
}
