Test autoGeneratedJdbc30 starting
Test 1 - request for generated keys resultset on a brand new statement with no sql executed on it yet
We will get a resultset with no rows because it is a non-insert sql
<NULL>
Test2 - request for generated keys on a statement which does select from a table ie a non-insert sql
We will get a resultset with no rows because it is a non-insert sql
<NULL>
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
<NULL>
Test 3 - insert multiple rows into a table with autogenerated key and request generated keys resultset
 We will get a row with NULL value because this insert sql inserted more than one row and 
 there was no prior one-row insert into a table with autogenerated key
	 1
	 -
	{3}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{6}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{9}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{12}
Test 4 - request for generated keys after doing an insert into a table with no auto generated keys
 And there has been no one-row insert into a table with auto-generated keys yet.
We should get a resultset with one row of NULL value from getGeneratedKeys
	 1
	 -
	{12}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{12}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{12}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{12}
Test 5a - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys
Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value
	 1
	 -
	{6}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{12}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{18}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Test 5b - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys
Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value
	 1
	 -
	{0}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{0}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{0}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{0}
Test 5c - request for generated keys after doing a one-row insert(using a subquery) into a table with autogenerated key using a subquery with auto generated keys
Even though this is a one-row insert but since insert has a sub-select, get generated keys will return one row of NULL value
	 1
	 -
	{25}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{26}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{27}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{28}
Test 6 - request for generated keys after doing a one-row insert into a table with auto generated keys
We should get a resultset with one row of non-NULL value
	 1
	 -
	{29}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{30}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{31}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{32}
Test 7 - Now try again inserting multiple rows into a table with autogenerated key and request generated keys resultset
 This time we will get a row of non-NULL value because there has been a prior one-row insert into table with auto-generated key 
	 1
	 -
	{15}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{18}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{21}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Test 8 - create a new statement and request for generated keys on it after doing an insert into 
 a table with no auto generated keys
We should get a resultset with one row of non-NULL value
	 1
	 -
	{24}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Test 9 - request for generated keys on a statement which does a update 
We should get a resultset with no rows from getGeneratedKeys because we executed a non-insert sql
<NULL>
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
<NULL>
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
<NULL>
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
<NULL>
Test 10 - request for generated keys on a statement which does a delete 
We should get a resultset with no rows from getGeneratedKeys because we executed a non-insert sql
<NULL>
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
<NULL>
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
<NULL>
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
<NULL>
Test 11 - do a commit and request for generated keys on a statement which does insert into a table with 
 no auto generated keys (previous transaction had a one-row insert on a table with auto-generated keys)
expected to see resultset with one row of NULL value but instead get one row of non-NULL value from getGeneratedKeys
	 1
	 -
	{24}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Test 12 - do a rollback and request for generated keys on a statement which does insert into a table with 
 no auto generated keys (previous transaction had a one-row insert on a table with auto-generated keys)
had expected to see resultset with one row of NULL value but instead get one row of non-NULL value from getGeneratedKeys
	 1
	 -
	{24}
Now try the same test again but this time with Statement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.execute. It should behave the same
	 1
	 -
	{24}
Now try the same test again but this time with PreparedStatement.executeUpdate. It should behave the same
	 1
	 -
	{24}
Test 13 - try savepoint rollback and see what happens to auto generated keys resultset
Inside the savepoint unit, issue a one-row insert into a table with auto generated keys
We should get a resultset with one row of non-NULL value
	 1
	 -
	{33}
Now rollback the savepoint unit, and make sure that autogenerated keys resultset still holds on to 
 value that got set inside the rolled back savepoint unit
	 1
	 -
	{33}
Test 14 - Look at metadata of a getGeneratedKeys resultset
The resultset will have one column only
Found 1 column in the resultset
Type of the column is DECIMAL
Precision of the column is 31
Scale of the column is 0
	 1
	 -
	{25}
Test 15 - Can not see the auto generated keys if insert is with NO_GENERATED_KEYS
<NULL>
<NULL>
<NULL>
<NULL>
Test 16 - Can not see the auto generated keys if insert is done jdbc 2.0 way ie with no generated key feature
<NULL>
<NULL>
<NULL>
<NULL>
Test 17 - non-insert with NO_GENERATED_KEYS
<NULL>
<NULL>
<NULL>
<NULL>
Test 18 - non-insert is done jdbc 2.0 way ie with no generated key feature
<NULL>
<NULL>
<NULL>
<NULL>
Test21 - insert select with columnIndexes[] array should fail
Try passing array with Statement.execute
PASS - expected exception - Feature not implemented
Try passing array with Statement.executeUpdate
PASS -- expected exception
SQLSTATE(0A000): Feature not implemented: executeUpdate(String, int[]).
Test21ps - insert select with columnIndexes[] array should fail
Try passing array with Connection.prepareStatement
PASS -- expected exception
SQLSTATE(0A000): Feature not implemented: prepareStatement(String, int[]).
Test22 - insert select with columnNames[] array should fail
Try passing array with Statement.execute
PASS -- expected exception
SQLSTATE(0A000): Feature not implemented: execute(String, String[]).
Try passing array with Statement.executeUpdate
PASS -- expected exception
SQLSTATE(0A000): Feature not implemented: executeUpdate(String, String[]).
Test22ps - insert select with columnNames[] array should fail
Try passing array with Connection.prepareStatement
PASS -- expected exception
SQLSTATE(0A000): Feature not implemented: prepareStatement(String, String[]).
Test autoGeneratedJdbc30 finished
