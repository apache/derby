# This file is used by our JDBC driver to determine values for methods
# from java.sql.DatabaseMetadata whose names match the property keys here.
#
# JDBC driver will take the value and perform
# a statement.execute() request on it, returning the result set or using the
# result set to produce an answer of the required type and format for the
# DatabaseMetadata method.  If the query has AS clauses in its select list items,
# you can be pretty sure that the JDBC driver was looking for a result set,
# because it specifies what it wants the column names to be.
#
#
# Note that property values can span multiple lines, by ending the line with a \
#
# Note: be sure to always enter SQL keywords in CAPS, this is both
# for convention, and because of the way the parser uppercases
# things (so it is purportedly faster that way).
# And also because it is the only way it will all work in Turkey where
# the turkish locale uppercases i to an upper case dotted i. ( bug 5362)
#
# REMIND: using SYSALIASES; need to deal with ProcedureColumns still.
# there are no procedures or metadata about them in our system yet.
#
# PROCEDURE_TYPE is always procedureResultUnknown for method aliases as it could map to
# multiple methods, some of which could return a value and some not.
#
getProcedures=\
	SELECT '' AS PROCEDURE_CAT, SCHEMANAME AS PROCEDURE_SCHEM, \
	    ALIAS AS PROCEDURE_NAME, \
		CAST (NULL AS INT) AS RESERVED1, CAST (NULL AS INT) AS RESERVED2, \
	    CAST (NULL AS INT) AS RESERVED3, \
		JAVACLASSNAME||'.'|| ALIASINFO->getMethodName() AS REMARKS, \
		CAST (java.sql.DatabaseMetaData::procedureNoResult AS SMALLINT) AS PROCEDURE_TYPE \
	FROM SYS.SYSALIASES, SYS.SYSSCHEMAS \
	WHERE ((1=1) OR ? IS NOT NULL) \
	AND (ALIASTYPE = 'P' AND SCHEMANAME LIKE ?) \
	AND SYS.SYSALIASES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
	AND ALIAS LIKE ? \
	ORDER BY 2,3
# getSchemas
#
getSchemas=\
	SELECT SCHEMANAME AS TABLE_SCHEM \
	FROM SYS.SYSSCHEMAS \
	ORDER BY TABLE_SCHEM

# REMIND: presently table_type is a single char, we match JDBC
# recommendations closer and make it a more obvious word.
# REMIND: fillers for catalog names' comparisons
# parameter 1 = catalog name pattern 
# parameter 2 = schema name pattern
# parameter 3 = table name pattern (should have like comparison)
# a list of table types is added to this query, in the form
# table_type in ('val1','val2',...)
#
# IMPORTANT NOTE:
# --------------
# As a list of table_types to serach for is added to this query,
# the ORDER BY clause below is also added as well, following the list:
# ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME
# Therefore, no need to mention it here.
#
getTables=\
	SELECT '' AS TABLE_CAT, SCHEMANAME AS TABLE_SCHEM,  \
		TABLENAME AS TABLE_NAME, \
		(CAST (RTRIM(TABLE_TYPE) AS VARCHAR(12))) \
		AS TABLE_TYPE, '' AS REMARKS \
	FROM \
		 SYS.SYSTABLES, \
	     SYS.SYSSCHEMAS, \
	     (VALUES ('T','TABLE'), \
			('S','SYSTEM TABLE'), ('V', 'VIEW')) T(TTABBREV,TABLE_TYPE) \
	WHERE (TTABBREV=TABLETYPE 	\
	  AND (SYS.SYSTABLES.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID) \
	  AND ((1=1) OR ? IS NOT NULL) \
	  AND (SYS.SYSSCHEMAS.SCHEMANAME LIKE ?) \
	  AND (TABLENAME LIKE ?))
#
# ORDER BY TABLE_TYPE, TABLE_SCHEM, TABLE_NAME
#
# See 'IMPORTANT NOTE' above
#

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are no catalogs or metadata about them in our system yet.
# would have order by table_cat if it mattered...
# ORDER BY TABLE_CAT
getCatalogs=\
	SELECT TABLE_CAT \
	FROM ( VALUES ('') ) AS CATALOGS(TABLE_CAT) \
	WHERE (1=0)

# parameter 1 = pattern for schema (must be empty string to return rows)
# parameter 2 = pattern for procedure (method) name
# parameter 3 = pattern for column (parameter) name
#
# vti.GetProcedureColumns does not convert the case of its column names to
# the language connection context casing. So delimited identifiers must be
# used to specify these column names and display names are used so that
# the column names of the result set use the database casing.
#
#
#
getProcedureColumns=\
	SELECT CAST (NULL AS VARCHAR(128)) AS PROCEDURE_CAT, \
	    SCHEMANAME AS PROCEDURE_SCHEM, \
	    A.ALIAS AS PROCEDURE_NAME, \
	    V."COLUMN_NAME" AS COLUMN_NAME, \
	    V."COLUMN_TYPE" AS COLUMN_TYPE, \
	    V."DATA_TYPE" AS DATA_TYPE, \
	    V."TYPE_NAME" AS TYPE_NAME, \
	    V."PRECISION" AS PRECISION, \
	    V."LENGTH" AS LENGTH, \
	    V."SCALE" AS SCALE, \
	    V."RADIX" AS RADIX, \
	    V."NULLABLE" AS NULLABLE, \
	    V."REMARKS" AS REMARKS, \
	    V."METHOD_ID" AS METHOD_ID, \
	    V."PARAMETER_ID" AS PARAMETER_ID \
	FROM \
	    SYS.SYSALIASES A, SYS.SYSSCHEMAS, \
	    NEW org.apache.derby.catalog.GetProcedureColumns(A.ALIASINFO, A.ALIASTYPE) V \
	WHERE \
		ALIASTYPE = 'P' AND SCHEMANAME LIKE ? \
		AND A.SCHEMAID = SYS.SYSSCHEMAS.SCHEMAID \
	    AND A.ALIAS LIKE ? AND \
            V."COLUMN_NAME" LIKE ? \
	ORDER BY PROCEDURE_SCHEM, PROCEDURE_NAME, METHOD_ID, PARAMETER_ID

# This wants a result set with a specific column name,
# so we wrap the values in a select to name it.
getTableTypes=\
	SELECT CAST (RTRIM(TABLE_TYPE) AS VARCHAR(12)) AS TABLE_TYPE \
	FROM (VALUES 'SYSTEM TABLE', 'TABLE', 'VIEW') TABLETYPES(TABLE_TYPE) \
	ORDER BY TABLE_TYPE

# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
# parameter 4 = pattern for column name
# REMIND: the true or is to guard against nulls
# REMIND: need to check that sqltype column starts with SERIALIZE...
#
# DECIMAL_DIGITS returns scale for DECIMAL and NUMERIC,
# otherwise it returns null.  This is as per JavaSoft.
#
# CHAR_OCTET_LENGTH returns maximumWidth() * 2 for
# character types to account for the fact that we
# java uses 2 bytes per char and getMaximumWidth()
# returns the string length, not the length in bytes.
#
getColumns=\
 	SELECT '' AS TABLE_CAT, \
		S.SCHEMANAME AS TABLE_SCHEM, \
		T.TABLENAME AS TABLE_NAME, \
		C.COLUMNNAME AS COLUMN_NAME, \
		(CAST (C.COLUMNDATATYPE.getJDBCTypeId() AS SMALLINT)) AS DATA_TYPE, \
		(CAST (C.COLUMNDATATYPE.getTypeName() \
		 AS VARCHAR(128))) AS TYPE_NAME, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::INTEGER, \
						 java.sql.Types::SMALLINT, \
						 java.sql.Types::TINYINT, \
						 java.sql.Types::BIGINT, \
						 java.sql.Types::REAL, \
						 java.sql.Types::DOUBLE,\
						 java.sql.Types::DECIMAL, \
						 java.sql.Types::NUMERIC, \
						 java.sql.Types::FLOAT)) THEN \
								C.COLUMNDATATYPE.getPrecision() ELSE \
				C.COLUMNDATATYPE.getMaximumWidth() END AS COLUMN_SIZE, \
		CAST( NULL AS INT) AS BUFFER_LENGTH, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::DECIMAL, 				\
						 java.sql.Types::NUMERIC)) THEN \
					C.COLUMNDATATYPE.getScale() ELSE \
					CAST(NULL AS INT) END \
			AS DECIMAL_DIGITS, 											\
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::REAL, 					\
						 java.sql.Types::DOUBLE,		\
						 java.sql.Types::FLOAT)) THEN 2 ELSE 10 END \
			AS NUM_PREC_RADIX, 											\
		CASE WHEN C.COLUMNDATATYPE.isNullable() THEN \
			java.sql.DatabaseMetaData::columnNullable ELSE \
			java.sql.DatabaseMetaData::columnNoNulls END AS NULLABLE, \
		'' AS REMARKS, \
		CASE WHEN (COLUMNDEFAULT IS NULL) THEN  \
		    (CASE WHEN (AUTOINCREMENTINC is NULL) THEN  \
			   CAST (NULL AS VARCHAR(254)) ELSE \
               'AUTOINCREMENT: start ' || \
							(CAST (RTRIM(CAST(AUTOINCREMENTSTART AS CHAR(12))) AS VARCHAR(12))) || \
							' increment ' || \
							(CAST (RTRIM(CAST(AUTOINCREMENTINC AS CHAR(12))) AS VARCHAR(12))) END ) ELSE \
 				CAST (COLUMNDEFAULT AS VARCHAR(254)) END AS COLUMN_DEF, \
		CAST( NULL AS INT) AS SQL_DATA_TYPE, \
		CAST( NULL AS INT) AS SQL_DATETIME_SUB, \
		CASE WHEN (C.COLUMNDATATYPE.getJDBCTypeId() IN (java.sql.Types::CHAR,	 				\
						 java.sql.Types::VARCHAR)) THEN \
					(CASE WHEN (C.COLUMNDATATYPE.getMaximumWidth() * 2.0 > 2147483647) THEN \
						2147483647 ELSE (C.COLUMNDATATYPE.getMaximumWidth() * 2) END) ELSE \
					CAST(NULL AS INT) END \
			AS CHAR_OCTET_LENGTH,										\
		C.COLUMNNUMBER AS ORDINAL_POSITION, \
		CASE WHEN C.COLUMNDATATYPE.isNullable() THEN 'YES' ELSE 'NO' END AS IS_NULLABLE \
	FROM SYS.SYSSCHEMAS S, \
			SYS.SYSTABLES T, \
			SYS.SYSCOLUMNS C \
	WHERE C.REFERENCEID = T.TABLEID AND S.SCHEMAID = T.SCHEMAID \
	  AND ((1=1) OR ? IS NOT NULL) \
	  AND (S.SCHEMANAME LIKE ?) AND (T.TABLENAME LIKE ?) AND (C.COLUMNNAME LIKE ?) \
	ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are none of these or metadata about them in our system yet.
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
# parameter 4 = pattern for column name
getColumnPrivileges=\
	SELECT * \
	FROM ( VALUES ('', '', '', '', '', '', '', '') ) \
		AS COLUMNPRIVILEGES ( TABLE_CAT, TABLE_SCHEM, TABLE_NAME, \
			COLUMN_NAME, GRANTOR, GRANTEE, \
			PRIVILEGE, IS_GRANTABLE ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=? OR ''=?)

# ORDER BY COLUMN_NAME, PRIVILEGE

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are none of these or metadata about them in our system yet.
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getTablePrivileges=\
	SELECT * \
	FROM ( VALUES ('', '', '', '', '', '', '') ) \
		AS TABLEPRIVILEGES (TABLE_CAT, TABLE_SCHEM, TABLE_NAME, \
			GRANTOR, GRANTEE, PRIVILEGE, IS_GRANTABLE ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=?) \
	ORDER BY TABLE_SCHEM, TABLE_NAME, PRIVILEGE

# REMIND: this query is set up to return 0 rows of the right shape, since
# there are none of these or metadata about them in our system yet.
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getVersionColumns=\
	SELECT * \
	FROM ( VALUES (1, '', 1, '', 1, 1, 1, 1) ) \
		AS VERSIONCOLUMNS (SCOPE, COLUMN_NAME, DATA_TYPE, \
			TYPE_NAME, COLUMN_SIZE, BUFFER_LENGTH, \
			DECIMAL_DIGITS, PSEUDO_COLUMN ) \
	WHERE (1=0) AND (((1=1) OR ? IS NOT NULL) OR ''=? OR ''=?)

# REMIND: update query when we have catalogs and SCHEMAS
# parameter 1 = pattern for catalog name
# parameter 2 = pattern for schema name
# parameter 3 = pattern for table name
getPrimaryKeys=\
	SELECT '' AS TABLE_CAT, S.SCHEMANAME AS TABLE_SCHEM, T.TABLENAME AS TABLE_NAME, \
		   COLS.COLUMNNAME AS COLUMN_NAME, \
		   CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) AS KEY_SEQ, \
		   CONS.CONSTRAINTNAME AS PK_NAME \
	FROM PROPERTIES joinOrder=FIXED \
			SYS.SYSTABLES T PROPERTIES index='SYSTABLES_INDEX1', \
			SYS.SYSSCHEMAS S PROPERTIES joinStrategy=NESTEDLOOP, index ='SYSSCHEMAS_INDEX1',  \
			SYS.SYSCONSTRAINTS CONS PROPERTIES joinStrategy=NESTEDLOOP, index ='SYSCONSTRAINTS_INDEX3',  \
			SYS.SYSKEYS KEYS PROPERTIES joinStrategy=NESTEDLOOP, index ='SYSKEYS_INDEX1', \
			SYS.SYSCONGLOMERATES CONGLOMS PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONGLOMERATES_INDEX1', \
			SYS.SYSCOLUMNS COLS PROPERTIES joinStrategy=NESTEDLOOP, index ='SYSCOLUMNS_INDEX1' \
	WHERE ((1=1) OR ? IS NOT NULL) AND S.SCHEMANAME LIKE ? AND T.TABLENAME LIKE ? AND \
		  T.SCHEMAID = S.SCHEMAID AND	\
		  T.TABLEID = COLS.REFERENCEID AND T.TABLEID = CONGLOMS.TABLEID AND \
		  CONS.TABLEID = T.TABLEID AND CONS.TYPE = 'P' AND \
		  CONS.CONSTRAINTID = KEYS.CONSTRAINTID AND \
		  (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
				0 END) <> 0 AND \
		  KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
	ORDER BY COLUMN_NAME 

########
# getCrossReference 
# 
# This query gives information about referenced keys
# and foreign keys.  It is used to satisfy 
# and getExportedKeys() AS well as getCrossReference().
#
# NOTE: this is the same query as getImportedKeys()
# except is has a different ORDER BY and extra parameters.
#
#param1 = pattern for the PRIMARY CATALOG name 
#param2 = pattern for the PRIMARY SCHEMA name 
#param3 = pattern for the PRIMARY TABLE name 
#
#param4 = pattern for the FOREIGN CATALOG name ('%' for getExportedKeys())
#param5 = pattern for the FOREIGN SCHEMA name ('%' for getExportedKeys())
#param6 = pattern for the FOREIGN TABLE name ('%' for getExportedKeys())
getCrossReference=\
SELECT ''AS PKTABLE_CAT, \
		PKTABLE_SCHEM, \
		PKTABLE_NAME, \
		PKCOLUMN_NAME, \
		'' AS FKTABLE_CAT, \
		S2.SCHEMANAME AS FKTABLE_SCHEM, \
		T2.TABLENAME AS FKTABLE_NAME, \
		COLS2.COLUMNNAME AS FKCOLUMN_NAME, \
		CAST (CONGLOMS2.DESCRIPTOR.getKeyColumnPosition( \
												COLS2.COLUMNNUMBER) \
										AS SMALLINT) AS KEY_SEQ, \
		CAST ((CASE WHEN F2.UPDATERULE='S' \
				THEN java.sql.DatabaseMetaData::importedKeyRestrict ELSE  \
				(CASE WHEN F2.UPDATERULE='R' \
				THEN java.sql.DatabaseMetaData::importedKeyNoAction ELSE \
				 java.sql.DatabaseMetaData::importedKeyNoAction END) END)  \
													AS SMALLINT) AS UPDATE_RULE, \
		CAST ((CASE WHEN F2.DELETERULE='S' \
				THEN java.sql.DatabaseMetaData::importedKeyRestrict ELSE  \
				(CASE WHEN F2.DELETERULE='R' \
				THEN java.sql.DatabaseMetaData::importedKeyNoAction ELSE \
				(CASE WHEN F2.DELETERULE='C' \
				THEN java.sql.DatabaseMetaData::importedKeyCascade ELSE \
				(CASE WHEN F2.DELETERULE='U' \
				THEN java.sql.DatabaseMetaData::importedKeySetNull ELSE \
				 java.sql.DatabaseMetaData::importedKeyNoAction END)END)ENd)END)  \
													AS SMALLINT) AS DELETE_RULE, \
		C2.CONSTRAINTNAME AS FK_NAME, \
		PK_NAME, \
		CAST (java.sql.DatabaseMetaData::importedKeyNotDeferrable \
												AS SMALLINT) AS DEFERRABILITY \
		FROM PROPERTIES joinOrder=FIXED \
			(SELECT C.CONSTRAINTID AS PK_ID, \
					CONSTRAINTNAME AS PK_NAME, \
					PKTB_SCHEMA AS PKTABLE_SCHEM,  \
					PKTB_NAME AS PKTABLE_NAME, \
					COLS.COLUMNNAME AS PKCOLUMN_NAME, \
					CONGLOMS.DESCRIPTOR.getKeyColumnPosition( \
												COLS.COLUMNNUMBER) AS KEY_SEQ \
					FROM PROPERTIES joinOrder=FIXED \
						(SELECT T.TABLEID AS PKTB_ID, \
							S.SCHEMANAME AS PKTB_SCHEMA, \
							T.TABLENAME AS PKTB_NAME \
						 FROM  \
							SYS.SYSTABLES t PROPERTIES index = 'SYSTABLES_INDEX1', \
							SYS.SYSSCHEMAS s PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSSCHEMAS_INDEX1' \
						 WHERE \
							((1=1) OR ? IS NOT NULL) \
							AND S.SCHEMANAME LIKE ? \
							AND T.TABLENAME LIKE ? \
							AND S.SCHEMAID = T.SCHEMAID \
						) AS PKTB (PKTB_ID, PKTB_SCHEMA, PKTB_NAME), \
					    SYS.SYSCONSTRAINTS C PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONSTRAINTS_INDEX3', \
						SYS.SYSKEYS K PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSKEYS_INDEX1', \
						SYS.SYSCONGLOMERATES CONGLOMS PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONGLOMERATES_INDEX1', \
						SYS.SYSCOLUMNS COLS PROPERTIES joinStrategy=NESTEDLOOP, index =  'SYSCOLUMNS_INDEX1' \
					WHERE  \
						PKTB.PKTB_ID = C.TABLEID \
						AND K.CONSTRAINTID = C.CONSTRAINTID  \
						AND PKTB.PKTB_ID = COLS.REFERENCEID \
						AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
									CONGLOMS.DESCRIPTOR.getKeyColumnPosition( \
													COLS.COLUMNNUMBER) ELSE \
													0 END) <> 0 \
						AND K.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
			) AS PKINFO(PK_ID, \
						PK_NAME, \
						PKTABLE_SCHEM, \
						PKTABLE_NAME, \
						PKCOLUMN_NAME, \
						KEY_SEQ), \
			SYS.SYSFOREIGNKEYS F2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSFOREIGNKEYS_INDEX1', \
			SYS.SYSCONSTRAINTS c2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONSTRAINTS_INDEX1',  \
			SYS.SYSTABLES T2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSTABLES_INDEX2',  \
			SYS.SYSSCHEMAS S2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSSCHEMAS_INDEX2', \
			SYS.SYSCONGLOMERATES CONGLOMS2 PROPERTIES joinStrategy = NESTEDLOOP, index = 'SYSCONGLOMERATES_INDEX1',  \
			SYS.SYSCOLUMNS COLS2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCOLUMNS_INDEX1' \
	WHERE  F2.keyCONSTRAINTID = PKINFO.PK_ID \
	AND PKINFO.KEY_SEQ = CONGLOMS2.DESCRIPTOR.getKeyColumnPosition(  \
															COLS2.COLUMNNUMBER)  \
	AND T2.TABLEID = C2.TABLEID \
	AND ((1=1) OR ? IS NOT NULL) \
	AND S2.SCHEMANAME LIKE ? \
	AND T2.TABLENAME LIKE ? \
	AND S2.SCHEMAID = T2.SCHEMAID  \
	AND F2.CONSTRAINTID = C2.CONSTRAINTID  \
	AND (CASE WHEN CONGLOMS2.DESCRIPTOR IS NOT NULL THEN \
		CONGLOMS2.DESCRIPTOR.getKeyColumnPosition(COLS2.COLUMNNUMBER) ELSE 0 END) <> 0 \
	AND F2.CONGLOMERATEID = CONGLOMS2.CONGLOMERATEID \
	AND C2.TABLEID = COLS2.REFERENCEID \
	ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, FK_NAME, KEY_SEQ

########
# getImportedKeys 
#
# NOTE: this is the same query AS getCrossReference()
# except is has a different ORDER BY and it doesn't take
# the primary key parameters
# 
#param1 = pattern for the FOREIGN CATALOG name
#param2 = pattern for the FOREIGN SCHEMA name 
#param3 = pattern for the FOREIGN TABLE name 
getImportedKeys=\
SELECT ''AS PKTABLE_CAT, \
		S.SCHEMANAME AS PKTABLE_SCHEM, \
		TABLENAME AS PKTABLE_NAME, \
		COLS.COLUMNNAME AS PKCOLUMN_NAME, \
		'' AS FKTABLE_CAT, \
		FKTABLE_SCHEM, \
		FKTABLE_NAME, \
		FKCOLUMN_NAME, \
		CAST (CONGLOMS.DESCRIPTOR.getKeyColumnPosition( \
												COLS.COLUMNNUMBER) \
										AS SMALLINT) AS KEY_SEQ, \
		CAST ((CASE WHEN FK_UPDATERULE='S' \
				THEN java.sql.DatabaseMetaData::importedKeyRestrict ELSE  \
				(CASE WHEN FK_UPDATERULE='R' \
				THEN java.sql.DatabaseMetaData::importedKeyNoAction ELSE \
				 java.sql.DatabaseMetaData::importedKeyNoAction END) END)  \
													AS SMALLINT) AS UPDATE_RULE, \
		CAST ((CASE WHEN FK_DELETERULE='S' \
				THEN java.sql.DatabaseMetaData::importedKeyRestrict ELSE  \
				(CASE WHEN FK_DELETERULE='R' \
				THEN java.sql.DatabaseMetaData::importedKeyNoAction ELSE \
				(CASE WHEN FK_DELETERULE='C' \
				THEN java.sql.DatabaseMetaData::importedKeyCascade ELSE \
				(CASE WHEN FK_DELETERULE='U' \
				THEN java.sql.DatabaseMetaData::importedKeySetNull ELSE \
				 java.sql.DatabaseMetaData::importedKeyNoAction END) END) END) END)  \
													AS SMALLINT) AS DELETE_RULE, \
		FK_NAME, \
		CONSTRAINTNAME AS PK_NAME, \
		CAST (java.sql.DatabaseMetaData::importedKeyNotDeferrable \
												AS SMALLINT) AS DEFERRABILITY \
		FROM PROPERTIES joinOrder=FIXED \
			(SELECT F2.keyCONSTRAINTID AS FK_ID, \
					FKTB_SCHEMA AS FKTABLE_SCHEM, \
					FKTB_NAME AS FKTABLE_NAME, \
					COLS2.COLUMNNAME AS FKCOLUMN_NAME, \
					CONGLOMS2.DESCRIPTOR.getKeyColumnPosition( \
												COLS2.COLUMNNUMBER) AS KEY_SEQ, \
					C2.CONSTRAINTNAME AS FK_NAME, \
					F2.DELETERULE AS FK_UPDATERULE, \
					F2.DELETERULE AS FK_DELETERULE \
					FROM PROPERTIES joinOrder=FIXED \
						(SELECT T2.TABLEID AS FKTB_ID, \
							S2.SCHEMANAME AS FKTB_SCHEMA, \
							T2.TABLENAME AS FKTB_NAME \
						 FROM  \
							SYS.SYSTABLES T2 PROPERTIES index = 'SYSTABLES_INDEX1', \
							SYS.SYSSCHEMAS S2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSSCHEMAS_INDEX1' \
						 WHERE \
							((1=1) OR ? IS NOT NULL) \
							AND S2.SCHEMANAME LIKE ? \
							AND T2.TABLENAME LIKE ? \
							AND S2.SCHEMAID = T2.SCHEMAID \
						) AS FKTB (FKTB_ID, FKTB_SCHEMA, FKTB_NAME), \
					    SYS.SYSCONSTRAINTS c2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONSTRAINTS_INDEX3', \
						SYS.SYSFOREIGNKEYS F2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSFOREIGNKEYS_INDEX1', \
						SYS.SYSCONGLOMERATES CONGLOMS2 PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONGLOMERATES_INDEX1', \
						SYS.SYSCOLUMNS COLS2 PROPERTIES joinStrategy=NESTEDLOOP, index =  'SYSCOLUMNS_INDEX1' \
					WHERE \
						FKTB.FKTB_ID = C2.TABLEID \
						AND F2.CONSTRAINTID = C2.CONSTRAINTID \
						AND FKTB.FKTB_ID = COLS2.REFERENCEID \
						AND (CASE WHEN CONGLOMS2.DESCRIPTOR IS NOT NULL THEN \
									CONGLOMS2.DESCRIPTOR.getKeyColumnPosition( \
													COLS2.COLUMNNUMBER) ELSE \
													0 END) <> 0 \
						AND F2.CONGLOMERATEID = CONGLOMS2.CONGLOMERATEID \
			) AS FKINFO(FK_ID, \
						FKTABLE_SCHEM, \
						FKTABLE_NAME, \
						FKCOLUMN_NAME, \
						KEY_SEQ, \
						FK_NAME, \
						FK_UPDATERULE, \
						FK_DELETERULE), \
			SYS.SYSCONSTRAINTS c PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCONSTRAINTS_INDEX1', \
			SYS.SYSTABLES T PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSTABLES_INDEX2', \
			SYS.SYSSCHEMAS S PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSSCHEMAS_INDEX2', \
			SYS.SYSKEYS K PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSKEYS_INDEX1', \
			SYS.SYSCONGLOMERATES CONGLOMS PROPERTIES joinStrategy = NESTEDLOOP, index = 'SYSCONGLOMERATES_INDEX1', \
			SYS.SYSCOLUMNS COLS PROPERTIES joinStrategy=NESTEDLOOP, index = 'SYSCOLUMNS_INDEX1' \
	WHERE T.TABLEID = C.TABLEID  \
	AND C.CONSTRAINTID = FKINFO.FK_ID  \
	AND FKINFO.KEY_SEQ = CONGLOMS.DESCRIPTOR.getKeyColumnPosition(  \
															COLS.COLUMNNUMBER) \
	AND S.SCHEMAID = T.SCHEMAID \
	AND K.CONSTRAINTID = C.CONSTRAINTID \
	AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
		CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE 0 END) <> 0  \
	AND K.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID  \
	AND C.TABLEID = COLS.REFERENCEID  \
	ORDER BY PKTABLE_CAT,  \
				PKTABLE_SCHEM, \
				PKTABLE_NAME, \
				PK_NAME, \
				KEY_SEQ

getTypeInfo=SELECT CAST (RTRIM(CAST (T1 AS CHAR(128))) AS VARCHAR(128)) AS TYPE_NAME, CAST (T2 AS SMALLINT) AS DATA_TYPE, \
T3 AS PRECISION, CAST (RTRIM(CAST(T4 AS CHAR(10))) AS VARCHAR(10)) AS LITERAL_PREFIX,CAST (RTRIM(T5) AS VARCHAR(10)) AS LITERAL_SUFFIX, \
CAST (RTRIM(CAST(T6 AS CHAR(20))) AS VARCHAR(20)) AS CREATE_PARAMS,T7 AS NULLABLE, T8 AS CASE_SENSITIVE, \
T9 AS SEARCHABLE,T10 AS UNSIGNED_ATTRIBUTE,T11 AS FIXED_PREC_SCALE, \
T12 AS AUTO_INCREMENT,CAST (RTRIM(CAST(T1 AS CHAR(128))) AS VARCHAR(128)) AS LOCAL_TYPE_NAME, \
T14 AS MINIMUM_SCALE,T15 AS MAXIMUM_SCALE,CAST (NULL AS INT) AS SQL_DATA_TYPE, \
CAST (NULL AS INT) AS SQL_DATETIME_SUB,T18 AS NUM_PREC_RADIX \
FROM ( VALUES \
('BIGINT',-5,19,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR),1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
('LONG VARCHAR FOR BIT DATA',-4,32700,'X''','''',CAST (NULL AS CHAR),1,FALSE,2,TRUE,FALSE,FALSE,0,0,0),\
('VARCHAR () FOR BIT DATA',-3,32762,'X''','''','length',1,FALSE,2,TRUE,FALSE,FALSE,0,0,2),\
('CHAR () FOR BIT DATA',-2,254,'X''','''','length',1,FALSE,2,TRUE,FALSE,FALSE,0,0,2),\
('LONG VARCHAR',-1,32700,'''','''',CAST (NULL AS CHAR),1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('LONG NVARCHAR',-1,32700,'''','''',CAST (NULL AS CHAR),1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('CHAR',1,254,'''','''','length',1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('NATIONAL CHAR',1,2147483647,'''','''','length',1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('NUMERIC',2,31,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision,scale',1,FALSE,2,FALSE,TRUE,FALSE,0,32767,10),\
('DECIMAL',3,31,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision,scale',1,FALSE,2,FALSE,TRUE,FALSE,0,32767,10),\
('INTEGER',4,10,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR),1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
('SMALLINT',5,5,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR),1,FALSE,2,FALSE,FALSE,TRUE,0,0,10),\
('FLOAT',6,52,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'precision',1,FALSE,2,FALSE,FALSE,FALSE,0,0,2),\
('REAL',7,23,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR),1,FALSE,2,FALSE,FALSE,FALSE,0,0,2),\
('DOUBLE',8,52,CAST (NULL AS CHAR),CAST (NULL AS CHAR),CAST (NULL AS CHAR),1,FALSE,2,FALSE,FALSE,FALSE,0,0,2),\
('VARCHAR',12,32672,'''','''','length',1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('NATIONAL CHAR VARYING',12,2147483647,'''','''','length',1,TRUE,3,TRUE,FALSE,FALSE,0,0,0),\
('DATE',91,10,'DATE''','''',CAST (NULL AS CHAR),1,FALSE,2,TRUE,FALSE,FALSE,0,0,0),\
('TIME',92,0,'TIME''','''',CAST (NULL AS CHAR),1,FALSE,2,TRUE,FALSE,FALSE,0,0,0),\
('TIMESTAMP',93,0,'TIMESTAMP''','''',CAST (NULL AS CHAR),1,FALSE,2,TRUE,FALSE,FALSE,0,0,0),\
('BLOB',2004,2147483647,CAST (NULL AS CHAR),CAST (NULL AS CHAR),'length',1,FALSE,1,CAST (NULL AS BOOLEAN),FALSE,CAST (NULL AS BOOLEAN),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER)),\
('CLOB',2005,2147483647,'''','''','length',1,TRUE,1,CAST (NULL AS BOOLEAN),FALSE,CAST (NULL AS BOOLEAN),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER),CAST (NULL AS INTEGER))\
) AS TYPEINFO(T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T14,T15,T18)


# parameter 1 = pattern for catalog name 
# parameter 2 = pattern for schema name 
# parameter 3 = pattern for table name 
# parameter 4 = only get unique Indexes if TRUE
# parameter 5 = approximate information allowed if TRUE
getIndexInfo=\
	SELECT '' AS TABLE_CAT, S.SCHEMANAME AS TABLE_SCHEM, T.TABLENAME AS TABLE_NAME, \
		   (CASE WHEN CONGLOMS.DESCRIPTOR.isUnique() THEN FALSE ELSE TRUE END) AS NON_UNIQUE, '' AS INDEX_QUALIFIER, \
		   CONGLOMS.CONGLOMERATENAME AS INDEX_NAME, \
		   java.sql.DatabaseMetaData::tableIndexOther AS TYPE, \
		   CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) AS ORDINAL_POSITION, \
		   COLS.COLUMNNAME AS COLUMN_NAME, \
		   CASE WHEN CONGLOMS.DESCRIPTOR.isAscending( \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER)) THEN 'A' ELSE 'D' END AS ASC_OR_DESC, \
		   CAST(NULL AS INT) AS CARDINALITY, \
		   CAST(NULL AS INT) AS PAGES, \
		   CAST(NULL AS VARCHAR(128)) AS FILTER_CONDITION \
	FROM SYS.SYSSCHEMAS S, \
			SYS.SYSTABLES T, \
			SYS.SYSCONGLOMERATES CONGLOMS, \
			SYS.SYSCOLUMNS COLS \
	WHERE T.TABLEID = CONGLOMS.TABLEID AND T.TABLEID = COLS.REFERENCEID \
	  AND T.SCHEMAID = S.SCHEMAID \
	  AND CONGLOMS.ISINDEX \
	  AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
				CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
				0 END) <> 0  \
	  AND ((1=1) OR ? IS NOT NULL) AND S.SCHEMANAME LIKE ? AND T.TABLENAME LIKE ? \
	  AND ( CASE WHEN ? THEN CONGLOMS.DESCRIPTOR.isUnique() ELSE (1=1) END) AND ((1=1) OR ?<>0) \
	ORDER BY NON_UNIQUE, TYPE, INDEX_NAME, ORDINAL_POSITION

############################################
# 
# getBestRowIdentifier queries
#
############################################

# getBestRowIdentifierEmpty
#
# Used when bad params passed into
# getBestRowIdentifier(); return empty result set 
# of the right shape 
#
getBestRowIdentifierEmpty=\
	SELECT * \
	FROM (VALUES \
		(CAST (2  AS SMALLINT), \
		 CAST ('' AS VARCHAR(128)), \
		 CAST (0  AS SMALLINT), \
		 CAST ('INT' AS VARCHAR(128)), \
		 0, \
		 0,	\
		 CAST (0 AS SMALLINT), \
		 CAST (0 AS SMALLINT)) \
		) AS BESTROWIDENTIFIER( \
		SCOPE, COLUMN_NAME, DATA_TYPE, TYPE_NAME, COLUMN_SIZE, BUFFER_LENGTH, \
		DECIMAL_DIGITS, PSEUDO_COLUMN) \
	WHERE (1=0)

# getBestRowIdentifierPrimaryKey 
#
# Find a primary key on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierPrimaryKey=\
	SELECT conS.CONSTRAINTID 	\
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys \
	WHERE TABS.TABLEID = conS.TABLEID \
			AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
			AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
			AND conS.type = 'P' \
			AND ((1=1) OR ? IS NOT NULL) \
			AND (SCHEMAS.SCHEMANAME LIKE ?)  \
			AND (TABS.TABLENAME LIKE ?) 

# getBestRowIdentifierPrimaryKeyColumns
#
# Return the columns that make up the primary key
#
# parameter1 - CONSTRAINTID from SYS.SYSCONSTRAINTS
# parameter2 - CONSTRAINTID from SYS.SYSKEYS
#
getBestRowIdentifierPrimaryKeyColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		CAST (COLS.COLUMNDATATYPE.getJDBCTypeId() AS SMALLINT) AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST (COLS.COLUMNDATATYPE.getPrecision() AS SMALLINT) AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, \
		SYS.SYSCONGLOMERATES CONGLOMS, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = conS.TABLEID \
		AND TABS.TABLEID = COLS.REFERENCEID \
		AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = ? \
		AND KEYS.CONSTRAINTID = ? \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
		AND TABS.TABLEID = CONGLOMS.TABLEID \
		AND KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
		AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
			CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) <> 0

# getBestRowIdentifierUniqueConstraint 
#
# See if there is a unique constraint on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierUniqueConstraint=\
	SELECT CONS.CONSTRAINTID, IDX.DESCRIPTOR.numberOfOrderedColumns() AS NUMCOLS \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, SYS.SYSCONGLOMERATES IDX \
	WHERE TABS.TABLEID = conS.TABLEID AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID AND IDX.DESCRIPTOR IS NOT NULL \
		AND KEYS.CONGLOMERATEID = IDX.CONGLOMERATEID AND IDX.ISCONSTRAINT \
		AND conS.type = 'U' \
		AND ((1=1) OR ? IS NOT NULL) \
		AND (SCHEMAS.SCHEMANAME LIKE ?) \
		AND (TABS.TABLENAME LIKE ?) \
	ORDER BY NUMCOLS

# getBestRowIdentifierUniqueKeyColumns
#
# Return the columns in the unique constraint
#
# parameter1 - CONSTRAINTID from SYS.SYSCONSTRAINTS
# parameter2 - CONSTRAINTID from SYS.SYSKEYS
# parameter3 - null ok
#
getBestRowIdentifierUniqueKeyColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		CAST (COLS.COLUMNDATATYPE.getJDBCTypeId() AS SMALLINT) AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST (COLS.COLUMNDATATYPE.getPrecision() AS SMALLINT) AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONSTRAINTS cons, SYS.SYSKEYS keys, \
		SYS.SYSCONGLOMERATES CONGLOMS, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = conS.TABLEID \
		AND TABS.TABLEID = COLS.REFERENCEID \
		AND SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND conS.CONSTRAINTID = ? \
		AND KEYS.CONSTRAINTID = ? \
		AND conS.CONSTRAINTID = KEYS.CONSTRAINTID \
		AND TABS.TABLEID = CONGLOMS.TABLEID \
		AND KEYS.CONGLOMERATEID = CONGLOMS.CONGLOMERATEID \
		AND (CASE WHEN CONGLOMS.DESCRIPTOR IS NOT NULL THEN \
			CONGLOMS.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) > 0 \
		AND (?<>0 or not COLS.COLUMNDATATYPE.isNullable() ) 

# getBestRowIdentifierUniqueIndex 
#
# See if there is a unique index on the given table
#
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
#
getBestRowIdentifierUniqueIndex=\
	SELECT IDX.CONGLOMERATENUMBER, IDX.DESCRIPTOR.numberOfOrderedColumns() AS NUMCOLS \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, SYS.SYSCONGLOMERATES IDX \
	WHERE SCHEMAS.SCHEMAID = TABS.SCHEMAID and not IDX.ISCONSTRAINT \
		AND TABS.TABLEID = IDX.TABLEID  \
		AND (CASE WHEN IDX.DESCRIPTOR IS NULL THEN (1=0) ELSE IDX.DESCRIPTOR.isUnique() END)  \
		AND ((1=1) OR ? IS NOT NULL) \
		AND (SCHEMAS.SCHEMANAME LIKE ?) \
		AND (TABS.TABLENAME LIKE ?) \
	ORDER BY NUMCOLS


# getBestRowIdentifierUniqueIndexColumns
#
# Return the index columns for the given indexnumber
#
# parameter1 - index number from SYS.SYSCONSTRAINTS
# parameter2 - null ok
#
getBestRowIdentifierUniqueIndexColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		CAST (COLS.COLUMNDATATYPE.getJDBCTypeId() AS SMALLINT) AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST (COLS.COLUMNDATATYPE.getPrecision() AS SMALLINT) AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS, \
		SYS.SYSCONGLOMERATES IDX, SYS.SYSCOLUMNS COLS \
	WHERE TABS.TABLEID = COLS.REFERENCEID and SCHEMAS.SCHEMAID = TABS.SCHEMAID \
		AND TABS.TABLEID = IDX.TABLEID and IDX.CONGLOMERATENUMBER = ? \
		AND (CASE WHEN IDX.DESCRIPTOR IS NOT NULL THEN \
			IDX.DESCRIPTOR.getKeyColumnPosition(COLS.COLUMNNUMBER) ELSE \
			0 END) > 0 \
		AND (?<>0 or not COLS.COLUMNDATATYPE.isNullable() )

# getBestRowIdentifierAllColumns 
#
# Return all columns as the unique identifier for this table.
# Used when 
# 
# parameter1 - catalog
# parameter2 - schema
# parameter3 - table
# parameter4 - scope
# parameter5 - null ok
#
getBestRowIdentifierAllColumns=\
	SELECT \
		CAST (java.sql.DatabaseMetaData::bestRowSession AS SMALLINT) AS SCOPE, \
		COLS.COLUMNNAME AS COLUMN_NAME, \
		CAST (COLS.COLUMNDATATYPE.getJDBCTypeId() AS SMALLINT) AS DATA_TYPE, \
		CAST (COLS.COLUMNDATATYPE.getTypeName() AS VARCHAR(128)) AS TYPE_NAME, \
		COLS.COLUMNDATATYPE.getMaximumWidth() AS COLUMN_SIZE, \
		CAST (NULL AS INT) AS BUFFER_LENGTH, \
		CAST (COLS.COLUMNDATATYPE.getPrecision() AS SMALLINT) AS DECIMAL_DIGITS, \
		CAST (java.sql.DatabaseMetaData::bestRowNotPseudo AS SMALLINT) AS PSEUDO_COLUMN \
	FROM SYS.SYSSCHEMAS SCHEMAS, SYS.SYSTABLES TABS,  \
		SYS.SYSCOLUMNS COLS  \
	WHERE COLS.REFERENCEID = TABS.TABLEID  \
	  AND TABS.SCHEMAID = SCHEMAS.SCHEMAID  \
	  AND ((1=1) OR ? IS NOT NULL)  \
	  AND (SCHEMAS.SCHEMANAME LIKE ?)  \
	  AND (TABS.TABLENAME LIKE ?) \
	  AND ? BETWEEN 0 AND 2  \
	  AND (?<>0 OR NOT COLS.COLUMNDATATYPE.isNullable())
# This one is added for new method getUDTs in jdbc for database metadata.
# First 2 parameters are catalog name and schema name. We don't have catalog names
# yet. Also, our class aliases are database wide and not schema wide and that's why
# we ignore the parameter for schema too. Third parameter is the name of the class
# alias to look for.
getUDTs=\
	SELECT \
		'' AS TYPE_CAT, \
		'' AS TYPE_SCHEM, \
		ALIAS AS TYPE_NAME, \
		JAVACLASSNAME AS CLASS_NAME, \
		CAST (? AS INT) AS DATA_TYPE, \
		'' AS REMARKS \
	FROM SYS.SYSALIASES \
	WHERE ((1=1) OR ? IS NOT NULL) AND ((1=1) OR ? IS NOT NULL) AND ALIAS LIKE ? \
	AND ?<>0 AND ALIASTYPE = 'C' \
	ORDER BY DATA_TYPE, TYPE_SCHEM, TYPE_NAME
