###################################################
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
###################################################

###################################################
#
# DO NOT EDIT THIS FILE!
#
# Instead, edit messages.xml. The ant MessageBuilder task takes
# messages.xml as input and from it generates this file.
#
###################################################


01001=Es wurde versucht, eine bereits gel\u00F6schte Zeile zu aktualisieren oder zu l\u00F6schen. Keine Zeile wurde aktualisiert oder gel\u00F6scht.

01003=Aus dem Argument einer Spaltenfunktion wurden Nullwerte eliminiert.

# Arguments:
#
#    {0} = authorizationID
#
01006=Die Berechtigung wurde dem Benutzer {0} nicht entzogen.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01007=Rolle {0} wurde der Authentifizierungs-ID {1} nicht entzogen.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01008=WITH ADMIN OPTION von Rolle {0} wurde der Authentifizierungs-ID {1} nicht entzogen.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01009=Generierte Spalte {0} wurde aus Tabelle {1} gel\u00F6scht.

0100E=Es wurde versucht, zu viele Ergebnismengen zur\u00FCckzugeben. 

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
01500=Der Constraint {0} in Tabelle {1} wurde gel\u00F6scht.

# Arguments:
#
#    {0} = viewName
#
01501=Die View {0} wurde gel\u00F6scht.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
01502=Der Trigger {0} in Tabelle {1} wurde gel\u00F6scht.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01503=Die Spalte {0} in Tabelle {1} wurde durch das Hinzuf\u00FCgen eines Constraints ungleich null ge\u00E4ndert.

# Arguments:
#
#    {0} = indexName
#
01504=Der neue Index ist ein Duplikat eines vorhandenen Indexes: {0}.

# Arguments:
#
#    {0} = dataValue
#
01505=Der Wert {0} ist m\u00F6glicherweise abgeschnitten.

# Arguments:
#
#    {0} = synonymName
#    {1} = objectName
#
01522=Das neu definierte Synonym ''{0}'' wurde in das Objekt ''{1}'' aufgel\u00F6st, das aktuell nicht definiert ist.

# Arguments:
#
#    {0} = databaseName
#
01J01=Die Datenbank ''{0}'' wurde nicht erstellt. Stattdessen wurde eine Verbindung zu einer vorhandenen Datenbank hergestellt.

01J02=Scroll-sensitive Cursor sind aktuell nicht implementiert.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
01J04=Die Klasse ''{0}'' f\u00FCr die Spalte ''{1}'' implementiert nicht java.io.Serializable oder java.sql.SQLData. Eine dieser Schnittstellen muss von Instanzen implementiert werden, damit sie gespeichert werden k\u00F6nnen.

01J05=Datenbankupgrade war erfolgreich. Die Datenbank steht zur Verwendung bereit. Die gespeicherten vorbereiteten Anweisungen waren nicht erfolgreich. Details hierzu finden Sie in der n\u00E4chsten Ausnahme.

01J06=ResultSet kann nicht aktualisiert werden. Die Abfrage wurde nicht f\u00FCr die Generierung eines aktualisierbaren ResultSet qualifiziert.

01J07=ResultSetHoldability wurde f\u00FCr eine globale Transaktion auf ResultSet.CLOSE_CURSORS_AT_COMMIT eingeschr\u00E4nkt.

# Arguments:
#
#    {0} = resultSetType
#    {1} = resultSetType
#
01J08=Der ResultSet-Typ {0} kann nicht ge\u00F6ffnet werden. Es wurde der ResultSet-Typ {1} ge\u00F6ffnet.

01J10=Scroll-sensitive Ergebnismengen werden vom Server nicht unterst\u00FCtzt. Erneute Zuordnung zu einem Vorw\u00E4rtscursor.

01J12=Vom Server kann kein Meldungstext abgerufen werden. Lesen Sie die n\u00E4chste Ausnahme. Die gespeicherte Prozedur SYSIBM.SQLCAMESSAGE ist nicht auf dem Server installiert. Wenden Sie sich an den Datenbankadministrator.

# Arguments:
#
#    {0} = number
#
01J13=Es wurden zu viele Zeilen ({0}) f\u00FCr eine Ganzzahl zur\u00FCckgegeben. Der zur\u00FCckgegebene Wert wird abgeschnitten.

01J14=Die SQL-Autorisierung wird verwendet, ohne dass zuvor die Authentifizierung aktiviert wurde.

# Arguments:
#
#    {0} = remainingDays
#    {1} = databaseName
#
01J15=Ihr Kennwort l\u00E4uft in {0} Tag(en) ab. Verwenden Sie die Prozedur SYSCS_UTIL.SYSCS_MODIFY_PASSWORD, um Ihr Kennwort in Datenbank ''{1}'' zu \u00E4ndern.

# Arguments:
#
#    {0} = databaseName
#
01J16=Ihr Kennwort ist veraltet. Um die Datenbank zu sch\u00FCtzen, aktualisieren Sie Ihr Kennwort bald. Verwenden Sie die Prozedur SYSCS_UTIL.SYSCS_MODIFY_PASSWORD, um Ihr Kennwort in Datenbank ''{0}'' zu \u00E4ndern.

07000=Mindestens ein Parameter der aktuellen Anweisung wurde nicht initialisiert.

# Arguments:
#
#    {0} = parameterName
#    {1} = procedureName
#
07004=Parameter {0} ist ein {1}-Prozedurparameter und muss vor der Ausf\u00FChrung mit CallableStatement.registerOutParameter registriert werden.

07009=Keine Inputparameter.

08000=Verbindung wurde von einer unbekannten Unterbrechung beendet.

08001.C.10=Es konnte keine Verbindung hergestellt werden, weil das Sicherheitstoken gr\u00F6\u00DFer als f\u00FCr das Netzwerkprotokoll maximal zul\u00E4ssig ist.

08001.C.11=Es konnte keine Verbindung hergestellt werden, weil die Benutzer-ID die L\u00E4nge null hat oder l\u00E4nger als f\u00FCr das Netzwerkprotokoll maximal zul\u00E4ssig ist.

08001.C.12=Es konnte keine Verbindung hergestellt werden, weil das Kennwort die L\u00E4nge null hat oder l\u00E4nger als f\u00FCr das Netzwerkprotokoll maximal zul\u00E4ssig ist.

08001.C.13=Es konnte keine Verbindung hergestellt werden, da der externe Name (EXTNAM) eine L\u00E4nge von null hat oder l\u00E4nger als die vom Netzwerkprotokoll zugelassene maximale L\u00E4nge ist.

08001.C.14=Es konnte keine Verbindung hergestellt werden, da der Servername (SRVNAM) eine L\u00E4nge von null hat oder l\u00E4nger als die vom Netzwerkprotokoll zugelassene maximale L\u00E4nge ist.

# Arguments:
#
#    {0} = propertyName
#
08001.C.1=Die erforderliche Derby-DataSource-Eigenschaft {0} ist nicht eingerichtet.

# Arguments:
#
#    {0} = error
#    {1} = serverName
#    {2} = portNumber
#    {3} = messageText
#
08001.C.2={0}: Fehler beim Herstellen der Verbindung zu Server {1} auf Port {2} mit Meldung {3}.

# Arguments:
#
#    {0} = error
#
08001.C.3=SocketException: ''{0}''

# Arguments:
#
#    {0} = error
#
08001.C.4=Auf Socket ''{0}'' kann kein Stream ge\u00F6ffnet werden.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08001.C.5=L\u00E4nge der Benutzer-ID ({0}) liegt au\u00DFerhalb des g\u00FCltigen Bereichs von 1 bis {1}.

# Arguments:
#
#    {0} = length
#    {1} = number
#
08001.C.6=L\u00E4nge des Kennworts ({0}) liegt au\u00DFerhalb des g\u00FCltigen Bereichs von 1 bis {1}.

08001.C.7=Benutzer-ID muss ungleich null sein.

08001.C.8=Kennwort muss ungleich null sein.

# Arguments:
#
#    {0} = databaseName
#
08001.C.9=Es konnte keine Verbindung hergestellt werden, weil der Datenbankname {0} l\u00E4nger als f\u00FCr das Netzwerkprotokoll maximal zul\u00E4ssig ist.

08003=Keine aktuelle Verbindung.

08003.C.1=getConnection() ist f\u00FCr eine geschlossene Verbindung im Pool ung\u00FCltig.

08003.C.2=Eine LOB-Methode wurde aufgerufen, nachdem die Verbindung beendet wurde.

08003.C.3=Die zugrunde liegende physische Verbindung ist veraltet oder beendet.

# Arguments:
#
#    {0} = connectionName
#
08004=Abgelehnte Verbindung: {0}

# Arguments:
#
#    {0} = reasonText
#
08004.C.1=Verbindung konnte nicht authentifiziert werden. Grund: {0}.

# Arguments:
#
#    {0} = databaseName
#
08004.C.2=Die Verbindung wurde zur\u00FCckgewiesen, weil die Datenbank {0} nicht gefunden wurde.

08004.C.3=Datenbankverbindung wurde verweigert.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.4=Benutzer ''{0}'' kann die Datenbank ''{1}'' nicht herunterfahren. Hierzu ist nur der Datenbankeigent\u00FCmer berechtigt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.5=Benutzer ''{0}'' kann die Datenbank ''{1}'' nicht (neu) verschl\u00FCsseln. Hierzu ist nur der Datenbankeigent\u00FCmer berechtigt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.6=Benutzer ''{0}'' kann kein Upgrade der Datenbank ''{1}'' erzwingen. Hierzu ist nur der Datenbankeigent\u00FCmer berechtigt.

# Arguments:
#
#    {0} = databaseName
#
08004.C.7=Verbindung mit Datenbank ''{0}'' verweigert. Die Datenbank befindet sich im Replication Slave-Modus.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.8=Benutzer ''{0}'' kann keinen Replikationsvorgang auf Datenbank ''{1}'' ausl\u00F6sen. Hierzu ist nur der Datenbankeigent\u00FCmer berechtigt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = exceptionMsg
#
08004.C.9=Benutzer ''{0}'' hat keine Berechtigung zum Herunterfahren des Systems [{1}].

# Arguments:
#
#    {0} = databaseName
#    {1} = exceptionMsg
#
08004.C.10=Systemberechtigung zum Erstellen von Datenbank ''{0}'' [{1}] kann nicht \u00FCberpr\u00FCft werden.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#    {2} = exceptionMsg
#
08004.C.11=Keine Berechtigung des Benutzers ''{0}'' zum Erstellen von Datenbank ''{1}'' [{2}].

08004.C.12=Verbindung konnte nicht authentifiziert werden. Entweder sind die eingegebenen Zugangsdaten ung\u00FCltig oder die Datenbank verwendet ein Kennwortverschl\u00FCsselungsschema, das mit dem starken Kennwortsubstitutions-Sicherheitsmechanismus nicht kompatibel ist. Wenn dieser Fehler nach dem Upgrade auftritt, erhalten Sie im Versionshinweis f\u00FCr DERBY-4483 Informationen zu Ihren M\u00F6glichkeiten.

08004.C.13=Benutzername oder Kennwort ist leer oder hat eine 0-L\u00E4nge.

# Arguments:
#
#    {0} = error
#
08006.C=Es wurde ein Netzwerkprotokollfehler festgestellt. Die Verbindung wurde beendet. {0}

08006.C.1=W\u00E4hrend des Zur\u00FCcksetzens einer Verbindung ist ein Fehler aufgetreten. Die Verbindung wurde beendet. Details finden Sie in den zugeh\u00F6rigen Ausnahmen.

# Arguments:
#
#    {0} = error
#
08006.C.2= SocketException: ''{0}''

# Arguments:
#
#    {0} = error
#
08006.C.3=Es wurde ein Kommunikationsfehler festgestellt. {0}

08006.C.4=W\u00E4hrend des verz\u00F6gerten Zur\u00FCcksetzens einer Verbindung ist ein Fehler aufgetreten. Die Verbindung wurde beendet. Details finden Sie in den zugeh\u00F6rigen Ausnahmen.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08006.C.5=Unzureichende Daten beim Lesen aus dem Netz. Erwartet wurden mindestens {0} Byte, empfangen wurden jedoch nur {1} Byte. Die Verbindung wurde beendet.

08006.C.6=Es wurde versucht, LOB-Daten vollst\u00E4ndig zu speichern, die f\u00FCr die JVM zu umfangreich sind. Die Verbindung wurde beendet.

08006.C.8=org.apache.derby.jdbc.EmbeddedDriver wurde nicht im JDBC-Treibermanager registriert.

# Arguments:
#
#    {0} = databaseName
#
08006.D=Datenbank ''{0}'' wird heruntergefahren.

# Arguments:
#
#    {0} = databaseName
#
08006.D.1=Datenbank ''{0}'' wurde gel\u00F6scht.

# Arguments:
#
#    {0} = featureName
#
0A000.S=Nicht implementiertes Feature: {0}.

# Arguments:
#
#    {0} = commandName
#
0A000.C.6=Der DRDA-Befehl {0} ist aktuell nicht implementiert. Die Verbindung wurde beendet.

0A000.S.1=JDBC-Methode noch nicht implementiert.

# Arguments:
#
#    {0} = methodName
#
0A000.S.2=JDBC-Methode {0} wird nicht vom Server unterst\u00FCtzt. F\u00FChren Sie ein Serverupgrade durch.

# Arguments:
#
#    {0} = propertyName
#
0A000.S.3=resultSetHoldability-Eigenschaft {0} wird nicht unterst\u00FCtzt.

0A000.S.4=cancel() wird nicht vom Server unterst\u00FCtzt.

# Arguments:
#
#    {0} = mechanismName
#
0A000.S.5=Sicherheitsmechanismus ''{0}'' wird nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = datatypeName
#
0A000.S.7=Der Datentyp ''{0}'' wird nicht unterst\u00FCtzt. 

# Arguments:
#
#    {0} = roleName
#
0P000=Ung\u00FCltige Rollenspezifikation, Rolle existiert nicht: ''{0}''.

# Arguments:
#
#    {0} = roleName
#
0P000.S.1=Ung\u00FCltige Rollenspezifikation, Rolle wurde weder aktuellem Benutzer noch PUBLIC zugewiesen: ''{0}''.

21000=Eine skalare Unterabfrage darf nur eine Zeile zur\u00FCckgeben.

# Arguments:
#
#    {0} = dataType
#    {1} = dataValue
#    {2} = length
#
22001=Beim Versuch, {0} ''{1}'' auf die L\u00E4nge {2} zu k\u00FCrzen, wurde ein Truncation-Fehler festgestellt.

# Arguments:
#
#    {0} = datatypeName
#
22003=Der resultierende Wert liegt au\u00DFerhalb des Bereichs f\u00FCr den Datentyp {0}.

# Arguments:
#
#    {0} = year
#    {1} = year
#
22003.S.1=Jahr ({0}) \u00FCberschreitet den Maximalwert ''{1}''.

22003.S.2=Dezimalzahlen d\u00FCrfen nicht mehr als 31 Stellen haben.

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22003.S.3=Bei der Konvertierung eines numerischen Datentyps von ''{0}'' in {1} ist es zu einem \u00DCberlauf gekommen.

# Arguments:
#
#    {0} = number
#    {1} = datatypeName
#
22003.S.4=Die L\u00E4nge ({0}) \u00FCberschreitet die maximale L\u00E4nge ({1}) f\u00FCr den Datentyp.

# Arguments:
#
#    {0} = typeName
#    {1} = typeName
#
22005.S.1=Ein Wert des Typs ''{0}'' kann nicht in den Typ ''{1}'' konvertiert werden. Die Codierung wird nicht unterst\u00FCtzt.

22005.S.2=Der erforderliche Zeichenkonverter ist nicht verf\u00FCgbar.

22005.S.3=Eine Unicode-Zeichenfolge kann nicht in eine EBCDIC-Zeichenfolge konvertiert werden.

# Arguments:
#
#    {0} = typeName
#    {1} = number
#    {2} = number
#
22005.S.4=Nicht erkannter JDBC-Typ. Typ: {0}, Spaltennummer: {1}, Spaltenindex: {2}

# Arguments:
#
#    {0} = parameterName
#
22005.S.5=Ung\u00FCltiger JDBC-Typ f\u00FCr den Parameter {0}

# Arguments:
#
#    {0} = datatypeName
#
22005.S.6=Nicht erkannter Java-SQL-Typ {0}

22005.S.7=Unicode-Zeichenfolge kann nicht in UTF-8-Zeichenfolge konvertiert werden

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22005=Es wurde versucht, einen Datenwert des Typs ''{0}'' aus einem Datenwert des Typs ''{1}'' abzurufen.

22007.S.180=Die Zeichenfolgendarstellung eines Datum-/Uhrzeitwertes liegt au\u00DFerhalb des Bereichs.

22007.S.181=Die Syntax der Zeichenfolgendarstellung eines Datum-/Uhrzeitwertes ist fehlerhaft.

# Arguments:
#
#    {0} = argument
#    {1} = functionName
#
22008.S=''{0}'' ist ein ung\u00FCltiges Argument f\u00FCr die Funktion {1}.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
2200H.S=Sequenzgenerator ''{0}.{1}'' z\u00E4hlt nicht zyklisch weiter. Es k\u00F6nnen keine Werte mehr von diesem Sequenzgenerator angefordert werden.

2200L=XML-Spalten zugeordnete Werte m\u00FCssen korrekt formatierte Dokumentknoten sein.

# Arguments:
#
#    {0} = parserError
#
2200M=Ung\u00FCltiges XML-Dokument: {0}

# Arguments:
#
#    {0} = operatorName
#
2200V=Ung\u00FCltiges Kontextelement f\u00FCr den Operator {0}. Kontextelemente m\u00FCssen korrekt formatierte Dokumentknoten sein.

2200W=XQuery-Serialisierungsfehler: Es wurde versucht, mindestens einen Top-Attributknoten zu serialisieren.

22011=Das zweite oder dritte Argument der Funktion SUBSTR liegt au\u00DFerhalb des Bereichs.

# Arguments:
#
#    {0} = offset
#    {1} = len
#    {2} = str
#
22011.S.1=Der Bereich f\u00FCr die Unterzeichenfolge mit der relativen Position {0} und der L\u00E4nge {1} liegt au\u00DFerhalb des g\u00FCltigen Bereichs f\u00FCr die Zeichenfolge: {2}.

22012=Es wurde eine Division durch null versucht.

# Arguments:
#
#    {0} = number
#
22013=Es wurde versucht, die Quadratwurzel einer negativen Zahl (''{0}'') zu ziehen.

# Arguments:
#
#    {0} = searchString
#    {1} = fromString
#    {2} = startIndex
#
22014=Die Anfangsposition f\u00FCr LOCATE ist ung\u00FCltig. Sie muss eine positive ganze Zahl sein. Der Index, bei dem die Suche beginnen soll, ist ''{2}''. Zu suchende Zeichenfolge: ''{0}''. Die Zeichenfolge, bei der die Suche beginnen soll, ist ''{1}''. 

# Arguments:
#
#    {0} = functionName
#    {1} = typeName
#    {2} = typeName
#    {3} = typeName
#
22015=Die Funktion ''{0}'' ist f\u00FCr die folgenden Typen nicht zul\u00E4ssig. Der erste Operand ist vom Typ ''{1}''. Der zweite Operand ist vom Typ ''{2}''. Der dritte Operand (Anfangsposition) ist vom Typ ''{3}''.

# Arguments:
#
#    {0} = typeName
#
22018=Ung\u00FCltiges Zeichenfolgenformat f\u00FCr den Typ {0}

# Arguments:
#
#    {0} = sequenceName
#
22019=Die Escape-Zeichenfolge ''{0}'' ist ung\u00FCltig. Die Escape-Zeichenfolge muss aus genau einem Zeichen bestehen. Sie muss ungleich null sein und darf nicht mehr als ein Zeichen enthalten.

# Arguments:
#
#    {0} = string
#
22020=Ung\u00FCltiger Trim-String ''{0}''. Der Trim-String muss genau ein Zeichen enthalten oder den Wert NULL aufweisen. Er kann nicht mehrere Zeichen umfassen.

22025=Auf das Escape-Zeichen muss ein Escape-Zeichen "_" oder ''''%'''' folgen. Ein anderes Folgezeichen ist nicht zul\u00E4ssig. Das Escape-Zeichen darf auch nicht das letzte Zeichen des Musters sein.

22027=Die integrierte Funktion TRIM() unterst\u00FCtzt nur das Entfernen eines Zeichens. Die integrierten Funktionen LTRIM() und RTRIM() unterst\u00FCtzen das Entfernen mehrerer Zeichen.

# Arguments:
#
#    {0} = number
#
22028=Die Zeichenfolge \u00FCberschreitet die maximale L\u00E4nge von {0}.

22501=Eine ESCAPE-Klausel NULL gibt nicht definierte Ergebnisse zur\u00FCck und ist nicht zul\u00E4ssig.

2201X=Ung\u00FCltige Zeilenanzahl f\u00FCr OFFSET, muss >= 0 sein.

2201W=Zeilenanzahl f\u00FCr FIRST/NEXT muss >= 1 und Zeilenanzahl f\u00FCr LIMIT muss >= 0 sein.

# Arguments:
#
#    {0} = string
#
2201Z=Ein Nullwert ist f\u00FCr das Argument {0} nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = columnName
#
23502=Die Spalte ''{0}'' akzeptiert keinen Nullwert.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = statementType
#    {3} = keyName
#
23503={2} in Tabelle ''{1}'' hat f\u00FCr Schl\u00FCssel {3} den Fremdschl\u00FCssel-Constraint ''{0}'' verletzt. Die Anweisung wurde zur\u00FCckgesetzt.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#
23505=Die Anweisung wurde abgebrochen, weil sie in einer f\u00FCr ''{1}'' definierten Vorgabe f\u00FCr einen eindeutigen oder Prim\u00E4rschl\u00FCssel-Constraint bzw. f\u00FCr einen von ''{0}'' identifizierten und eindeutigen Index zu einem duplizierten Schl\u00FCsselwert gef\u00FChrt h\u00E4tte.

# Arguments:
#
#    {0} = tableName
#    {1} = constraintName
#
23513=Der CHECK Constraint ''{1}'' wurde beim Ausf\u00FChren von INSERT oder UPDATE f\u00FCr Tabelle ''{0}'' verletzt.

24000=Ung\u00FCltiger Cursorstatus; keine aktuelle Zeile.

24501.S=Der angegebene Cursor ist nicht ge\u00F6ffnet.

25001=Eine Verbindung kann nicht beendet werden, solange noch eine Transaktion aktiv ist.

25001.S.1=Ung\u00FCltiger Transaktionsstatus: Aktive SQL-Transaktion.

25501=Schreibschutzeigenschaft f\u00FCr Verbindung kann nicht in einer aktiven Transaktion eingerichtet werden.

25502=F\u00FCr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff sind \u00C4nderungen von SQL-Daten nicht zul\u00E4ssig.

25503=F\u00FCr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff ist die DDL nicht zul\u00E4ssig.

25505=Ein Benutzer mit Lesezugriff oder der Benutzer einer schreibgesch\u00FCtzten Datenbank ist nicht berechtigt, den Schreibschutzmodus f\u00FCr eine Verbindung zu inaktivieren.

# Arguments:
#
#    {0} = authorizationID
#
28502=Der Benutzername ''{0}'' ist ung\u00FCltig. 

2D521.S.1=setAutoCommit(true) ist f\u00FCr eine globale Transaktion ung\u00FCltig.

2D521.S.2=Commit oder Rollback ist f\u00FCr eine Anwendungsausf\u00FChrungsumgebung ung\u00FCltig. 

# Arguments:
#
#    {0} = exception
#
38000=Bei der Auswertung eines Ausdrucks wurde die Ausnahme ''{0}'' ausgel\u00F6st.

38001=Die externe Routine ist nicht berechtigt, SQL-Anweisungen auszuf\u00FChren.

38002=Die Routine hat versucht, Daten zu modifizieren, wurde jedoch nicht als MODIFIES SQL DATA definiert.

38004=Die Routine hat versucht, Daten zu lesen, wurde jedoch nicht als READS SQL DATA definiert.

# Arguments:
#
#    {0} = type
#
39004=An eine Methode mit einem Parameter des Primitive-Typs ''{0}'' kann kein Nullwert \u00FCbergeben werden.

# Arguments:
#
#    {0} = savepointName
#
3B001.S=SAVEPOINT {0} ist nicht vorhanden oder in der aktuellen Transaktion nicht aktiv.

3B002.S=Die maximale Savepoint-Anzahl ist erreicht. 

3B501.S=In der aktuellen Transaktion ist bereits ein SAVEPOINT mit dem \u00FCbergebenen Namen vorhanden.

3B502.S=Es wurde "Release oder Rollback to Savepoint" angegeben. Der Savepoint ist jedoch nicht vorhanden.

# Arguments:
#
#    {0} = lockCycle
#    {1} = transactionID
#
40001=Eine Sperre konnte aufgrund eines Deadlocks nicht angefordert werden. Zyklus der Sperren und beantragten Sperren:\n{0}. Die ausgew\u00E4hlte Opfertransaktion ist XID: {1}.

40XC0=Nicht mehr verwendbare Anweisung. Die Ursache kann das Abfangen eines Transaktionsfehlers bestimmter Wertigkeit innerhalb dieser Anweisung sein.

40XD0=Container wurde geschlossen.

40XD1=Container wurde im Schreibschutzmodus ge\u00F6ffnet.

# Arguments:
#
#    {0} = containerName
#
40XD2=Container {0} kann nicht ge\u00F6ffnet werden. Er wurde gel\u00F6scht oder ist nicht vorhanden.

40XL1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden.

# Arguments:
#
#    {0} = tableDump
#
40XL1.T.1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden. Speicherauszug von lockTable: {0}

40XT0=Das Modul RawStore hat einen internen Fehler festgestellt.

40XT1=Beim Festschreiben der Transaktion wurde eine Ausnahme ausgel\u00F6st.

40XT2=Beim Zur\u00FCcksetzen von SAVEPOINT wurde eine Ausnahme ausgel\u00F6st.

40XT4=Es wurde versucht, eine noch aktive Transaktion zu schlie\u00DFen. Die Transaktion wurde abgebrochen.

40XT5=W\u00E4hrend einer internen Transaktion wurde eine Ausnahme ausgel\u00F6st.

40XT6=Datenbank ist im Ruhemodus, Transaktion kann nicht aktiviert werden. Warten Sie, bis die Datenbank wieder aktiv ist.

40XT7=Vorgang wird in einer internen Transaktion nicht unterst\u00FCtzt.

42000=Syntaxfehler oder Verletzung einer Zugriffsregel. Details k\u00F6nnen Sie den zus\u00E4tzlichen Fehlermeldungen entnehmen.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42500=Benutzer ''{0}'' hat keine {1} Berechtigung f\u00FCr Tabelle ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42501=Benutzer ''{0}'' hat keine {1} Berechtigung f\u00FCr Tabelle ''{2}''.''{3}'' mit GRANT erteilt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42502=Benutzer ''{0}'' hat keine {1} Berechtigung f\u00FCr Spalte ''{2}'' in Tabelle ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42503=Benutzer ''{0}'' hat keine {1} Berechtigung f\u00FCr Spalte ''{2}'' in Tabelle ''{3}''.''{4}'' mit GRANT erteilt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42504=Benutzer ''{0}'' hat keine Berechtigung f\u00FCr {1} auf {2} ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42505=Benutzer ''{0}'' hat keine Berechtigung f\u00FCr {1} auf {2} ''{3}''.''{4}'' mit GRANT erteilt.

# Arguments:
#
#    {0} = authorizationID
#    {1} = objectName
#    {2} = schemaName
#    {3} = tableName
#
42506=Benutzer ''{0}'' ist nicht Eigent\u00FCmer von {1} ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42507=Benutzer ''{0}'' darf den Vorgang im Schema ''{1}'' nicht ausf\u00FChren.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42508=Benutzer ''{0}'' darf das Schema ''{1}'' nicht erstellen. Diese Anweisung kann nur vom Datenbankeigent\u00FCmer abgesetzt werden.

# Arguments:
#
#    {0} = objectName
#
42509=Angegebener Vorgang GRANT oder REVOKE ist f\u00FCr Objekt ''{0}'' nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionName
#    {2} = schemaName
#    {3} = objectName
#
4250A=Benutzer ''{0}'' hat keine {1}-Berechtigung f\u00FCr Objekt ''{2}''.''{3}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
4250B=Ung\u00FCltige Datenbankautorisierungseigenschaft ''{0}={1}''.

# Arguments:
#
#    {0} = authorizationID
#
4250C=Benutzer ''{0}'' d\u00FCrfen nicht gleichzeitig in Autorisierungslisten f\u00FCr Lesezugriff und Vollzugriff enthalten sein.

# Arguments:
#
#    {0} = listName
#    {1} = authorizationID
#
4250D=Benutzer ''{1}'' wiederholt in der Zugriffsliste ''{0}'';

# Arguments:
#
#    {0} = authorizationID
#
4250E=Interner Fehler: Ung\u00FCltige ID {0} in der Liste der Anweisungsberechtigungen.

# Arguments:
#
#    {0} = sqlText
#
4251A=Anweisung {0} kann nur vom Datenbankeigent\u00FCmer ausgegeben werden.

4251B=PUBLIC ist reserviert und kann nicht als Benutzer-ID oder Rollenname verwendet werden.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
4251C=Rolle {0} kann nicht f\u00FCr {1} gew\u00E4hrt werden, da eine Zirkularit\u00E4t entstehen w\u00FCrde.

4251D=Nur der Datenbankeigent\u00FCmer kann diesen Vorgang ausf\u00FChren.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
4251E=Niemand kann die Spalte ''{0}''.''{1}'' anzeigen.

4251F=Sie k\u00F6nnen die Zugangsdaten des Datenbankeigent\u00FCmers nicht l\u00F6schen.

4251G=Legen Sie derby.authentication.builtin.algorithm auf einen g\u00FCltigen Message Digest-Algorithmus fest. Das aktuelle Authentifizierungsschema ist zu schwach f\u00FCr die NATIVE-Authentifizierung.

4251H=Ung\u00FCltige Angabe der NATIVE-Authentifizierung. Legen Sie derby.authentication.provider auf einen Wert in folgender Form fest NATIVE:$credentialsDB oder NATIVE:$credentialsDB:LOCAL (auf Systemebene).

# Arguments:
#
#    {0} = databaseName
#
4251I=Authentifizierung kann nicht ausgef\u00FChrt werden, weil die Datenbank f\u00FCr die Zugangsdaten ''{0}'' nicht vorhanden ist.

# Arguments:
#
#    {0} = propertyName
#
4251J=Der Wert f\u00FCr die Eigenschaft ''{0}'' ist nicht ordnungsgem\u00E4\u00DF formatiert.

4251K=Die ersten erstellten Zugangsdaten m\u00FCssen die Zugangsdaten des DBO sein.

# Arguments:
#
#    {0} = dbName
#
4251L=In der Eigenschaft "derby.authentication.provider" wird ''{0}'' als Name der Datenbank f\u00FCr die Zugangsdaten angegeben. Dies ist kein g\u00FCltiger Name f\u00FCr eine Datenbank.

# Arguments:
#
#    {0} = columnName
#
42601=Spalte ''{0}'' wurde in einer Anweisung ALTER TABLE als NOT NULL angegeben und die Klausel DEFAULT wurde nicht oder als DEFAULT NULL angegeben.

42601.S.372=Anweisung ALTER TABLE kann keine Spalte IDENTITY zu einer Tabelle hinzuf\u00FCgen.

# Arguments:
#
#    {0} = functionName
#
42605=Die Anzahl der Argumente f\u00FCr die Funktion ''{0}'' ist falsch.

# Arguments:
#
#    {0} = number
#
42606=Es wurde eine ung\u00FCltige Hexadezimalkonstante gefunden, die mit ''{0}'' beginnt.

42610=Es k\u00F6nnen nicht alle Argumente f\u00FCr die Funktion COALESCE/VALUE Parameter sein. Mindestens ein Argument darf kein Parameter sein.

# Arguments:
#
#    {0} = dataType
#
42611=Das Attribut "length", "precision" oder "scale" f\u00FCr die Spalte oder Typzuordnung ''{0}'' ist ung\u00FCltig. 

# Arguments:
#
#    {0} = clause
#
42613=Es liegen mehrere oder Konflikte verursachende Schl\u00FCsselw\u00F6rter mit der Klausel ''{0}'' vor.

# Arguments:
#
#    {0} = columnName
#
42621=Ein mit ''{0}'' definierter CHECK Constraint oder eine generierte Spalte ist ung\u00FCltig.

# Arguments:
#
#    {0} = name
#    {1} = number
#
42622=Der Name ''{0}'' ist zu lang. Die maximale L\u00E4nge liegt bei ''{1}''.

# Arguments:
#
#    {0} = name
#    {1} = context
#
42734=Der im Kontext ''{1}'' angegebene Name ''{0}'' ist nicht eindeutig.

42802=Die Anzahl der zugeordneten Werte stimmt nicht mit der Anzahl der angegebenen oder impliziten Spalten \u00FCberein.

# Arguments:
#
#    {0} = columnName
#
42803=Ein Ausdruck mit der Spalte ''{0}'' wird in der SELECT-Liste angezeigt und ist kein Bestandteil einer GROUP BY-Klausel.

# Arguments:
#
#    {0} = sqlText
#
42815.S.713=Der Ersatzwert f\u00FCr ''{0}'' ist ung\u00FCltig.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#
42815.S.171=Die Argumente ''{0}'' und ''{1}'' sind nach Datentyp, L\u00E4nge oder Argumentwerten inkompatibel.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42818=Vergleiche zwischen ''{0}'' und ''{1}'' werden nicht unterst\u00FCtzt. Typen m\u00FCssen vergleichbar sein. String-Typen m\u00FCssen dar\u00FCber hinaus eine \u00FCbereinstimmende Sortierung aufweisen. Wenn die Sortierung nicht \u00FCbereinstimmt, besteht alternativ die M\u00F6glichkeit, Operanden umzuformen, um so eine Standardsortierung zu erzwingen (Beispiel: SELECT tablename FROM sys.systables WHERE CAST(tablename AS VARCHAR(128)) \\= "T1")

# Arguments:
#
#    {0} = string
#
42820=Das Gleitkommaliteral ''{0}'' enth\u00E4lt mehr als 30 Zeichen.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42821=Spalten vom Typ ''{0}'' d\u00FCrfen keine Werte des Typs ''{1}'' enthalten. 

42824=Ein Operand von LIKE ist keine Zeichenfolge, oder der erste Operand ist keine Spalte.

# Arguments:
#
#    {0} = columnName
#
42831=''{0}'' kann Nullwerte enthalten und daher keine Spalte eines Prim\u00E4rschl\u00FCssels oder eines eindeutigen Schl\u00FCssels sein.

# Arguments:
#
#    {0} = columnName
#
42831.S.1=''{0}'' kann Nullwerte enthalten und daher keine Spalte eines Prim\u00E4rschl\u00FCssels sein.

# Arguments:
#
#    {0} = key
#
42834=SET NULL kann nicht angegeben werden, weil der Fremdschl\u00FCssel ''{0}'' keine Nullwerte enthalten darf. 

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42837=ALTER TABLE ''{0}'' gibt Attribute f\u00FCr die Spalte ''{1}'' an, die nicht mit der vorhandenen Spalte kompatibel sind.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42846=Die Typen ''{0}'' k\u00F6nnen nicht in ''{1}'' konvertiert werden.

# Arguments:
#
#    {0} = columnName
#
42877=Der qualifizierte Spaltenname ''{0}'' ist in der ORDER BY-Klausel nicht zul\u00E4ssig.

42878=Die ORDER BY-Klausel einer SELECT UNION-Anweisung unterst\u00FCtzt nur nicht-qualifizierte Spaltenreferenzen und Spaltenpositionsnummern. Andere Ausdr\u00FCcke werden nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = columnName
#
42879=Die ORDER BY-Klausel enth\u00E4lt eventuell keine Spalte ''{0}'', die die Abfrage DISTINCT angibt. Diese Spalte wird nicht im Abfrageergebnis angezeigt.

4287A=Die ORDER BY-Klausel gibt eventuell keinen Ausdruck an, da die Abfrage DISTINCT angibt.

# Arguments:
#
#    {0} = routineName
#    {1} = type
#
42884=Es wurde keine autorisierte Routine ''{0}'' des Typs ''{1}'' mit kompatiblen Argumenten gefunden.

# Arguments:
#
#    {0} = parameterMode
#    {1} = parameterName
#
42886=Der ''{0}''-Parameter ''{1}'' erfordert eine Parametermarke ''?''.

# Arguments:
#
#    {0} = columnName
#
42894=Der DEFAULT-Wert oder der Wert des Attributs IDENTITY ist f\u00FCr die Spalte ''{0}'' ung\u00FCltig.

428C1=Pro Tabelle ist nur eine Identit\u00E4tsspalte zul\u00E4ssig.

428EK=Der Qualifier f\u00FCr eine deklarierte globale tempor\u00E4re Tabelle muss SESSION sein.

42903=Ung\u00FCltige Verwendung einer Aggregatfunktion.

42908=Die Anweisung CREATE VIEW enth\u00E4lt keine Spaltenliste.

42909=Die Anweisung CREATE TABLE enth\u00E4lt keine Spaltenliste.

# Arguments:
#
#    {0} = key
#    {1} = detailedReason
#
42915=Fremdschl\u00FCssel ''{0}'' ist aus folgendem Grund ung\u00FCltig: ''{1}''. 

# Arguments:
#
#    {0} = synonym2
#    {1} = synonym1
#
42916=Synonym ''{0}'' kann nicht f\u00FCr ''{1}'' erstellt werden, da dies zu einer Synonymkette in Form einer Schleife f\u00FChren w\u00FCrde.

# Arguments:
#
#    {0} = schemaNamet
#
42939=Mit dem Schemanamen ''{0}'' kann kein Objekt erstellt werden.

# Arguments:
#
#    {0} = authorizationID
#
4293A=Es kann keine Rolle mit Namen ''{0}'' erstellt werden, das Pr\u00E4fix SYS ist reserviert.

# Arguments:
#
#    {0} = columnName
#
42962=LOB-Spalte oder der Parameter ''{0}'' ist in deklarierten globalen tempor\u00E4ren Tabellen oder Prozedurdefinitionen nicht zul\u00E4ssig. 

42995=Die angeforderte Funktion ist nicht auf globale tempor\u00E4re Tabellen anwendbar.

# Arguments:
#
#    {0} = error
#
42X01=Syntaxfehler: {0}.

# Arguments:
#
#    {0} = parserException
#
42X02={0}.

# Arguments:
#
#    {0} = columnName
#
42X03=Spaltenname ''{0}'' findet sich in mehr als einer Tabelle der FROM-Liste.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42X04=Spalte ''{0}'' ist in keiner Tabelle der FROM-Liste enthalten, wird in einer Join-Spezifikation angezeigt und befindet sich au\u00DFerhalb des Geltungsbereichs derselben oder in einer HAVING-Klausel und ist nicht in der GROUP BY-Liste enthalten. Wenn es sich um eine Anweisung CREATE oder ALTER TABLE handelt, ist ''{0}'' keine Spalte in der Zieltabelle.

# Arguments:
#
#    {0} = objectName
#
42X05=Tabelle/View ''{0}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = tableName
#
42X06=F\u00FCr die Tabelle ''{0}'' wurden zu viele Ergebnisspalten angegeben.

42X07=Null ist nur in einer VALUES-Klausel innerhalb einer INSERT-Anweisung zul\u00E4ssig.

# Arguments:
#
#    {0} = className
#    {1} = constructorName
#
42X08=Der Konstruktor f\u00FCr die Klasse ''{0}'' kann nicht als \u00E4u\u00DFere virtuelle Tabelle verwendet werden, da die Klasse ''{1}'' nicht implementiert. 

# Arguments:
#
#    {0} = tableName
#
42X09=Die Tabelle oder der Aliasname ''{0}'' wird in der FROM-Liste mehr als einmal verwendet.

# Arguments:
#
#    {0} = tableName
#
42X10=''{0}'' ist kein in diesem Bereich angezeigter Tabellenname.

# Arguments:
#
#    {0} = columnName
#
42X12=Spaltenname ''{0}'' wird in der Anweisung CREATE TABLE mehr als einmal angezeigt. 

# Arguments:
#
#    {0} = columnName
#
42X13=Spaltenname ''{0}'' wird in der Spaltenliste einer INSERT-Anweisung mehr als einmal angezeigt. 

# Arguments:
#
#    {0} = columnName
#    {1} = tableOrVTIName
#
42X14=''{0}'' ist keine Spalte in der Tabelle oder in VTI ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42X15=Spaltenname ''{0}'' wird in einer Anweisung ohne eine FROM-Liste angezeigt.

# Arguments:
#
#    {0} = columnName
#
42X16=Spaltenname ''{0}'' wird mehrfach in der SET-Klausel einer UPDATE-Anweisung angezeigt.

# Arguments:
#
#    {0} = joinOrder
#
42X17=Der Wert ''{0}'' ist in der Merkmalliste einer FROM-Klausel nicht als joinOrder-Spezifikation g\u00FCltig. Es sind nur die Werte FIXED und UNFIXED g\u00FCltig.

# Arguments:
#
#    {0} = dataType
#
42X19.S.1=Die WHERE- oder HAVING-Klausel oder die Definition CHECK CONSTRAINT ist ein Ausdruck des Typs ''{0}''. Es muss ein boolescher Ausdruck sein.

42X19.S.2=Die WHERE- oder HAVING-Klausel oder die CHECK CONSTRAINT-Definition ist ein nicht typisierter Parameterausdruck. Ein boolescher Ausdruck ist erforderlich.

42X20=Syntaxfehler; Ganzzahlliteral erwartet.

# Arguments:
#
#    {0} = cursorName
#
42X23=Cursor {0} kann nicht aktualisiert werden.

# Arguments:
#
#    {0} = columnName
#
42X24=Spalte {0} wird in der HAVING-Klausel referenziert, befindet sich aber nicht in der GROUP BY-Liste.

# Arguments:
#
#    {0} = functionName
#    {1} = 1
#
42X25=Die Funktion ''{0}'' ist f\u00FCr den Typ ''{1}'' nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
42X26=Die Klasse ''{0}'' f\u00FCr die Spalte ''{1}'' ist nicht vorhanden oder nicht zug\u00E4nglich. Diese Situation kann eintreten, wenn die Klasse nicht \u00F6ffentlich ist.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X28=Die zu l\u00F6schende Tabelle ''{0}'' ist keine Zieltabelle des Cursors ''{1}''.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X29=Die zu aktualisierende Tabelle ''{0}'' ist nicht die Zieltabelle des Cursors ''{1}''.

# Arguments:
#
#    {0} = cursorName
#
42X30=Cursor ''{0}'' wurde nicht gefunden. Pr\u00FCfen Sie, ob das automatische Festschreiben deaktiviert ist.

# Arguments:
#
#    {0} = columnName
#    {1} = cursorName
#
42X31=Spalte ''{0}'' ist nicht in der FOR UPDATE-Liste des Cursors ''{1}'' enthalten.

# Arguments:
#
#    {0} = tableName
#
42X32=Die Spaltenanzahl in der abgeleiteten Spaltenliste muss mit der Spaltenanzahl der Tabelle ''{0}'' \u00FCbereinstimmen.

# Arguments:
#
#    {0} = columnName
#
42X33=Die abgeleitete Spaltenliste enth\u00E4lt zweimal den Spaltennamen ''{0}''.

42X34=Es gibt einen ?- Parameter in der ausgew\u00E4hlten Liste. Dies ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = operatorName
#
42X35=Es ist nicht zul\u00E4ssig, dass beide Operanden von ''{0}'' ?- Parameter sind.

# Arguments:
#
#    {0} = operatorName
#
42X36=F\u00FCr den Operator ''{0}'' darf kein ?- Parameter als Operand angegeben werden.

# Arguments:
#
#    {0} = operatorName
#    {1} = type
#
42X37=Der un\u00E4re Operator ''{0}'' ist f\u00FCr den Typ ''{1}'' nicht zul\u00E4ssig.

42X38="SELECT *'''' ist nur in den Subquerys EXISTS und NOT EXISTS zul\u00E4ssig.

42X39=Eine Unterabfrage darf nur eine Spalte zur\u00FCckgeben.

42X40=Ein Operand einer NOT-Anweisung ist kein boolescher Operand. Das Ergebnis der Auswertung f\u00FCr den Operanden von NOT muss TRUE, FALSE oder UNKNOWN sein.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
42X41=Die Eigenschaft ''{0}'' ist in der Klausel einer FROM-Liste ung\u00FCltig. (Die Eigenschaft wurde auf ''{1}'' festgelegt.) 

# Arguments:
#
#    {0} = columnName
#
42X42=F\u00FCr die Spalte ''{0}'' ist kein Korrelationsname zul\u00E4ssig, weil die Spalte in der FOR UPDATE-Liste enthalten ist.

# Arguments:
#
#    {0} = className
#
42X43=Die von der Klasse bzw. dem Objekt ''{0}'' zur\u00FCckgegebenen ResultSetMetaData waren Nulldaten. Die ResultSetMetaData m\u00FCssen ungleich null sein, wenn diese Klasse als \u00E4u\u00DFere virtuelle Tabelle verwendet werden soll. 

# Arguments:
#
#    {0} = number
#
42X44=Ung\u00FCltige L\u00E4nge ''{0}'' in der Spaltenspezifikation.

# Arguments:
#
#    {0} = dataType
#    {1} = argumentNumber
#    {2} = operatorName
#
42X45={0} ist ein ung\u00FCltiger Typ f\u00FCr das Argument {1} von {2}.

# Arguments:
#
#    {0} = functionName
#
42X46=Es gibt mehrere Funktionen mit dem Namen ''{0}''. Verwenden Sie die vollst\u00E4ndige Signatur oder den spezifischen Namen.

# Arguments:
#
#    {0} = procedureName
#
42X47=Es gibt mehrere Prozeduren mit dem Namen ''{0}''. Verwenden Sie die vollst\u00E4ndige Signatur oder den spezifischen Namen.

# Arguments:
#
#    {0} = dataType
#    {1} = number
#
42X48=Wert ''{1}'' hat eine f\u00FCr ''{0}'' nicht g\u00FCltige Genauigkeit.

# Arguments:
#
#    {0} = invalidNumber
#
42X49=Wert ''{0}'' ist kein g\u00FCltiges ganzzahliges Literal.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X50=Es wurde keine mit dem Methodenaufruf {0}.{1}({2}) \u00FCbereinstimmende Methode gefunden, obwohl alle Kombinationen von Objekttypen und Primitive-Typen und alle m\u00F6glichen Typumsetzungen f\u00FCr die zul\u00E4ssigen Parameter des Methodenaufrufs versucht wurden. M\u00F6glicherweise ist die Methode vorhanden, jedoch keine \u00F6ffentliche und/oder statische Methode. Es kann auch sein, dass die Parametertypen beim Aufruf der Methode nicht konvertierbar sind.

# Arguments:
#
#    {0} = className
#
42X51=Die Klasse ''{0}'' ist nicht vorhanden oder es kann nicht auf die Klasse zugegriffen werden. Diese Situation kann eintreten, wenn die Klasse nicht \u00F6ffentlich ist.

# Arguments:
#
#    {0} = methodName
#    {1} = type
#
42X52=Das Aufrufen einer Methode (''{0}'') mit dem Java-Primitive-Typ ''{1}'' als Empf\u00E4nger ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = type
#
42X53=Das Pr\u00E4dikat LIKE kann nur mit dem Operand CHAR oder VARCHAR verwendet werden. Der Typ ''{0}'' ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = methodName
#
42X54=Der Empf\u00E4nger der Java-Methode ''{0}'' ist ein ?. Dies ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = tableName
#    {1} = tableName
#
42X55=Tabellenname ''{1}'' muss mit ''{0}'' identisch sein.

# Arguments:
#
#    {0} = viewName
#
42X56=Die Spaltenanzahl in der View-Spaltenliste stimmt nicht mit der Spaltenanzahl im zugrunde liegenden Abfrageausdruck in der View-Definition f\u00FCr ''{0}'' \u00FCberein.

# Arguments:
#
#    {0} = tableName
#    {1} = number
#
42X57=getColumnCount() f\u00FCr die \u00E4u\u00DFere virtuelle Tabelle ''{0}'' hat den ung\u00FCltigen Wert ''{1}'' zur\u00FCckgegeben. G\u00FCltige Werte sind gr\u00F6\u00DFer als oder gleich 1. 

# Arguments:
#
#    {0} = tableName
#
42X58=Die Spaltenanzahl auf der linken Seite von {0} muss mit der auf der rechten Seite \u00FCbereinstimmen.

42X59=Die Spaltenanzahl muss in allen VALUES-Konstruktoren identisch sein.

# Arguments:
#
#    {0} = insertMode
#    {1} = tableName
#
42X60=F\u00FCr Tabelle ''{1}'' wurde f\u00FCr die Eigenschaft "insertMode" der ung\u00FCltige Wert ''{0}'' angegeben.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#    {2} = sqlOperator
#
42X61=Die Typen ''{0}'' und ''{1}'' sind nicht mit {2} kompatibel.

# Arguments:
#
#    {0} = sqlText
#    {1} = schemaName
#
42X62=''{0}'' ist im Schema ''{1}'' nicht zul\u00E4ssig.

42X63=Die USING-Klausel hat keine Ergebnisse zur\u00FCckgegeben. Es k\u00F6nnen keine Parameter festgelegt werden. 

# Arguments:
#
#    {0} = propertyValue
#
42X64=In der Eigenschaftsliste wurde f\u00FCr die Eigenschaft "useStatistics" der ung\u00FCltige Wert ''{0}'' angegeben. Es sind nur die Werte TRUE und FALSE g\u00FCltig. 

# Arguments:
#
#    {0} = index
#
42X65=Index ''{0}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = columnName
#
42X66=Spaltenname ''{0}'' wird in der Anweisung CREATE INDEX mehr als einmal angezeigt.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X68=Es wurde kein Feld ''{0}'', das zur Klasse ''{1}'' geh\u00F6rt, gefunden. M\u00F6glicherweise ist das Feld vorhanden, jedoch nicht \u00F6ffentlich. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00F6ffentlich ist.

# Arguments:
#
#    {0} = fieldName
#    {1} = type
#
42X69=Es ist nicht zul\u00E4ssig, mit einem referenzierenden Ausdruck des Java-Primitive-Typs ''{1}'' ein Feld (''{0}'') zu referenzieren.

# Arguments:
#
#    {0} = tableName
#
42X70=Die Anzahl der Spalten in der Tabellenspaltenliste entspricht nicht der Anzahl der Spalten im zugrunde liegenden Abfrageausdruck in der Tabellendefinition f\u00FCr ''{0}''.

# Arguments:
#
#    {0} = datatypeName
#    {1} = columnName
#
42X71=Ung\u00FCltiger Datentyp ''{0}'' f\u00FCr Spalte ''{1}''.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X72=Es wurde kein statisches Feld ''{0}'', das zur Klasse ''{1}'' geh\u00F6rt, gefunden. M\u00F6glicherweise ist das Feld vorhanden, jedoch nicht \u00F6ffentlich und/oder statisch. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00F6ffentlich ist. 

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X73=Methodenaufl\u00F6sung f\u00FCr die Signatur {0}.{1}({2}) war nicht eindeutig. (Keine Methode mit maximaler Spezifik.)

42X74=Ung\u00FCltige Syntax f\u00FCr Anweisung CALL.

# Arguments:
#
#    {0} = className
#    {1} = parameterTypes
#
42X75=Es wurde kein Konstruktor mit der Signatur {0}({1}) gefunden. M\u00F6glicherweise sind die Parametertypen beim Aufruf der Methode nicht konvertierbar.

# Arguments:
#
#    {0} = columnName
#
42X76=F\u00FCr mindestens eine Spalte (''{0}'') des hinzuzuf\u00FCgenden prim\u00E4ren Schl\u00FCssels besteht keine Eintragspflicht. F\u00FCr alle Spalten eines Prim\u00E4rschl\u00FCssels muss Eintragspflicht gelten.

# Arguments:
#
#    {0} = columnPosition
#
42X77=Spaltenposition ''{0}'' befindet sich au\u00DFerhalb des Bereichs f\u00FCr den Abfrageausdruck.

# Arguments:
#
#    {0} = columnName
#
42X78=Spalte ''{0}'' ist nicht im Ergebnis des Abfrageausdrucks enthalten.

# Arguments:
#
#    {0} = columnName
#
42X79=Spaltenname ''{0}'' wird mehr als einmal im Ergebnis des Abfrageausdrucks angezeigt.

42X80=VALUES-Klausel muss mindestens ein Element enthalten. Leere Elemente sind nicht zul\u00E4ssig. 

42X81=Ein Abfrageausdruck muss mindestens eine Spalte zur\u00FCckgeben.

42X82=USING-Klausel hat mehr als eine Zeile zur\u00FCckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00E4ssig.

# Arguments:
#
#    {0} = index
#    {1} = constraintName
#
42X84=Index ''{0}'' wurde erstellt, um Constraint ''{1}'' zu erzwingen. Der Index kann nur gel\u00F6scht werden, wenn der Constraint gel\u00F6scht wird.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X85=Constraint ''{0}'' muss sich in demselben Schema wie Tabelle ''{1}'' befinden.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X86=ALTER TABLE war nicht erfolgreich. F\u00FCr Tabelle ''{1}'' ist kein Constraint ''{0}'' vorhanden. 

# Arguments:
#
#    {0} = expression
#
42X87=Mindestens ein Ergebnisausdruck (THEN oder ELSE) des Ausdrucks ''{0}'' muss ''?'' sein. 

42X88=Ein Bedingungsausdruck enth\u00E4lt einen nicht-booleschen Operanden. Das Ergebnis der Auswertung f\u00FCr den Operanden eines Bedingungsausdrucks muss TRUE, FALSE oder UNKNOWN sein. 

# Arguments:
#
#    {0} = type
#    {1} = type
#
42X89=Die Typen ''{0}'' und ''{1}'' sind untereinander nicht kompatibel. Keiner der Typen kann dem jeweils anderen zugeordnet werden. 

# Arguments:
#
#    {0} = tableName
#
42X90=F\u00FCr Tabelle ''{0}'' wurde mehr als ein Prim\u00E4rschl\u00FCssel-Constraint angegeben.

# Arguments:
#
#    {0} = constraintName
#
42X91=Constraint-Name ''{0}'' wird in der Anweisung CREATE TABLE mehr als einmal angezeigt. 

# Arguments:
#
#    {0} = columnName
#
42X92=Spaltenname ''{0}'' wird mehr als einmal in der Spaltenliste eines Constraints angezeigt.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42X93=Tabelle ''{0}'' enth\u00E4lt die Definition eines Constraints mit Spalte ''{1}'', der nicht in der Tabelle ist.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = objectName
#
42X94={0} ''{1}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = fileName
#
42X96=Der Datenbank-Classpath enth\u00E4lt die unbekannte JAR-Datei ''{0}''.

42X98=In einer VIEW-Definition sind Parameter nicht zul\u00E4ssig.

42X99=In einer TABLE-Definition sind Parameter nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = columnName
#    {1} = datatypeName
#
42XA0=Die Generierungsklausel f\u00FCr Spalte ''{0}'' hat den Datentyp ''{1}'', der dem deklarierten Datentyp der Spalte nicht zugewiesen werden kann.

# Arguments:
#
#    {0} = columnName
#
42XA1=Die Generierungsklausel f\u00FCr Spalte ''{0}'' enth\u00E4lt ein Aggregat. Dies ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = sqlObjectName
#
42XA2=''{0}'' kann nicht in einer Generation-Klausel angezeigt werden, da unter Umst\u00E4nden unzuverl\u00E4ssige Ergebnisse zur\u00FCckgegeben werden.

# Arguments:
#
#    {0} = columnName
#
42XA3=Unter Umst\u00E4nden ist das \u00DCberschreiben des Werts der generierten Spalte ''{0}'' nicht m\u00F6glich.

# Arguments:
#
#    {0} = columnName
#
42XA4=Die Generierungsklausel f\u00FCr Spalte ''{0}'' referenziert andere generierte Spalten. Dies ist nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = routineName
#
42XA5=Routine ''{0}'' gibt unter Umst\u00E4nden SQL-Code aus und kann daher nicht in einer Generation-Klausel enthalten sein.

# Arguments:
#
#    {0} = columnName
#
42XA6=''{0}'' ist eine generierte Spalte. Sie kann nicht Teil eines Fremdschl\u00FCssels sein, dessen referenzielle Aktion f\u00FCr DELETE entweder SET NULL oder SET DEFAULT lautet oder dessen referenzielle Aktion f\u00FCr UPDATE CASCADE lautet.

# Arguments:
#
#    {0} = columnName
#
42XA7=''{0}'' ist eine generierte Spalte. Sie k\u00F6nnen ihren Standardwert nicht \u00E4ndern.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42XA8=Sie k\u00F6nnen ''{0}'' nicht umbenennen, da die Generierungsklausel von Spalte ''{1}'' eine Referenz enth\u00E4lt.

# Arguments:
#
#    {0} = columnName
#
42XA9=Spalte ''{0}'' erfordert einen expliziten Datentyp. Der Datentyp kann nur f\u00FCr Spalten mit Generierungsklauseln \u00FCbersprungen werden.

# Arguments:
#
#    {0} = columnName
#
42XAA=Der NEW-Wert der generierten Spalte ''{0}'' wird in der BEFORE-Aktion eines Triggers genannt. Dies ist nicht zul\u00E4ssig.

42XAB=NOT NULL ist nur zul\u00E4ssig, wenn Sie einen Datentyp explizit deklarieren.

42XAC="INCREMENT BY"-Wert darf nicht null sein.

# Arguments:
#
#    {0} = argName
#    {1} = datatypeName
#    {2} = minValue
#    {3} = maxValue
#
42XAE=Wert ''{0}'' liegt au\u00DFerhalb des Bereichs f\u00FCr Datentyp ''{1}''. Er muss zwischen ''{2}'' und ''{3}'' liegen.

# Arguments:
#
#    {0} = minValue
#    {1} = maxValue
#
42XAF=Ung\u00FCltiger "MINVALUE"-Wert ''{0}''. Er muss kleiner als "MAXVALUE: {1}'' sein.

# Arguments:
#
#    {0} = startValue
#    {1} = minValue
#    {2} = maxValue
#
42XAG=Ung\u00FCltiger "START WITH"-Wert ''{0}''. Er muss zwischen ''{1}'' und ''{2}'' liegen.

42XAH=Ein NEXT VALUE FOR-Ausdruck kann in vielen Kontexten nicht angezeigt werden, einschlie\u00DFlich der Klauseln WHERE, ON, HAVING, ORDER BY, DISTINCT, CASE, GENERATION und AGGREGATE sowie WINDOW-Funktionen und CHECK CONSTRAINTS.

# Arguments:
#
#    {0} = sequenceName
#
42XAI=Die Anweisung referenziert die folgende Sequenz mehrmals: ''{0}''.

# Arguments:
#
#    {0} = clauseName
#
42XAJ=Die CREATE SEQUENCE-Anweisung weist eine redundante Klausel des Typs ''{0}'' auf.

# Arguments:
#
#    {0} = className
#
42Y00=Klasse ''{0}'' implementiert nicht org.apache.derby.iapi.db.AggregateDefinition und kann deshalb nicht als Aggregatausdruck verwendet werden.

# Arguments:
#
#    {0} = constraintName
#
42Y01=Constraint ''{0}'' ist ung\u00FCltig.

# Arguments:
#
#    {0} = statement
#
42Y03.S.0=''{0}'' wurde nicht als Funktion oder Prozedur erkannt.

# Arguments:
#
#    {0} = statement
#
42Y03.S.1=''{0}'' wurde nicht als Prozedur erkannt.

# Arguments:
#
#    {0} = statement
#
42Y03.S.2=''{0}'' wurde nicht als Funktion erkannt.

# Arguments:
#
#    {0} = name
#
42Y04=F\u00FCr die Funktion mit EXTERNAL NAME ''{0}'' kann keine Prozedur oder Funktion erstellt werden, weil keine Liste in Schreibweise mit Trennzeichen vorliegt. Das erwartete Format ist <vollst\u00E4ndiger Java-Pfad>.<Methodenname>. 

# Arguments:
#
#    {0} = key
#
42Y05=Es gibt keinen Fremdschl\u00FCssel mit dem Namen ''{0}''.

# Arguments:
#
#    {0} = schemaNamet
#
42Y07=Schema ''{0}'' ist nicht vorhanden.

42Y08=F\u00FCr Systemtabellen sind Fremdschl\u00FCssel-Constraints nicht zul\u00E4ssig.

42Y09=Void-Methoden sind nur in einer CALL-Anweisung erlaubt.

42Y10=Bei einem Tabellenkonstruktor, der nicht in einer INSERT-Anweisung enthalten ist, befinden sich alle ?-Parameter in einer der Spalten. F\u00FCr jede Spalte muss mindestens eine der Zeilen einen nichtparametrischen Wert enthalten.

# Arguments:
#
#    {0} = clauseName
#
42Y11=F\u00FCr die Klausel ''{0}'' ist eine Join-Spezifikation erforderlich.

# Arguments:
#
#    {0} = expressionType
#
42Y12=Die ON-Klausel f\u00FCr ein JOIN ist ein Ausdruck vom Typ ''{0}''. Es muss ein Boolescher Ausdruck sein.

# Arguments:
#
#    {0} = columnName
#
42Y13=Spaltenname ''{0}'' wird in der Anweisung CREATE VIEW mehr als einmal angezeigt.

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
42Y16=In der Klasse ''{1}'' wurde keine \u00F6ffentliche statische Methode ''{0}'' gefunden. M\u00F6glicherweise ist die Methode vorhanden, jedoch keine \u00F6ffentliche und/oder statische Methode. 

# Arguments:
#
#    {0} = aggregateType
#    {1} = type
#
42Y22=Aggregat {0} kann nicht f\u00FCr den Typ {1} verwendet werden.

# Arguments:
#
#    {0} = colunmName
#
42Y23=F\u00FCr Spalte {0} wurde eine falsche JDBC-Typangabe zur\u00FCckgegeben.

# Arguments:
#
#    {0} = viewName
#
42Y24=View ''{0}'' kann nicht aktualisiert werden. (Views k\u00F6nnen aktuell nicht aktualisiert werden.) 

# Arguments:
#
#    {0} = tableName
#
42Y25=''{0}'' ist eine Systemtabelle. Benutzer d\u00FCrfen den Inhalt dieser Tabelle nicht \u00E4ndern.

42Y26=Aggregate sind in der GROUP BY-Liste nicht zul\u00E4ssig.

42Y27=Parameter sind in der Triggeraktion nicht zul\u00E4ssig.

42Y29=Die SELECT-Liste einer nicht gruppierten Abfrage enth\u00E4lt mindestens einen ung\u00FCltigen Ausdruck. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00E4lt, m\u00FCssen alle Eintr\u00E4ge g\u00FCltige Aggregatausdr\u00FCcke sein.

42Y30=Die SELECT-Liste einer gruppierten Abfrage enth\u00E4lt mindestens einen ung\u00FCltigen Ausdruck. Eine SELECT-Liste mit GROUP BY darf nur g\u00FCltige Gruppierungsausdr\u00FCcke und g\u00FCltige Aggregatausdr\u00FCcke enthalten. 

# Arguments:
#
#    {0} = className
#    {1} = aggregateName
#    {2} = type
#
42Y32=Aggregatorklasse ''{0}'' f\u00FCr das Aggregat ''{1}'' des Typs {2} implementiert nicht org.apache.derby.iapi.sql.execute.ExecAggregator. 

# Arguments:
#
#    {0} = aggregateName
#
42Y33=Aggregat {0} enth\u00E4lt mindestens ein Aggregat.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
42Y34=Spaltenname ''{0}'' stimmt mit mehr als einer Ergebnisspalte in der Tabelle ''{1}'' \u00FCberein.

# Arguments:
#
#    {0} = reference
#
42Y35=Spaltenreferenz ''{0}'' ist ung\u00FCltig. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00E4lt, m\u00FCssen alle Eintr\u00E4ge g\u00FCltige Aggregatausdr\u00FCcke sein. 

# Arguments:
#
#    {0} = reference
#
42Y36=Spaltenreferenz ''{0}'' ist ung\u00FCltig oder Teil eines ung\u00FCltigen Ausdrucks. Bei einer SELECT-Liste mit GROUP BY d\u00FCrfen die ausgew\u00E4hlten Spalten und Ausdr\u00FCcke nur g\u00FCltige Gruppierungsausdr\u00FCcke und g\u00FCltige Aggregatausdr\u00FCcke enthalten.

# Arguments:
#
#    {0} = javaTypeName
#
42Y37=''{0}'' ist ein Java-Primitive-Typ und kann nicht mit diesem Operator verwendet werden.

# Arguments:
#
#    {0} = tableName
#
42Y38=insertMode \\= replace ist f\u00FCr eine Einf\u00FCgung nicht zul\u00E4ssig, bei der SELECT die Zieltabelle ''{0}'' referenziert.

# Arguments:
#
#    {0} = sqlObjectName
#
42Y39=''{0}'' darf nicht in einer CHECK CONSTRAINT-Definition angezeigt werden, da dies zu unvorhersehbaren Ergebnissen f\u00FChren k\u00F6nnte.

# Arguments:
#
#    {0} = columnName
#    {1} = triggerName
#
42Y40=''{0}'' wird mehrfach in der Spalte UPDATE OF des Triggers ''{1}'' angezeigt.

# Arguments:
#
#    {0} = storedPreparedStatementName
#
42Y41=''{0}'' kann nicht direkt mit EXECUTE STATEMENT aufgerufen werden, da dieses Objekt Teil eines Triggers ist.

# Arguments:
#
#    {0} = dataType
#    {1} = scaleValue
#
42Y42=Nachkommastellenangabe ''{1}'' ist keine g\u00FCltige Angabe f\u00FCr {0}.

# Arguments:
#
#    {0} = scaleValue
#    {1} = precision
#
42Y43=Nachkommastellenangabe ''{0}'' ist keine g\u00FCltige Angabe mit einer Gesamtstellenzahl von ''{1}''.

# Arguments:
#
#    {0} = key
#    {1} = key
#
42Y44=In der Eigenschaftsliste einer FROM-Liste wurde der ung\u00FCltige Schl\u00FCssel ''{0}'' angegeben. Aktuell werden folgende Schl\u00FCssel unter Beachtung der Gro\u00DF-/Kleinschreibung unterst\u00FCtzt: ''{1}'' 

# Arguments:
#
#    {0} = vtiName
#
42Y45=Der VTI ''{0}'' kann nicht gebunden werden, weil es sich um einen spezifischen Trigger-VTI handelt und diese Anweisung nicht zu einer Triggeraktion oder WHEN-Klausel geh\u00F6rt.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y46=Ung\u00FCltige Merkmalliste in FROM-Liste. F\u00FCr die Tabelle ''{1}'' gibt es keinen Index ''{0}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42Y48=Ung\u00FCltige Eigenschaftsliste in FROM-Liste. Entweder ist in Tabelle ''{1}'' kein benannter Constraint ''{0}'' vorhanden oder es gibt keinen Sicherungsindex f\u00FCr den Constraint.

# Arguments:
#
#    {0} = key
#
42Y49=F\u00FCr den Eigenschaftsschl\u00FCssel ''{0}'' wurden mehrere Werte angegeben. 

# Arguments:
#
#    {0} = tableName
#
42Y50=Eigenschaftsliste f\u00FCr Tabelle ''{0}'' darf Indexwerte oder Werte f\u00FCr Constraint enthalten, jedoch nicht beide zusammen.

# Arguments:
#
#    {0} = sqlText
#    {1} = sqlObjectName
#
42Y55=''{0}'' kann nicht f\u00FCr ''{1}'' ausgef\u00FChrt werden, da dieses Objekt nicht vorhanden ist.

# Arguments:
#
#    {0} = strategyValue
#    {1} = tableName
#
42Y56=In der Eigenschaftsliste f\u00FCr Tabelle ''{1}'' wurde die ung\u00FCltige Join-Strategie ''{0}'' angegeben. Derzeit werden folgende Werte als Join-Strategie unterst\u00FCtzt: "hash" und "nestedloop".

# Arguments:
#
#    {0} = invalidNumber
#    {1} = optimizerOverrideName
#
42Y58=Beim Konvertieren des Wertes ''{0}'' f\u00FCr den vorrangigen Optimizer-Wert ''{1}'' ist eine NumberFormatException eingetreten.

# Arguments:
#
#    {0} = invalidNumber
#
42Y59=F\u00FCr das \u00DCberschreiben von hashInitialCapacity wurde der ung\u00FCltige Wert ''{0}'' angegeben. Der Wert muss gr\u00F6\u00DFer als 0 sein.

# Arguments:
#
#    {0} = invalidNumber
#
42Y60=F\u00FCr das \u00DCberschreiben von hashLoadFactor wurde der ung\u00FCltige Wert ''{0}'' angegeben. Der Wert muss gr\u00F6\u00DFer als 0.0 und kleiner als oder gleich 1.0 sein.

# Arguments:
#
#    {0} = invalidNumber
#
42Y61=F\u00FCr das \u00DCberschreiben von hashMaxCapacity wurde der ung\u00FCltige Wert ''{0}'' angegeben. Der Wert muss gr\u00F6\u00DFer als 0 sein.

# Arguments:
#
#    {0} = statement
#    {1} = viewName
#
42Y62=''{0}'' ist f\u00FCr ''{1}'' nicht zul\u00E4ssig, weil es sich um eine View handelt.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y63=Hash Join erfordert ein optimierbares equijoin-Pr\u00E4dikat f\u00FCr eine Spalte im ausgew\u00E4hlten Index oder Heap. Die Tabelle bzw. der Index ''{0}'' enth\u00E4lt f\u00FCr keine Spalte ein optimierbares equijoin-Pr\u00E4dikat. Verwenden Sie den vorrangigen Optimizer-Wert "index", um einen Index oder Heap f\u00FCr die Tabelle ''{1}'' anzugeben.

# Arguments:
#
#    {0} = invalidNumber
#
42Y64=bulkFetch-Wert ''{0}'' ist ung\u00FCltig. Der Mindestwert f\u00FCr bulkFetch ist 1.

# Arguments:
#
#    {0} = joinType
#
42Y65=bulkFetch ist f\u00FCr Joins ''{0}'' nicht zul\u00E4ssig.

42Y66=bulkFetch ist f\u00FCr aktualisierbare Cursor nicht zul\u00E4ssig. 

# Arguments:
#
#    {0} = schemaNamet
#
42Y67=Schema ''{0}'' kann nicht gel\u00F6scht werden.

42Y69=F\u00FCr diese Anweisung wurde kein g\u00FCltiger Ausf\u00FChrungsplan gefunden. Dies kann eine der beiden folgenden Ursachen haben: Sie haben eine Hash Join-Strategie festgelegt, obwohl Hash Join nicht zul\u00E4ssig ist (kein optimierbares equijoin) oder Sie versuchen, zwei externe virtuelle Tabellen zu verkn\u00FCpfen, die jeweils einander referenzieren, sodass die Anweisung nicht ausgewertet werden kann.

42Y70=Der Benutzer hat eine nicht zul\u00E4ssige Join-Reihenfolge angegeben. Dies kann daran liegen, dass eine Join-Spalte einer inneren Tabelle als Parameter an eine \u00E4u\u00DFere virtuelle Tabelle \u00FCbergeben wird.

# Arguments:
#
#    {0} = procedureName
#
42Y71=Systemfunktion oder Prozedur ''{0}'' kann nicht gel\u00F6scht werden.

# Arguments:
#
#    {0} = statement
#
42Y82=Die vom System generierte gespeicherte vorbereitete Anweisung ''{0}'' kann mit DROP STATEMENT nicht gel\u00F6scht werden. Sie geh\u00F6rt zu einem Trigger.

# Arguments:
#
#    {0} = aggregateName
#
42Y83=Nicht typisierte NULL ist kein zul\u00E4ssiges Argument f\u00FCr das Aggregat {0}. Konvertieren Sie NULL in einen geeigneten Typ.

# Arguments:
#
#    {0} = sqlText
#
42Y84=''{0}'' darf nicht in einer DEFAULT-Definition angezeigt werden.

42Y85=Das Schl\u00FCsselwort DEFAULT ist in einer VALUES-Klausel nur zul\u00E4ssig, wenn die VALUES-Klausel in einer INSERT-Anweisung angezeigt wird.

42Y90=FOR UPDATE ist f\u00FCr diesen Anweisungstyp nicht zul\u00E4ssig. 

42Y91=Die USING-Klausel ist in EXECUTE STATEMENT f\u00FCr eine Triggeraktion nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = sqlKeyword
#    {1} = sqlKeyword
#
42Y92={0}-Trigger k\u00F6nnen nur \u00DCbergangsvariablen/Tabellen des Typs {1} referenzieren.

42Y93=Ung\u00FCltige REFERENCING-Klausel: F\u00FCr jede Art von \u00DCbergangsvariable/-tabelle ist nur ein Name zul\u00E4ssig.

42Y94=Ein AND oder OR verwendet einen nicht-booleschen Operanden. Das Ergebnis der Auswertung f\u00FCr die Operanden von AND und OR muss TRUE, FALSE oder UNKNOWN sein.

# Arguments:
#
#    {0} = operatorName
#    {1} = operandType
#    {2} = operandType
#
42Y95=Der Operator ''{0}'' mit dem linken Operanden vom Typ ''{1}'' und dem rechten Operanden vom Typ ''{2}'' wird nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
42Y97=Ung\u00FCltiges Escape-Zeichen in Zeile ''{0}'', Spalte ''{1}''.

42Z02=Mehrere DISTINCT-Aggregate werden zurzeit nicht unterst\u00FCtzt.

42Z07=Aggregate sind in der ON-Klausel nicht erlaubt.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
42Z08=F\u00FCr ''{0}'' gibt es einen aktivierten Trigger ({1}). Eine Ersetzung durch Masseneinf\u00FCgung ist daher nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = columnName
#
42Z15=F\u00FCr die Spalte ''{0}'' wurde ein ung\u00FCltiger Typ angegeben. Der Typ einer Spalte kann nicht ge\u00E4ndert werden.

42Z16=Die L\u00E4nge kann nur f\u00FCr Spalten des Typs VARCHAR, CLOB und BLOB ge\u00E4ndert werden. 

# Arguments:
#
#    {0} = columnName
#
42Z17=F\u00FCr die Spalte ''{0}'' wurde eine ung\u00FCltige L\u00E4nge angegeben. Der L\u00E4ngenwert muss gr\u00F6\u00DFer als die aktuelle Spaltenl\u00E4nge sein.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z18=Spalte ''{0}'' geh\u00F6rt zum Fremdschl\u00FCssel-Constraint ''{1}''. Wenn Sie die L\u00E4nge dieser Spalte \u00E4ndern m\u00F6chten, sollten Sie zun\u00E4chst den Constraint l\u00F6schen. F\u00FChren Sie dann ALTER TABLE aus, und erstellen Sie den Constraint neu.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z19=Spalte ''{0}'' wird von mindestens einem Fremdschl\u00FCssel-Constraint ''{1}'' referenziert. Wenn Sie die L\u00E4nge dieser Spalte \u00E4ndern m\u00F6chten, sollten Sie zun\u00E4chst die referenzierenden Constraints l\u00F6schen. F\u00FChren Sie dann ALTER aus, und erstellen Sie die Constraints neu.

# Arguments:
#
#    {0} = columnName
#
42Z20=Spalte ''{0}'' kann nicht auf null festgelegt werden. Sie geh\u00F6rt zu einem Prim\u00E4rschl\u00FCssel oder einem eindeutigen Constraint, der keine Spalten enthalten darf, die leer sein k\u00F6nnen.

# Arguments:
#
#    {0} = columnName
#
42Z20.S.1=Die Spalte ''{0}'' kann nicht auf null gesetzt werden. Sie geh\u00F6rt zu einem Prim\u00E4rschl\u00FCssel, der keine Spalten enthalten darf, die leer sein k\u00F6nnen.

# Arguments:
#
#    {0} = columnName
#
42Z21=F\u00FCr die Identit\u00E4t der Spalte ''{0}'' wurde ein ung\u00FCltiges Inkrement angegeben. Das Inkrement muss ungleich null sein. 

# Arguments:
#
#    {0} = columnName
#
42Z22=F\u00FCr die Identit\u00E4tsspalte ''{0}'' wurde ein ung\u00FCltiger Typ angegeben. F\u00FCr Identit\u00E4tsspalten sind nur die Typen BIGINT, INT und SMALLINT g\u00FCltig.

# Arguments:
#
#    {0} = columnName
#
42Z23=Es wurde versucht, die Identit\u00E4tsspalte ''{0}'' zu \u00E4ndern. 

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42Z24=Beim Identit\u00E4tswert f\u00FCr die Spalte ''{1}'' in der Tabelle ''{0}'' ist es zu einem \u00DCberlauf gekommen.

42Z25=Interner Fehler beim Identit\u00E4tsz\u00E4hler. UPDATE wurde ohne Argumente mit dem aktuellen Wert \= NULL aufgerufen.

# Arguments:
#
#    {0} = columnName
#
42Z26=Die Spalte ''{0}'' mit einer Standardidentit\u00E4t kann nicht leer sein.

# Arguments:
#
#    {0} = columnName
#
42Z27=F\u00FCr eine Spalte ''{0}'', die leer sein kann, kann keine Standardidentit\u00E4t festgelegt werden.

# Arguments:
#
#    {0} = queryTreeNodeIdentifier
#
42Z50=Interner Fehler: F\u00FCr {0} kann kein Code generiert werden.

# Arguments:
#
#    {0} = number
#
42Z53=Interner Fehler: Der f\u00FCr die Knotenauswahl {0} zu generierende Aktivierungstyp ist unbekannt.

# Arguments:
#
#    {0} = sqlText
#    {1} = propertyName
#    {2} = propertyValue
#
42Z60={0} ist nur zul\u00E4ssig, wenn die Datenbankeigenschaft {1} den Wert ''{2}'' hat.

42Z70=Direktes Binding an einen XML-Wert ist nicht zul\u00E4ssig. Versuchen Sie, XMLPARSE zu verwenden.

42Z71=In Ergebnismengen der h\u00F6chsten Ebene sind keine XML-Werte zul\u00E4ssig. Versuchen Sie, XMLSERIALIZE zu verwenden.

# Arguments:
#
#    {0} = keywords
#    {1} = lineNumber
#    {2} = columnNumber
#
42Z72=Fehlende SQL/XML-Schl\u00FCsselw\u00F6rter ''{0}'' in Zeile {1}, Spalte {2}

# Arguments:
#
#    {0} = typeName
#
42Z73=Ung\u00FCltiger Zieltyp f\u00FCr XMLSERIALIZE: ''{0}''.

# Arguments:
#
#    {0} = featureName
#
42Z74=Nicht unterst\u00FCtztes XML-Feature: ''{0}''.

42Z75=XML-Abfrageausdruck muss ein Zeichenfolgenliteral sein.

42Z76=Mehrere XML-Kontextelemente sind nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = dataType
#
42Z77=Kontextelement muss vom Typ "XML" sein. ''{0}'' ist nicht zul\u00E4ssig.

42Z79=Der Parametertyp f\u00FCr XMLPARSE kann nicht bestimmt werden. Versuchen Sie, ein CAST zu verwenden.

# Arguments:
#
#    {0} = className
#
42Z90=Klasse ''{0}'' gibt kein aktualisierbares ResultSet zur\u00FCck.

# This is a kind of query fragment, which may or may not appear in certain query contexts.
#
42Z91=SELECT

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z92=repeatable read

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintName
#
42Z93=Constraints ''{0}'' und ''{1}'' haben dieselben Spaltengruppen. Dies ist nicht zul\u00E4ssig. 

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z97=Umbenennung der Spalte ''{0}'' verst\u00F6\u00DFt gegen CHECK Constraint ''{1}''.

42Z99=Ein Zeichenfolgen- oder Hexadezimalliteral darf 64 K nicht \u00FCberschreiten.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z9A=read uncommitted

42Z9D.S.1=In BEFORE-Triggern sind keine Prozeduren erlaubt, die SQL-Daten modifizieren.

# Arguments:
#
#    {0} = statement
#    {1} = triggerName
#
42Z9D=''{0}''-Anweisungen sind in ''{1}''-Triggern nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintType
#
42Z9E=Constraint ''{0}'' ist kein {1} Constraint.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#    {2} = number
#
42Z9F=Zu viele Indizes ({0}) f\u00FCr die Tabelle {1}. Die Begrenzung liegt bei {2}.

42ZA0=Anweisung zu komplex. Versuchen Sie, die Abfrage weniger komplex zu schreiben. Dieser Fehler l\u00E4sst sich h\u00E4ufig dadurch beheben, dass viele duplizierte Ausdr\u00FCcke entfernt werden oder dass die Abfrage unterteilt wird und Zwischenergebnisse in einer tempor\u00E4ren Tabelle gespeichert werden.

# Arguments:
#
#    {0} = batch
#
42ZA1=Ung\u00FCltige SQL in Batch: ''{0}''

# Arguments:
#
#    {0} = dataType
#    {1} = collationType
#    {2} = dataType
#    {3} = collationType
#
42ZA2=Operand LIKE mit Typ {0} und Sortierung {1} ist nicht kompatibel mit dem LIKE-Musteroperand mit Typ {2} und Sortierung {3}.

# Arguments:
#
#    {0} = collationType
#    {1} = schemaName
#
42ZA3=Die Tabelle wird f\u00FCr die Sortierung den Typ {0} haben, der sich von der Sortierung des Schemas {1} unterscheidet, da dieser Vorgang nicht unterst\u00FCtzt wird.

42ZB1=Parameterstil DERBY_JDBC_RESULT_SET ist nur bei Tabellenfunktionen zul\u00E4ssig.

42ZB2=F\u00FCr Tabellenfunktionen gibt es nur den Parameterstil DERBY_JDBC_RESULT_SET.

42ZB3=XML ist nicht zul\u00E4ssig als Datentyp einer von einer Tabellenfunktion zur\u00FCckgegebenen Spalte.

# Arguments:
#
#    {0} = schemaName
#    {1} = functionName
#
42ZB4=''{0}''.{1}'' identifiziert keine Tabellenfunktion.

# Arguments:
#
#    {0} = className
#
42ZB5=Klasse ''{0}'' implementiert VTICosting, stellt jedoch keinen \u00F6ffentlichen Konstruktor ohne Argumente bereit.

42ZB6=Ein skalarer Wert wird erwartet und keine Zeilenmenge, die von einer Tabellenfunktion zur\u00FCckgegeben wird.

# Arguments:
#
#    {0} = columnName
#
42ZB7=Unzul\u00E4ssige Referenz auf Spalte ''{0}'' durch eine Tabellenfunktion oder VTI.

# Arguments:
#
#    {0} = windowName
#
42ZC0=Fenster ''{0}'' ist nicht definiert.

42ZC1=Nur ein Fenster wird unterst\u00FCtzt.

# Arguments:
#
#    {0} = clauseName
#
42ZC2=Fensterfunktion ist in diesem Kontext ung\u00FCltig: Klausel ''{0}''

# Arguments:
#
#    {0} = aggregateName
#
42ZC3=Ein benutzerdefiniertes Aggregat darf nicht den Namen eines Aggregats, das von SQL Standard definiert wird, oder den Namen einer integrierten Derby-Funktion haben, die ein Argument enth\u00E4lt: ''{0}''

# Arguments:
#
#    {0} = codePage
#    {1} = codePage
#
57017.C=Eine Konvertierung von der Quell-Codepage {0} in die Ziel-Codepage {1} ist nicht verf\u00FCgbar. Die Verbindung wurde beendet.

58009.C.10=Netzwerkprotokollausnahme: Nur die VCM-L\u00E4nge oder nur die VCS-L\u00E4nge darf gr\u00F6\u00DFer als 0 sein. Die Verbindung wurde beendet.

58009.C.11=Die Verbindung wurde beendet, weil die Codierung nicht unterst\u00FCtzt wird.

# Arguments:
#
#    {0} = codePoint
#    {1} = codePoint
#
58009.C.12=Netzwerkprotokollausnahme: Der tats\u00E4chliche Codepunkt {0} stimmt nicht mit dem erwarteten Codepunkt {1} \u00FCberein. Die Verbindung wurde beendet.

58009.C.13=Netzwerkprotokollausnahme: Die DDM-Objektgruppe enth\u00E4lt weniger als 4 Byte Daten. Die Verbindung wurde beendet.

58009.C.14=Netzwerkprotokollausnahme: Collection-Stack ist beim Beenden des Parsing-Vorgangs der ID-Kette nicht leer. Die Verbindung wurde beendet.

58009.C.15=Netzwerkprotokollausnahme: DSS-L\u00E4nge ist beim Beenden des Parsing-Vorgangs der ID-Kette gr\u00F6\u00DFer als 0. Die Verbindung wurde beendet.

58009.C.16=Netzwerkprotokollausnahme: Das n\u00E4chste DSS-Segment der Kette hat dieselbe ID wie das aktuelle Segment. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = number
#
58009.C.17=Netzwerkprotokollausnahme: Beim Lesen des InputStreams, Parameter {0}, wurde das Ende des Daten-Streams vorzeitig erreicht. Die Verbindung wurde beendet.

58009.C.18=Netzwerkprotokollausnahme: Ung\u00FCltiges FDOCA-LID. Die Verbindung wurde beendet.

58009.C.19=Netzwerkprotokollausnahme: SECTKN wurde nicht zur\u00FCckgegeben. Die Verbindung wurde beendet.

58009.C.20=Netzwerkprotokollausnahme: Nur NVCM oder nur NVCS darf ungleich null sein. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = length
#
58009.C.21=Netzwerkprotokollausnahme: Die SCLDTA-L\u00E4nge {0} ist f\u00FCr RDBNAM ung\u00FCltig. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = length
#
58009.C.7=Netzwerkprotokollausnahme: Die SCLDTA-L\u00E4nge {0} ist f\u00FCr RDBCOLID ung\u00FCltig. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = length
#
58009.C.8=Netzwerkprotokollausnahme: Die SCLDTA-L\u00E4nge {0} ist f\u00FCr PKGID ung\u00FCltig. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = length
#    {1} = sqlApplicationManager
#
58009.C.9=Netzwerkprotokollausnahme: Die SCLDTA-L\u00E4nge {0} ist f\u00FCr SQLAM {1} ung\u00FCltig. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = managerCodePoint
#    {1} = level
#
58010.C=Es wurde ein Netzwerkprotokollfehler festgestellt. Es konnte keine Verbindung hergestellt werden, weil der Manager {0} auf Ebene {1} vom Server nicht unterst\u00FCtzt wird. 

# Arguments:
#
#    {0} = distributedDataManagementCommand
#
58014.C=Der DDM-Befehl 0x{0} wird nicht unterst\u00FCtzt. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = distributedDataManagementObject
#
58015.C=Das DDM-Objekt 0x{0} wird nicht unterst\u00FCtzt. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = distributedDataManagementParameter
#
58016.C=Der DDM-Parameter 0x{0} wird nicht unterst\u00FCtzt. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = distributedDataManagementParameterValue
#
58017.C=Der DDM-Parameterwert 0x{0} wird nicht unterst\u00FCtzt. M\u00F6glicherweise liegt eine Input-Hostvariable nicht in dem vom Server unterst\u00FCtzten Bereich. Die Verbindung wurde beendet.

# Arguments:
#
#    {0} = columnName
#
X0A00.S=Die Auswahlliste enth\u00E4lt zweimal die Spalte ''{0}''. In Abfragen mit der Klausel GROUP BY oder HAVING ist dies nicht zul\u00E4ssig. Verwenden Sie f\u00FCr eine der einen Konflikt verursachenden Spalten einen Aliasnamen, um eindeutige Spaltennamen zu erhalten.

# Arguments:
#
#    {0} = tableName
#    {1} = mode
#
X0X02.S=Tabelle ''{0}'' kann nicht im Modus ''{1}'' gesperrt werden.

X0X03.S=Ung\u00FCltiger Transaktionsstatus. Der gehaltene Cursor erfordert dieselbe Isolationsebene.

# Arguments:
#
#    {0} = tableName
#
X0X05.S=Tabelle/View ''{0}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = fileName
#    {1} = classpath
#
X0X07.S=Die JAR-Datei ''{0}'' kann nicht entfernt werden, weil sie im derby.database.classpath ''{0}'' enthalten ist.

# Arguments:
#
#    {0} = columnArrayLength
#
X0X0D.S=Ung\u00FCltige L\u00E4nge f\u00FCr Spalten-Array ''{0}''. Um generierte Schl\u00FCssel zur\u00FCckzugeben, muss das Spalten-Array die L\u00E4nge 1 haben und darf nur die Identit\u00E4tsspalte enthalten.

# Arguments:
#
#    {0} = columnPosition
#    {1} = tableName
#
X0X0E.S=Tabelle ''{1}'' verf\u00FCgt nicht \u00FCber eine automatisch generierte Spalte in Spaltenposition ''{0}''.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
X0X0F.S=Tabelle ''{1}'' verf\u00FCgt nicht \u00FCber eine automatisch generierte Spalte mit der Bezeichnung ''{0}''.

X0X10.S=Die USING-Klausel hat mehr als eine Zeile zur\u00FCckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00E4ssig.

X0X11.S=Die USING-Klausel hat keine Ergebnisse geliefert. Es k\u00F6nnen keine Parameter festgelegt werden. 

# Arguments:
#
#    {0} = fileName
#    {1} = schemaNamet
#
X0X13.S=JAR-Datei ''{0}'' ist nicht im Schema ''{1}'' enthalten.

# Arguments:
#
#    {0} = type
#
X0X57.S=Es wurde versucht, einen Java-Wert vom Typ ''{0}'' in einem SQL-Wert aufzunehmen. Es ist jedoch kein entsprechender SQL-Typ vorhanden. Der Java-Wert ist wahrscheinlich das Ergebnis eines Methodenaufrufs oder Feldzugriffs.

# Arguments:
#
#    {0} = cursorName
#
X0X60.S=Ein Cursor mit dem Namen ''{0}'' ist bereits vorhanden.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaName
#    {2} = tableName
#    {3} = rowLocation
#    {4} = columnName
#    {5} = dataValue
#    {6} = dataValue
#    {7} = indexKey
#
X0X61.S=Die Werte f\u00FCr die Spalte ''{4}'' im Index ''{0}'' und in der Tabelle ''{1}.{2}'' passen nicht zur Zeilenposition {3}. Der Wert im Index ist ''{5}'' und der Wert in der Basistabelle ist ''{6}''. Der vollst\u00E4ndige Indexschl\u00FCssel mit der Zeilenposition ist ''{7}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.

# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#    {2} = rowLocation
#    {3} = indexKey
#
X0X62.S=Die Tabelle ''{0}'' und der Index ''{1}'' sind inkonsistent. Bei dem Versuch, die Zeilenposition ''{2}'' aus der Tabelle abzurufen, ist ein Fehler aufgetreten. Der vollst\u00E4ndige Indexschl\u00FCssel mit der Zeilenposition ist ''{3}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.

# Arguments:
#
#    {0} = exceptionText
#
X0X63.S=IOException ''{0}'' empfangen.

# Arguments:
#
#    {0} = type
#
X0X67.S=Spalten des Typs ''{0}'' k\u00F6nnen in den Anweisungen CREATE INDEX, ORDER BY, GROUP BY, UNION, INTERSECT, EXCEPT oder DISTINCT nicht verwendet werden, da f\u00FCr diesen Typ keine Vergleiche unterst\u00FCtzt werden.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0X81.S={0} ''{1}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = indexName
#    {1} = indexType
#
X0X85.S=Index ''{0}'' wurde nicht erstellt, weil ''{1}'' kein g\u00FCltiger Indextyp ist.

X0X86.S=0 ist ein ung\u00FCltiger Parameterwert f\u00FCr ResultSet.absolute(int row).

X0X87.S=ResultSet.relative(int row) kann nicht aufgerufen werden, wenn sich der Cursor nicht in einer Zeile befindet.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#
X0X95.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil es ein offenes ResultSet gibt, das von diesem Objekt abh\u00E4ngig ist.

# Arguments:
#
#    {0} = indexName
#
X0X99.S=Index ''{0}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = sqlObjectName
#
X0Y16.S=''{0}'' ist keine View. Falls es sich um eine Tabelle handelt, verwenden Sie DROP TABLE.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = viewName
#
X0Y23.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil VIEW ''{2}'' von diesem Objekt abh\u00E4ngt.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = statement
#
X0Y24.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil STATEMENT ''{2}'' von diesem Objekt abh\u00E4ngt.

# Arguments:
#
#    {0} = operationName
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y25.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil {2} ''{3}'' von diesem Objekt abh\u00E4ngt.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y26.S=Index ''{0}'' muss sich in demselben Schema wie die Tabelle ''{1}'' befinden.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y28.S=Index ''{0}'' kann f\u00FCr die Systemtabelle ''{1}'' nicht erstellt werden. Benutzer k\u00F6nnen keine Indizes f\u00FCr Systemtabellen erstellen.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = tableName
#
X0Y29.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil TABLE ''{2}'' von diesem Objekt abh\u00E4ngt.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = routineName
#
X0Y30.S=Vorgang ''{0}'' kann f\u00FCr das Objekt ''{1}'' nicht ausgef\u00FChrt werden, weil ROUTINE ''{2}'' von diesem Objekt abh\u00E4ngt.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y32.S={0} ''{1}'' ist bereits in {2} ''{3}'' vorhanden.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y38.S=Index ''{0}'' kann nicht erstellt werden, weil die Tabelle ''{1}'' nicht vorhanden ist.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = tableName
#
X0Y41.S=Constraint ''{0}'' ist ung\u00FCltig, weil die referenzierte Tabelle {1} keinen Prim\u00E4rschl\u00FCssel hat. F\u00FCgen Sie einen Prim\u00E4rschl\u00FCssel zu {1} hinzu oder geben Sie explizit die Spalten eines eindeutigen Constraints an, den dieser Fremdschl\u00FCssel referenziert. 

# Arguments:
#
#    {0} = constraintName
#
X0Y42.S=Constraint ''{0}'' ist ung\u00FCltig: Die Spalten des Fremdschl\u00FCssels stimmen vom Typ her nicht mit den referenzierten Spalten \u00FCberein.

# Arguments:
#
#    {0} = constraintName
#    {1} = number
#    {2} = number
#
X0Y43.S=Constraint ''{0}'' ist ung\u00FCltig: Die Anzahl der Spalten in ({1}) stimmt nicht mit der Anzahl der Spalten im referenzierten Schl\u00FCssel ({2}) \u00FCberein.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y44.S=Constraint ''{0}'' ist ung\u00FCltig: In Tabelle ''{1}'' ist kein Constraint f\u00FCr eindeutige oder Prim\u00E4rschl\u00FCssel vorhanden, der nach Anzahl und Typ der Spalten mit dem Fremdschl\u00FCssel \u00FCbereinstimmt.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y45.S=Constraint ''{0}'' f\u00FCr Fremdschl\u00FCssel kann nicht zur Tabelle {1} hinzugef\u00FCgt oder f\u00FCr die Tabelle aktiviert werden, weil es f\u00FCr einen oder mehrere Fremdschl\u00FCssel keine \u00FCbereinstimmenden referenzierten Schl\u00FCssel gibt. 

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y46.S=Constraint ''{0}'' ist ung\u00FCltig: Die referenzierte Tabelle {1} ist nicht vorhanden.

# Arguments:
#
#    {0} = schemaNamet
#
X0Y54.S=Schema ''{0}'' kann nicht gel\u00F6scht werden, weil es nicht leer ist.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaNamet
#    {2} = tableName
#    {3} = number
#    {4} = number
#
X0Y55.S=Die Zeilenanzahl in der Basistabelle stimmt nicht mit der Zeilenanzahl in mindestens einem der Indizes f\u00FCr die Tabelle \u00FCberein. Index ''{0}'' f\u00FCr Tabelle ''{1}.{2}'' hat {3} Zeilen, die Basistabelle jedoch {4} Zeilen. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.

# Arguments:
#
#    {0} = sqlText
#    {1} = tableName
#
X0Y56.S=''{0}'' ist f\u00FCr die Systemtabelle ''{1}'' nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = tableName
#
X0Y57.S=Eine Spalte, die leer sein darf, kann nicht zur Tabelle ''{0}'' hinzugef\u00FCgt werden, weil die Tabelle mindestens eine Zeile enth\u00E4lt. Spalten, die nicht leer sein d\u00FCrfen, k\u00F6nnen nur zu leeren Tabellen hinzugef\u00FCgt werden.

# Arguments:
#
#    {0} = tableName
#
X0Y58.S=Der Versuch, zur Tabelle ''{0}'' ein Constraint f\u00FCr Prim\u00E4rschl\u00FCssel hinzuzuf\u00FCgen, war nicht erfolgreich, weil es f\u00FCr die Tabelle bereits ein Constraint dieses Typs gibt. F\u00FCr eine Tabelle kann es nur ein Prim\u00E4rschl\u00FCssel-Constraint geben.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = rowCount
#
X0Y59.S=Der Versuch, Constraints zur Tabelle ''{1}'' hinzuzuf\u00FCgen bzw. f\u00FCr die Tabelle zu aktivieren, war nicht erfolgreich, weil die Tabelle {2} Zeilen enth\u00E4lt, die die folgenden Check Constraints verletzen: {0}.

# Arguments:
#
#    {0} = tableName
#
X0Y63.S=Der Befehl f\u00FCr die Tabelle ''{0}'' war nicht erfolgreich, weil im Prim\u00E4rschl\u00FCssel oder den Spalten des eindeutigen Constraints bzw. des Index Nulldaten gefunden wurden. Alle Spalten eines prim\u00E4ren oder eindeutigen Indexschl\u00FCssels m\u00FCssen ungleich null sein. 

# Arguments:
#
#    {0} = tableName
#
X0Y63.S.1=Der Befehl f\u00FCr die Tabelle ''{0}'' war nicht erfolgreich, weil in den Spalten des Prim\u00E4rschl\u00FCssels Nulldaten gefunden wurden. Alle Spalten eines Prim\u00E4rschl\u00FCssels d\u00FCrfen nicht leer sein. 

X0Y66.S=In einer verschachtelten Verbindung kann kein COMMIT-Vorgang ausgegeben werden, solange es einen anstehenden Vorgang in der \u00FCbergeordneten Verbindung gibt.

X0Y67.S=In einer verschachtelten Verbindung kann kein ROLLBACK-Vorgang ausgegeben werden, solange es einen anstehenden Vorgang in der \u00FCbergeordneten Verbindung gibt.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0Y68.S={0} ''{1}'' ist bereits vorhanden.

# Arguments:
#
#    {0} = triggerName
#
X0Y69.S=DDL wird in Trigger {0} nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
X0Y70.S=INSERT, UPDATE und DELETE sind f\u00FCr die Tabelle {1} nicht zul\u00E4ssig, weil der Trigger {0} aktiv ist.

# Arguments:
#
#    {0} = triggerName
#
X0Y71.S=Eine Transaktionsbearbeitung wie SET ISOLATION ist nicht zul\u00E4ssig, weil der Trigger {0} aktiv ist.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
X0Y72.S=F\u00FCr ''{0}'' gibt es einen aktivierten Trigger ({1}). Eine Ersetzung durch Bulk-Einf\u00FCgung ist daher nicht zul\u00E4ssig.

X0Y77.S=Die Anweisung "set transaction isolation" kann nicht f\u00FCr eine laufende globale Transaktion abgesetzt werden, weil die globale Transaktion damit implizit festgeschrieben werden w\u00FCrde.

X0Y78.S=Statement.executeQuery() kann nicht mit einer Anweisung ausgef\u00FChrt werden, die eine Zeilenanzahl zur\u00FCckgibt.

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.1={0}.executeQuery() kann nicht aufgerufen werden, weil mehrere Ergebnismengen zur\u00FCckgegeben wurden. Verwenden Sie zum Abrufen mehrerer Ergebnisse {1}.execute().

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.2={0}.executeQuery() wurde aufgerufen, aber keine Ergebnismenge zur\u00FCckgegeben. Verwenden Sie f\u00FCr Nicht-Abfragen {1}.executeUpdate().

X0Y79.S=Statement.executeUpdate() kann nicht mit einer Anweisung ausgef\u00FChrt werden, die ein ResultSet zur\u00FCckgibt.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
X0Y80.S=ALTER war f\u00FCr Tabelle ''{0}'' nicht erfolgreich. In Spalte ''{1}'' wurden Nulldaten gefunden.

# Arguments:
#
#    {0} = rowName
#    {1} = id
#
X0Y83.S=Warnung: Beim L\u00F6schen einer Zeile aus einer Tabelle wurde die Indexzeile f\u00FCr die Zeile {0} der Basistabelle im Index mit der Konglomerat-ID {1} nicht gefunden. Dieser Fehler wurde automatisch im Rahmen eines L\u00F6schvorgangs behoben.

# Arguments:
#
#    {0} = sequenceName
#
X0Y84.T=Zu viele Konflikte bei Sequenz {0}. Dies wird wahrscheinlich durch einen nicht festgeschriebenen Scan des SYS.SYSSEQUENCES-Katalogs verursacht. Fragen Sie diesen Katalog nicht direkt ab. Verwenden Sie stattdessen die Funktion SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE, um den aktuellen Wert eines Abfragegenerators anzuzeigen.

# Arguments:
#
#    {0} = propertyName
#    {1} = className
#
X0Y85.S=Die Derby-Eigenschaft ''{0}'' identifiziert eine Klasse, die nicht instanziiert werden kann: ''{1}''. Weitere Einzelheiten finden Sie in der n\u00E4chsten Ausnahme.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
X0Y86.S=Derby konnte die Sperren nicht anfordern, die zur Freigabe der nicht verwendeten, im Voraus zugeordneten Werte f\u00FCr die Sequenz ''{0}''.''{1}'' erforderlich sind. Deshalb kann diese Sequenz unerwartete L\u00FCcken enthalten.

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateOrFunctionName
#
X0Y87.S=Es ist bereits ein Aggregat oder eine Funktion mit einem Argument namens ''{0}''.''{1}'' vorhanden.

# Arguments:
#
#    {0} = cacheName
#    {1} = keyValue
#
XBCA0.S=Im {0}-Cache kann kein neues Objekt mit dem Schl\u00FCssel {1} erstellt werden, da es bereits im Cache vorhanden ist. 

# Arguments:
#
#    {0} = className
#
XBCM1.S=Beim Laden der generierten Klasse {0} wurde ein Java-Verbindungsfehler ausgel\u00F6st.

# Arguments:
#
#    {0} = className
#
XBCM2.S=Es kann keine Instanz der generierten Klasse {0} erstellt werden.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#
XBCM3.S=Methode {1}() ist in der generierten Klasse {0} nicht vorhanden.

# Arguments:
#
#    {0} = className
#    {1} = limitDescriptor
#
XBCM4.S=Grenze f\u00FCr Java-Klassendateiformat \u00FCberschritten: {1} in generierter Klasse {0}.

XBCX0.S=Ausnahme vom Verschl\u00FCsselungsprovider. Details enth\u00E4lt die n\u00E4chste Ausnahme.

XBCX1.S=Das Verschl\u00FCsselungsverfahren wird mit einem ung\u00FCltigen Modus initialisiert. Der Modus muss CipherFactory.ENCRYPT oder CipherFactory.DECRYPT sein.

# Arguments:
#
#    {0} = number
#
XBCX2.S=Sie initialisieren das Verschl\u00FCsselungsverfahren mit einem zu kurzen Boot-Kennwort. Das Kennwort muss aus mindestens {0} Zeichen bestehen. 

XBCX5.S=Boot-Kennwort kann nicht in eine Nullzeichenfolge ge\u00E4ndert werden.

XBCX6.S=Boot-Kennwort kann nicht in einen serialisierbaren Typ, der keine Zeichenfolge ist, ge\u00E4ndert werden.

XBCX7.S=Falsches Format f\u00FCr das \u00C4ndern des Boot-Kennworts. G\u00FCltiges Format: old_boot_password, new_boot_password.

XBCX8.S=Boot-Kennwort f\u00FCr eine nicht verschl\u00FCsselte Datenbank kann nicht ge\u00E4ndert werden.

XBCX9.S=Boot-Kennwort f\u00FCr eine schreibgesch\u00FCtzte Datenbank kann nicht ge\u00E4ndert werden. 

XBCXA.S=Falsches Boot-Kennwort.

# Arguments:
#
#    {0} = paddingDirective
#
XBCXB.S=Das Verschl\u00FCsselungs-Padding ''{0}'' ist fehlerhaft oder es wurde kein Padding angegeben. Es muss "NoPadding" verwendet werden.

# Arguments:
#
#    {0} = algorithmName
#    {1} = providerName
#
XBCXC.S=Der Verschl\u00FCsselungsalgorithmus ''{0}'' ist nicht vorhanden. \u00DCberpr\u00FCfen Sie, ob der ausgew\u00E4hlte Provider ''{1}'' diesen Algorithmus unterst\u00FCtzt.

XBCXD.S=Der Verschl\u00FCsselungsalgorithmus kann nach dem Erstellen der Datenbank nicht ge\u00E4ndert werden.

XBCXE.S=Der Verschl\u00FCsselungsprovider kann nach dem Erstellen der Datenbank nicht ge\u00E4ndert werden.

# Arguments:
#
#    {0} = className
#
XBCXF.S=Die Klasse ''{0}'', die den Verschl\u00FCsselungsprovider repr\u00E4sentiert, wurde nicht gefunden.

# Arguments:
#
#    {0} = providerName
#
XBCXG.S=Der Verschl\u00FCsselungsprovider ''{0}'' ist nicht vorhanden.

# Arguments:
#
#    {0} = algorithmName
#
XBCXH.S=Der Verschl\u00FCsselungsalgorithmus ''{0}'' hat nicht das richtige Format. Korrektes Format: algorithm/feedbackMode/NoPadding.

# Arguments:
#
#    {0} = mode
#
XBCXI.S=Der Feedbackmodus ''{0}'' wird nicht unterst\u00FCtzt. Unterst\u00FCtzte Feedbackmodi sind CBC, CFB, OFB und ECB.

XBCXJ.S=Die Anwendung verwendet eine \u00E4ltere JCE-Version (Java Cryptography Extension) als 1.2.1. F\u00FChren Sie ein Upgrade auf JCE 1.2.1 durch, und wiederholen Sie den Vorgang. 

XBCXK.S=Der angegebene Verschl\u00FCsselungsschl\u00FCssel stimmt nicht mit dem bei der Erstellung der Datenbank verwendeten Verschl\u00FCsselungsschl\u00FCssel \u00FCberein. Vergewissern Sie sich, dass Sie den richtigen Verschl\u00FCsselungsschl\u00FCssel verwenden, und versuchen Sie es erneut. 

XBCXL.S=Der Pr\u00FCfprozess f\u00FCr den Verschl\u00FCsselungsschl\u00FCssel war nicht erfolgreich. Als Ursache kommt ein Fehler beim Zugriff auf die Datei f\u00FCr die Ausf\u00FChrung des Pr\u00FCfprozesses in Frage. Details enth\u00E4lt die n\u00E4chste Ausnahme. 

XBCXM.S=Die L\u00E4nge des externen Verschl\u00FCsselungsschl\u00FCssels muss eine gerade Zahl sein.

XBCXN.S=Der externe Verschl\u00FCsselungsschl\u00FCssel enth\u00E4lt mindestens ein ung\u00FCltiges Zeichen. Zul\u00E4ssige Zeichen f\u00FCr Hexadezimalzahlen sind 0-9, a-f und A-F.

XBCXO.S=Die Datenbank kann nicht verschl\u00FCsselt werden, wenn eine vorbereitete globale Transaktion vorliegt.

XBCXP.S=Die Datenbank kann nicht mit einem anderen Boot-Kennwort oder einem externen Verschl\u00FCsselungsschl\u00FCssel neu verschl\u00FCsselt werden, wenn eine vorbereitete globale Transaktion vorliegt.

XBCXQ.S=Eine schreibgesch\u00FCtzte Datenbank kann nicht zur Verschl\u00FCsselung konfiguriert werden.

XBCXR.S=Eine schreibgesch\u00FCtzte Datenbank kann nicht mit einem anderen Boot-Kennwort oder einem externen Verschl\u00FCsselungsschl\u00FCssel neu verschl\u00FCsselt werden.

XBCXS.S=Eine Datenbank im Archivierungsmodus kann nicht zur Verschl\u00FCsselung konfiguriert werden.

XBCXT.S=Eine Datenbank im Archivierungsmodus kann nicht mit einem anderen Boot-Kennwort oder einem externen Verschl\u00FCsselungsschl\u00FCssel neu verschl\u00FCsselt werden.

# Arguments:
#
#    {0} = failureMessage
#
XBCXU.S=Verschl\u00FCsselung einer unverschl\u00FCsselten Datenbank war nicht erfolgreich: {0}

# Arguments:
#
#    {0} = failureMessage
#
XBCXV.S=Verschl\u00FCsselung einer verschl\u00FCsselten Datenbank mit einem neuen Schl\u00FCssel oder einem neuen Kennwort war nicht erfolgreich: {0}

# Arguments:
#
#    {0} = algorithmName
#
XBCXW.S=Der Message Digest-Algorithmus ''{0}'' wird von keinem der verf\u00FCgbaren Verschl\u00FCsselungsprovider unterst\u00FCtzt. Installieren Sie einen Verschl\u00FCsselungsprovider, der den Algorithmus unterst\u00FCtzt, oder geben Sie in der Eigenschaft "derby.authentication.builtin.algorithm" einen anderen Algorithmus an.

XBM01.D=Systemstart aufgrund einer Ausnahme nicht erfolgreich. Details enth\u00E4lt die n\u00E4chste Ausnahme. 

# Arguments:
#
#    {0} = moduleName
#
XBM02.D=Systemstart aufgrund fehlender Funktionalit\u00E4t f\u00FCr {0} nicht erfolgreich. Stellen Sie sicher, dass Ihr Classpath die richtige Derby-Software enth\u00E4lt.

# Arguments:
#
#    {0} = productName
#
XBM05.D=Systemstart aufgrund der fehlenden Produktversionsnummer f\u00FCr {0} nicht erfolgreich.

XBM06.D=Systemstart nicht erfolgreich. Auf eine verschl\u00FCsselte Datenbank kann nur mit dem richtigen Boot-Kennwort zugegriffen werden. 

XBM07.D=Systemstart nicht erfolgreich. Das Boot-Kennwort muss eine Mindestl\u00E4nge von 8 Byte haben.

# Arguments:
#
#    {0} = subSubProtocol
#    {1} = className
#
XBM08.D=StorageFactory-Klasse {1} unter {0} konnte nicht instanziiert werden.

# Arguments:
#
#    {0} = directoryName
#    {1} = servicePropertiesName
#
XBM0A.D=Das Datenbankverzeichnis ''{0}'' ist vorhanden. Es enth\u00E4lt jedoch nicht die erwartete Datei ''{1}''. M\u00F6glicherweise wurde Derby w\u00E4hrend der Erstellung dieser Datenbank heruntergefahren. Es empfiehlt sich m\u00F6glicherweise, dieses Verzeichnis zu l\u00F6schen und die Datenbank erneut zu erstellen.

# Arguments:
#
#    {0} = errorMessage
#
XBM0B.D=Service-Properties-Datei konnte nicht bearbeitet/geschrieben werden: {0}

# Arguments:
#
#    {0} = operation
#    {1} = path
#    {2} = errorMessage
#
XBM0C.D=Fehlende Berechtigung f\u00FCr Vorgang ''{0}'' mit Datei ''{1}'': {2}

XBM0G.D=Die Verschl\u00FCsselungs-Engine konnte nicht gestartet werden. Vergewissern Sie sich, dass Sie Java 2 ausf\u00FChren und einen Verschl\u00FCsselungsprovider wie JCE heruntergeladen und in den Classpath aufgenommen haben. 

# Arguments:
#
#    {0} = directoryName
#
XBM0H.D=Verzeichnis {0} kann nicht erstellt werden.

# Arguments:
#
#    {0} = directoryName
#
XBM0I.D=Verzeichnis {0} kann nicht entfernt werden.

# Arguments:
#
#    {0} = directoryName
#
XBM0J.D=Verzeichnis {0} ist bereits vorhanden.

# Arguments:
#
#    {0} = databaseName
#
XBM0K.D=Unbekanntes Unterprotokoll f\u00FCr den Datenbanknamen {0}.

# Arguments:
#
#    {0} = className
#    {1} = interfaceName
#
XBM0L.D=Angegebene Authentifizierungsschemaklasse {0} implementiert nicht die Authentifizierungsschnittstelle {1}.

# Arguments:
#
#    {0} = className
#    {1} = detail
#
XBM0M.D=Fehler beim Erstellen einer Instanz einer Klasse namens ''{0}''. Dieser Klassenname war der Wert der Eigenschaft derby.authentication.provider und sollte der Name einer von der Anwendung bereitgestellten Implementierung von org.apache.derby.authentication.UserAuthenticator sein. Das zugrunde liegende Problem war: {1}

XBM0N.D=JDBC-Treiberregistrierung mit java.sql.DriverManager war nicht erfolgreich. Weitere Details finden Sie in der n\u00E4chsten Ausnahme. 

XBM0P.D=Serviceprovider ist schreibgesch\u00FCtzt. Der Vorgang ist nicht zul\u00E4ssig. 

# Arguments:
#
#    {0} = fileName
#
XBM0Q.D=Datei {0} nicht gefunden. Vergewissern Sie sich, dass es sich um das richtige Backup handelt und dass dieses nicht besch\u00E4digt ist.

# Arguments:
#
#    {0} = fileName
#
XBM0R.D=Datei {0} kann nicht entfernt werden.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0S.D=Datei ''{0}'' kann nicht in ''{1}'' umbenannt werden.

# Arguments:
#
#    {0} = databaseName
#
XBM0T.D=Mehrdeutiges Unterprotokoll f\u00FCr den Datenbanknamen {0}. 

# Arguments:
#
#    {0} = identifierName
#
XBM0U.S=F\u00FCr die ID {0} wurde keine Klasse registriert.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0V.S=Beim Laden der f\u00FCr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00F6st.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0W.S=Beim Erstellen einer Instanz der f\u00FCr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00F6st.

# Arguments:
#
#    {0} = territoryID
#
XBM0X.D=Angegebenes Gebietsschema ''{0}'' ist ung\u00FCltig. Erwartet wurde ln[_CO[_variant]]\nln \\= zwei Kleinbuchstaben des ISO-639-Sprachcodes, CO \\= zwei Gro\u00DFbuchstaben der ISO-3166-L\u00E4ndercodes. Siehe java.util.Locale.

# Arguments:
#
#    {0} = collationName
#
XBM03.D=Angegebener Wert ''{0}'' f\u00FCr das Sortierungsattribut ist ung\u00FCltig, erwartet wurde UCS_BASIC oder TERRITORY_BASED.

# Arguments:
#
#    {0} = localeName
#
XBM04.D=Collator-Unterst\u00FCtzung von JVM ist nicht verf\u00FCgbar f\u00FCr Datenbankgebietsschema ''{0}''.

# Arguments:
#
#    {0} = directoryName
#
XBM0Y.D=Backupdatenbankverzeichnis {0} nicht gefunden. Vergewissern Sie sich, dass der angegebene Backuppfad richtig ist.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0Z.D=Datei ''{0}'' kann nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00FCgbar ist und dass die notwendigen Berechtigungen vorliegen. 

# Arguments:
#
#    {0} = operationName
#
XCL01.S=Ergebnismenge gibt keine Zeilen zur\u00FCck. Vorgang {0} nicht zul\u00E4ssig. 

# Arguments:
#
#    {0} = operationName
#
XCL05.S=Aktivierung wurde geschlossen. Vorgang {0} nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = cursorName
#
XCL07.S=Cursor ''{0}'' wurde geschlossen. Pr\u00FCfen Sie, ob das automatische Festschreiben deaktiviert ist.

# Arguments:
#
#    {0} = cursorName
#
XCL08.S=Cursor ''{0}'' befindet sich nicht in einer Zeile.

# Arguments:
#
#    {0} = methodName
#
XCL09.S=An die Methode ''{0}'' wurde eine Aktivierung \u00FCbergeben, die nicht mit dem PreparedStatement \u00FCbereinstimmt.

XCL10.S=Ein PreparedStatement wurde kompiliert, und die Parameter wurden ge\u00E4ndert. Wenn Sie JDBC verwenden, m\u00FCssen Sie die Anweisung erneut vorbereiten. 

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
XCL12.S=Es wurde versucht, einen Datenwert des Typs ''{0}'' in einen Datenwert des Typs ''{1}'' aufzunehmen.

# Arguments:
#
#    {0} = parameterPosition
#    {1} = number
#
XCL13.S=Die Parameterposition ''{0}'' liegt au\u00DFerhalb des Bereichs. Die Parameteranzahl f\u00FCr diese vorbereitete Anweisung ist ''{1}''.

# Arguments:
#
#    {0} = columnPosition
#    {1} = number
#
XCL14.S=Die Spaltenposition ''{0}'' befindet sich au\u00DFerhalb des Bereichs. Die Anzahl der Spalten f\u00FCr dieses ResultSet liegt bei ''{1}''.

# Arguments:
#
#    {0} = object
#    {1} = className
#
XCL15.S=Beim Aufrufen der Methode compareTo() f\u00FCr ein Objekt ''{0}'' ist eine ClassCastException eingetreten. Der Parameter f\u00FCr compareTo() geh\u00F6rt zur Klasse ''{1}''.

# Arguments:
#
#    {0} = operation
#
XCL16.S=ResultSet nicht ge\u00F6ffnet. Vorgang ''{0}'' nicht zul\u00E4ssig. Stellen Sie sicher, dass Autocommit deaktiviert ist.

XCL18.S=Stream oder LOB-Wert kann nicht mehrmals abgerufen werden

# Arguments:
#
#    {0} = tableName
#    {1} = key
#
XCL19.S=In der Tabelle ''{0}'' fehlt die Zeile f\u00FCr den Schl\u00FCssel ''{1}''.

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL20.S=F\u00FCr Kataloge mit dem Versionsstand ''{0}'' kann kein Upgrade auf den Versionsstand ''{1}'' durchgef\u00FChrt werden.

XCL21.S=Sie versuchen, eine Datendefinitionsanweisung (CREATE, DROP oder ALTER) auszuf\u00FChren, w\u00E4hrend Sie eine andere Anweisung vorbereiten. Dies ist nicht zul\u00E4ssig. Dies kann geschehen, wenn Sie eine Definitionsanweisung aus einem statischen Initialisierungsoperator f\u00FCr eine Java-Klasse ausf\u00FChren, der innerhalb einer SQL-Anweisung verwendet wird.

# Arguments:
#
#    {0} = parameterName
#
XCL22.S=Parameter {0} kann nicht als OUT-Parameter registriert werden, da er ein IN-Parameter ist. 

# Arguments:
#
#    {0} = type
#
XCL23.S=SQL-Typnummer ''{0}'' ist kein Typ, der von registerOutParameter() unterst\u00FCtzt wird.

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#
XCL24.S=Parameter {0} scheint ein Outputparameter zu sein, wurde jedoch von registerOutParameter() nicht als solcher angegeben. Wenn der Parameter kein Outputparameter ist, muss er auf den Typ {1} festgelegt werden.

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#    {2} = type
#
XCL25.S=Parameter {0} kann nicht als Parameter des Typs {1} registriert werden, weil er dem Typ {2} zugeordnet wird und beide Typen inkompatibel sind.

# Arguments:
#
#    {0} = parameterName
#
XCL26.S=Parameter {0} ist kein Outputparameter.

XCL27.S=Zur\u00FCckzugebende Outputparameter k\u00F6nnen nicht festgelegt werden.

# Arguments:
#
#    {0} = dataType
#
XCL30.S=Beim Lesen eines ''{0}'' von einem InputStream wurde eine IOException ausgel\u00F6st.

XCL31.S=Anweisung geschlossen.

# Arguments:
#
#    {0} = tableName
#
XCL33.S=Aufgrund von L\u00F6schregeleinschr\u00E4nkungen kann die Tabelle nicht als abh\u00E4ngig von der Tabelle {0} definiert werden. (Die Beziehung ist selbstreferenzierend. Eine solche Beziehung besteht bereits zur L\u00F6schregel SET NULL.)

# Arguments:
#
#    {0} = tableName
#
XCL34.S=Aufgrund von L\u00F6schregeleinschr\u00E4nkungen kann die Tabelle nicht als abh\u00E4ngig von der Tabelle {0} definiert werden. (Die Beziehung umfasst zwei oder mehr Tabellen, sodass die Tabelle f\u00FCr das mehrstufige L\u00F6schen auf sich selbst verweist. F\u00FCr alle \u00FCbrigen Tabellen gilt die L\u00F6schregel CASCADE.)

# Arguments:
#
#    {0} = tableName
#
XCL35.S=Aufgrund von L\u00F6schregeleinschr\u00E4nkungen kann die Tabelle nicht als abh\u00E4ngig von der Tabelle {0} definiert werden. (Die Beziehung f\u00FChrt dazu, dass die Tabelle \u00FCber mehrere Beziehungen f\u00FCr das mehrstufige L\u00F6schen auf die angegebene Tabelle verweist. Die L\u00F6schregel der bestehenden Beziehung ist SET NULL.)

# Arguments:
#
#    {0} = sqlText
#
XCL36.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel muss {0} sein. (Der referenzielle Constraint referenziert sich selbst. Ein vorhandener selbstreferenzierender Constraint hat die L\u00F6schregel NO ACTION, RESTRICT oder CASCADE.)

# Arguments:
#
#    {0} = sqlText
#
XCL37.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel muss {0} sein. (Der referenzielle Constraint verweist auf sich selbst, und die Tabelle befindet sich in einer Abh\u00E4ngigkeitsbeziehung mit der L\u00F6schregel CASCADE.)

# Arguments:
#
#    {0} = ruleName
#
XCL38.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel muss {0} sein. (Die Beziehung w\u00FCrde dazu f\u00FChren, dass die Tabelle \u00FCber mehrere Beziehungen f\u00FCr das mehrstufige L\u00F6schen auf dieselbe Tabelle verweist. Diese Beziehungen m\u00FCssen dieselbe L\u00F6schregel NO ACTION, RESTRICT oder CASCADE haben.)

XCL39.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel darf nicht CASCADE lauten. (Es liegt ein sich selbst referenzierender Constraint mit der L\u00F6schregel SET NULL, NO ACTION oder RESTRICT vor.)

XCL40.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel darf nicht CASCADE lauten. (Es w\u00FCrde eine Zyklus entstehen, in der eine Tabelle f\u00FCr das mehrstufige L\u00F6schen sich selbst referenzieren w\u00FCrde. Eine der vorhandenen L\u00F6schregeln in der Beziehung ist nicht CASCADE. Die Beziehung kann demzufolge definiert werden, wenn die L\u00F6schregel nicht CASCADE lautet.) 

XCL41.S=Die L\u00F6schregel f\u00FCr den Fremdschl\u00FCssel darf nicht CASCADE lauten. (Die Beziehung w\u00FCrde dazu f\u00FChren, dass eine andere Tabelle \u00FCber mehrere Pfade mit verschiedenen L\u00F6schregeln oder der einheitlichen L\u00F6schregel SET NULL f\u00FCr das mehrstufige L\u00F6schen dieselbe Tabelle referenzieren w\u00FCrde.)

# Arguments:
#
#    {0} = sqlText
#    {1} = versionNumber
#    {2} = versionNumber
#
XCL47.S=Die Verwendung von ''{0}'' setzt voraus, dass Sie ein Upgrade der Datenbank von Version {1} auf Version {2} oder eine aktuellere Version durchf\u00FChren. 

# Arguments:
#
#    {0} = tableName
#
XCL48.S= F\u00FCr ''{0}'' ist TRUNCATE TABLE nicht zul\u00E4ssig, weil aktivierte Constraints f\u00FCr Fremdschl\u00FCssel in anderen Tabellen Constraints f\u00FCr eindeutige oder Prim\u00E4rschl\u00FCssel in dieser Tabelle referenzieren. 

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
XCL49.S= F\u00FCr ''{0}'' ist TRUNCATE TABLE nicht zul\u00E4ssig, weil ein aktivierter DELETE-Trigger vorliegt ({1}).

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL50.S=Ein Upgrade f\u00FCr eine fr\u00FChere Version der Datenbank wird nicht unterst\u00FCtzt. Die Datenbank, auf die zugegriffen wird, hat den Versionsstand ''{0}'' und diese Software den Versionsstand ''{1}''. 

XCL51.S=Die angeforderte Funktion kann keine Tabellen im Schema SESSION referenzieren.

XCL52.S=Die Anweisung wurde abgebrochen oder wegen Timeouts abgebrochen.

# Arguments:
#
#    {0} = versionID
#    {1} = versionID
#
XCW00.D=Ein Upgrade von ''{0}'' auf ''{1}'' wird nicht unterst\u00FCtzt.

XCXA0.S=Ung\u00FCltige ID.

# Arguments:
#
#    {0} = classpath
#
XCXB0.S=Ung\u00FCltiger Datenbank-Classpath: ''{0}''.

XCXC0.S=Ung\u00FCltige ID-Liste.

XCXE0.S=Sie versuchen, einen Vorgang auszuf\u00FChren, der das Gebietsschema der Datenbank verwendet. F\u00FCr die Datenbank ist jedoch kein Gebietsschema festgelegt.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY00.S=Ung\u00FCltiger Wert f\u00FCr Eigenschaft ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY02.S=Die angeforderte Eigenschafts\u00E4nderung wird nicht unterst\u00FCtzt; ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#
XCY03.S=Erforderliche Eigenschaft ''{0}'' nicht definiert.

XCY04.S=Ung\u00FCltige Syntax f\u00FCr vorrangige Optimizer-Werte. G\u00FCltige Syntax: DERBY-PROPERTIES Eigenschaftsname = Wert [, Eigenschaftsname = Wert]*

XCY05.S.2=Ung\u00FCltige Einstellung der Eigenschaft "derby.authentication.provider". Diese Eigenschaft ist bereits zur Aktivierung der NATIVE-Authentifizierung festgelegt und kann nicht ge\u00E4ndert werden.

XCY05.S.3=Ung\u00FCltige Einstellung der Eigenschaft "derby.authentication.provider". Um die NATIVE-Authentifizierung zu aktivieren, verwenden Sie die Prozedur SYSCS_UTIL.SYSCS_CREATE_USER, um Zugangsdaten f\u00FCr den Datenbankeigent\u00FCmer zu speichern.

# Arguments:
#
#    {0} = permissionName
#
XCZ00.S=Unbekannte Berechtigung ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#
XCZ01.S=Unbekannter Benutzer ''{0}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCZ02.S=Ung\u00FCltiger Parameter ''{0}''=''{1}''.

XD004.S=Es k\u00F6nnen keine Abh\u00E4ngigkeiten gespeichert werden.

XIE01.S=Es ist keine Verbindung vorhanden.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
XIE03.S=In Zeile {0} f\u00FCr Spalte {1} wurden nach dem Endbegrenzer Daten gefunden. 

# Arguments:
#
#    {0} = fileName
#
XIE04.S=Nicht gefundene Datendatei: {0}

XIE05.S=Es muss eine Datendatei angegeben werden. 

XIE06.S=Entityname nicht angegeben.

XIE07.S=Feld- und Datensatztrennzeichen k\u00F6nnen nicht als Unterzeichenfolge des jeweils anderen Trennzeichens verwendet werden. 

# Arguments:
#
#    {0} = columnName
#
XIE08.S=Es gibt keine Spalte mit dem Namen {0}. 

# Arguments:
#
#    {0} = number
#
XIE09.S=Gesamtanzahl Spalten in der Zeile: {0}. 

# Arguments:
#
#    {0} = columnName
#    {1} = type
#
XIE0B.S=Spalte ''{0}'' der Tabelle ist vom Typ {1}, der vom Import/Export nicht unterst\u00FCtzt wird. 

# Arguments:
#
#    {0} = lineNumber
#
XIE0D.S=Das Datensatztrennzeichen wurde nicht in Zeile {0} gefunden.

# Arguments:
#
#    {0} = lineNumber
#
XIE0E.S=In Zeile {0} wurde an unerwarteter Stelle ein Dateiende gelesen.

XIE0I.S=Beim Schreiben von Daten in die Datei ist eine IOException aufgetreten.

XIE0J.S=Ein Begrenzungszeichen ist ung\u00FCltig oder wird mehrfach verwendet.

XIE0K.S=Als Zeichenfolgenbegrenzungszeichen wurde ein Punkt angegeben.

# Arguments:
#
#    {0} = tableName
#
XIE0M.S=Tabelle ''{0}'' ist nicht vorhanden. 

# Arguments:
#
#    {0} = hexString
#
XIE0N.S=Ein ung\u00FCltiger hexadezimaler String ''{0}'' wurde in der Importdatei erfasst.

# Arguments:
#
#    {0} = fileName
#
XIE0P.S=Referenzierte LOB-Datendatei {0} in der Importdatei nicht gefunden.

XIE0Q.S=Name der LOB-Datendatei darf nicht leer sein. 

# Arguments:
#
#    {0} = lineNumber
#    {1} = fileName
#    {2} = details
#
XIE0R.S=Importfehler in Zeile {0} der Datei {1}: {2} 

# Arguments:
#
#    {0} = fileName
#
XIE0S.S=Der Exportvorgang wurde nicht ausgef\u00FChrt, weil die angegebene Outputdatei ({0}) bereits vorhanden ist. Bei einem Export wird keine vorhandene Datei \u00FCberschrieben, auch dann nicht, wenn der Prozess das Recht zum Schreiben in diese Datei hat. Diese Vorgehensweise wurde aus Sicherheitsgr\u00FCnden \u00FCbernommen, und um unbeabsichtigte Dateibesch\u00E4digungen zu vermeiden. \u00C4ndern Sie den Namen der Outputdatei in den Exportargumenten in einen nicht vorhandenen Namen, oder l\u00F6schen Sie die vorhandene Datei und versuchen Sie dann erneut einen Export.

# Arguments:
#
#    {0} = fileName
#
XIE0T.S=Der Exportvorgang wurde nicht ausgef\u00FChrt, weil die angegebene LOB-Hilfsdatei ({0}) bereits vorhanden ist. Bei einem Export wird keine vorhandene Datei \u00FCberschrieben, auch dann nicht, wenn der Prozess das Recht zum Schreiben in diese Datei hat. Diese Vorgehensweise wurde aus Sicherheitsgr\u00FCnden \u00FCbernommen, und um unbeabsichtigte Dateibesch\u00E4digungen zu vermeiden. \u00C4ndern Sie den Namen der LOB-Hilfsdatei in den Exportargumenten zu einem nicht vorhandenen Namen, oder l\u00F6schen Sie die vorhandene Datei, und versuchen Sie dann erneut einen Export.

# Arguments:
#
#    {0} = databaseName
#
XJ004.C=Datenbank ''{0}'' wurde nicht gefunden.

XJ008.S=Ein Savepoint kann im Autocommit-Modus nicht zur\u00FCckgesetzt oder freigegeben werden.

# Arguments:
#
#    {0} = sqlText
#
XJ009.S=F\u00FCr das Aufrufen einer gespeicherten Prozedur ist die Verwendung von CallableStatement oder von Outputparametern erforderlich: {0}

XJ010.S=Savepoint kann nicht abgesetzt werden, wenn autoCommit aktiviert ist.

XJ011.S=Null kann nicht als Name f\u00FCr den SAVEPOINT \u00FCbergeben werden.

# Arguments:
#
#    {0} = interfaceName
#
XJ012.S=''{0}'' ist bereits geschlossen.

XJ013.S=Keine ID f\u00FCr benannte SAVEPOINTS.

XJ014.S=Kein Name f\u00FCr nicht benannte SAVEPOINTS.

XJ015.M=Derby-System wird heruntergefahren.

# Arguments:
#
#    {0} = methodName
#
XJ016.S=Methode ''{0}'' ist in einer vorbereiteten Anweisung nicht zul\u00E4ssig.

XJ017.S=Innerhalb des Triggercodes ist ein Savepoint-Befehl nicht zul\u00E4ssig.

XJ018.S=Spaltenname muss ungleich null sein.

# Arguments:
#
#    {0} = typeName
#
XJ020.S=Objekttyp kann nicht in Typ ''{0}'' konvertiert werden. Der Wert f\u00FCr java.sql.Types ist ung\u00FCltig oder das Objekt war null.

XJ021.S=Typ wird nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = name
#
XJ022.S=Folgender Stream kann nicht eingerichtet werden: ''{0}''.

XJ023.S=Datenmenge des Input Streams entspricht nicht exakt der angeforderten L\u00E4nge.

XJ025.S=Input Stream kann keine negative L\u00E4nge haben.

# Arguments:
#
#    {0} = urlValue
#
XJ028.C=Die URL ''{0}'' hat nicht das richtige Format.

XJ030.S=In einer verschachtelten Verbindung kann Autocommit On nicht festgelegt werden.

# Arguments:
#
#    {0} = databaseName
#    {1} = classLoader
#
XJ040.C=Datenbank ''{0}'' konnte nicht mit dem Class Loader {1} gestartet werden. Details k\u00F6nnen Sie der n\u00E4chsten Ausnahme entnehmen.

# Arguments:
#
#    {0} = databaseName
#
XJ041.C=Datenbank ''{0}'' konnte nicht erstellt werden. Details k\u00F6nnen Sie der n\u00E4chsten Ausnahme entnehmen.

# Arguments:
#
#    {0} = propertyValue
#    {1} = propertyName
#
XJ042.S=''{0}'' ist kein g\u00FCltiger Wert f\u00FCr Eigenschaft ''{1}''.

# Arguments:
#
#    {0} = number
#
XJ044.S=''{0}'' ist eine ung\u00FCltige Nachkommastellenangabe.

# Arguments:
#
#    {0} = levelName
#
XJ045.S=An Connection.setTransactionIsolation() wurde die ung\u00FCltige oder (derzeit) nicht unterst\u00FCtzte Isolationsebene ''{0}'' \u00FCbergeben. Derzeit unterst\u00FCtzte Werte sind java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED und java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.

# Arguments:
#
#    {0} = attributes
#
XJ048.C=Es wurden Konflikte verursachende Boot-Attribute angegeben: {0}

XJ049.C=Es wurden Konflikte verursachende Erstellungsattribute angegeben.

XJ04B.S=Batch darf keinen Befehl enthalten, der versucht, eine Ergebnismenge zur\u00FCckzugeben.

XJ04C.S=Batch "CallableStatement" darf keine Outputparameter enthalten.

XJ056.S=In einer XA-Verbindung kann Autocommit On nicht festgelegt werden.

XJ057.S=Eine globale Transaktion kann nicht \u00FCber die Verbindung festgeschrieben werden. Die COMMIT-Verarbeitung muss \u00FCber die Schnittstelle XAResource erfolgen.

XJ058.S=Eine globale Transaktion kann nicht \u00FCber die Verbindung zur\u00FCckgesetzt werden. Die COMMIT-Verarbeitung muss \u00FCber die Schnittstelle XAResource erfolgen.

XJ059.S=Eine Verbindung kann nicht beendet werden, solange noch eine globale Transaktion aktiv ist.

# Arguments:
#
#    {0} = attributeName
#    {1} = attributeValue
#    {2} = attributeValues
#
XJ05B.C=JDBC-Attribut ''{0}'' hat einen ung\u00FCltigen Wert ''{1}''. G\u00FCltige Werte sind: ''{2}''.

XJ05C.S=Holdability f\u00FCr ResultSet.HOLD_CURSORS_OVER_COMMIT kann f\u00FCr eine globale Transaktion nicht eingerichtet werden.

# Arguments:
#
#    {0} = methodName
#
XJ061.S=Methode ''{0}'' ist nur f\u00FCr Scroll-Cursor zul\u00E4ssig.

# Arguments:
#
#    {0} = invalidNumber
#
XJ062.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr ResultSet.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ063.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr Statement.setMaxRows(int maxRows). Der Parameterwert muss >= 0 sein.

# Arguments:
#
#    {0} = invalidNumber
#
XJ064.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr setFetchDirection(int direction).

# Arguments:
#
#    {0} = invalidNumber
#
XJ065.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr Statement.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ066.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr Statement.setMaxFieldSize(int max).

XJ067.S=SQL-Textzeiger ist null.

XJ068.S=In der Mitte eines Batches sind nur executeBatch und clearBatch zul\u00E4ssig.

XJ069.S=F\u00FCr die Ausf\u00FChrungsanweisung USING sind keine SetXXX-Methoden zul\u00E4ssig.

# Arguments:
#
#    {0} = argument
#
XJ070.S=In einer BLOB- oder CLOB-Methode wurde das Argument ''{0}'' mit negativer oder Nullposition \u00FCbergeben.

# Arguments:
#
#    {0} = argument
#
XJ071.S=An eine BLOB- oder CLOB-Methode wurde das negative L\u00E4ngenargument ''{0}'' \u00FCbergeben.

XJ072.S=An eine BLOB- oder CLOB-Methode wurde ein Nullmuster oder eine Nullsuchzeichenfolge \u00FCbergeben.

XJ073.S=Die Daten in diesem BLOB oder CLOB sind nicht mehr verf\u00FCgbar. M\u00F6glicherweise wurde die Transaktion des BLOB/CLOB festgeschrieben, die Verbindung geschlossen oder freigegeben.

# Arguments:
#
#    {0} = invalidNumber
#
XJ074.S=Ung\u00FCltiger Parameterwert ''{0}'' f\u00FCr Statement.setQueryTimeout(int seconds)

# Arguments:
#
#    {0} = positionArgument
#
XJ076.S=Das Positionsargument ''{0}'' \u00FCberschreitet die Gr\u00F6\u00DFe des BLOB/CLOB.

XJ077.S=Bei dem Versuch, mit getBytes/getSubString das erste Byte/Zeichen des BLOB/CLOB-Musters zu lesen, wurde eine Ausnahme empfangen.

# Arguments:
#
#    {0} = invalidNumber
#
XJ078.S=Die relative Position ''{0}'' ist entweder kleiner als null oder f\u00FCr das aktuelle BLOB/CLOB zu gro\u00DF.

# Arguments:
#
#    {0} = number
#
XJ079.S=Die angegebene L\u00E4nge ''{0}'' \u00FCberschreitet die Gr\u00F6\u00DFe des BLOB/CLOB.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ080.S=Die Ausf\u00FChrungsanweisung USING hat an Stelle von {1} Parametern {0} Parameter \u00FCbergeben.

XJ081.C=Es wurden Konflikte verursachende Erstellungs-/Wiederherstellungsattribute angegeben.

# Arguments:
#
#    {0} = parameterValue
#    {1} = parameterName
#    {2} = methodName
#
XJ081.S=An die Methode ''{2}'' wurde der ung\u00FCltige Wert ''{0}'' als Parameter ''{1}'' \u00FCbergeben.

XJ085.S=Stream wurde bereits gelesen. Das Dateiende ist erreicht und kann nicht erneut verwendet werden.

XJ086.S=Wenn der Cursor nicht in der Einf\u00FCgezeile steht oder der gemeinsame Zugriff f\u00FCr dieses ResultSet-Objekt auf CONCUR_READ_ONLY festgelegt ist, kann diese Methode nicht aufgerufen werden.

# Arguments:
#
#    {0} = pos
#    {1} = length
#
XJ087.S=Summe von position(''{0}'') und length(''{1}'') ist gr\u00F6\u00DFer als die Gr\u00F6\u00DFe der LOB plus eins.

XJ088.S=Ung\u00FCltiger Vorgang: wasNull() wurde ohne abgerufene Daten aufgerufen.

XJ090.S=Ung\u00FCltiger Parameter: calendar ist null.

# Arguments:
#
#    {0} = indexNumber
#
XJ091.S=Ung\u00FCltiges Argument: Parameterindex {0} ist kein OUT- oder INOUT-Parameter.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ093.S=Das BLOB/CLOB {0} ist zu lang. Die L\u00E4nge darf {1} nicht \u00FCberschreiten.

XJ095.S=Der Versuch, eine Aktion mit erforderlicher Berechtigung auszuf\u00FChren, war nicht erfolgreich.

XJ097.S=Ein Savepoint, der nicht von dieser Verbindung erstellt wurde, kann nicht zur\u00FCckgesetzt oder freigegeben werden.

# Arguments:
#
#    {0} = keyValue
#
XJ098.S=Der automatisch generierte Schl\u00FCsselwert {0} ist ung\u00FCltig

XJ099.S=Das Reader-/Stream-Objekt enth\u00E4lt keine L\u00E4ngenzeichen

XJ100.S=Die von der Methode registerOutParameter angegebene Anzahl der Nachkommastellen stimmt nicht mit der setter-Methode \u00FCberein. Genauigkeitsverlust ist m\u00F6glich.

XJ103.S=Tabellenname muss ungleich null sein.

# Arguments:
#
#    {0} = invalidNumber
#
XJ104.S=Ung\u00FCltige L\u00E4nge des gemeinsamen Schl\u00FCssels: {0}.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ105.S=DES-Schl\u00FCssel hat die falsche L\u00E4nge. Erwartete L\u00E4nge: {0}, empfangene L\u00E4nge: {1}

XJ106.S=Kein derartiges Padding 

XJ107.S=Falsches Padding

XJ108.S=Nicht zul\u00E4ssige Blockgr\u00F6\u00DFe

XJ110.S=Name der Prim\u00E4rtabelle darf nicht leer sein.

XJ111.S=Name der Prim\u00E4rtabelle darf nicht leer sein.

XJ112.S=Es wurde eine Sicherheitsausnahme festgestellt. Weitere Details finden Sie in der n\u00E4chsten Ausnahme.

# Arguments:
#
#    {0} = fileName
#    {1} = error
#
XJ113.S=Datei {0} kann nicht ge\u00F6ffnet werden. {1}

# Arguments:
#
#    {0} = cursorName
#
XJ114.S=Ung\u00FCltiger Cursorname ''{0}''

# Arguments:
#
#    {0} = invalidNumber
#
XJ115.S=ResultSet kann nicht mit der angeforderten Holdability {0} ge\u00F6ffnet werden.

# Arguments:
#
#    {0} = number
#
XJ116.S=Zu einem Batch k\u00F6nnen nicht mehr als {0} Befehle hinzugef\u00FCgt werden.

XJ117.S=Gem\u00E4\u00DF J2EE k\u00F6nnen Abfragen nicht im Batchmodus verarbeitet werden.

XJ118.S=F\u00FCr eine Nicht-Abfrageanweisung wurde eine Abfragebatchverarbeitung angefordert.

XJ121.S=Ung\u00FCltiger Vorgang bei aktueller Cursorposition.

XJ122.S=F\u00FCr diese Zeile wurden keine updateXXX-Methoden aufgerufen.

XJ123.S=Diese Methode muss aufgerufen werden, um Werte in der aktuellen Zeile oder der Einf\u00FCgezeile zu aktualisieren.

XJ124.S=Spalte kann nicht aktualisiert werden.

XJ125.S=Diese Methode sollte nur f\u00FCr ResultSet-Objekte vom Typ TYPE_SCROLL_INSENSITIVE aufgerufen werden.

XJ126.S=Diese Methode sollte nicht f\u00FCr sensitive dynamische Cursor aufgerufen werden.

# Arguments:
#
#    {0} = interfaceName
#
XJ128.S=F\u00FCr ''{0}'' konnte kein unwrap ausgef\u00FChrt werden.

# Arguments:
#
#    {0} = number
#
XJ200.S=Maximale Anzahl der Abschnitte {0} wurde \u00FCberschritten.

# Arguments:
#
#    {0} = cursorName
#
XJ202.S=Ung\u00FCltiger Cursorname ''{0}''.

# Arguments:
#
#    {0} = cursorName
#
XJ203.S=Cursorname ''{0}'' wird bereits verwendet.

# Arguments:
#
#    {0} = holdValue
#
XJ204.S=Ergebnismenge kann nicht mit der angeforderten Holdability {0} ge\u00F6ffnet werden.

# Arguments:
#
#    {0} = sqlText
#
XJ206.S=SQL-Text ''{0}'' enth\u00E4lt keine Token.

XJ207.S=Methode executeQuery kann nicht f\u00FCr ein Update verwendet werden.

XJ208.S=Fehler bei nicht atomarem Batchvorgang. Der Batch wurde \u00FCbergeben. Bei einem Batch-Member ist jedoch mindestens eine Ausnahme eingetreten. Mit getNextException() k\u00F6nnen Sie die Ausnahmen f\u00FCr bestimmte Batchelemente abrufen.

XJ209.S=Die erforderliche gespeicherte Prozedur ist nicht auf dem Server installiert.

XJ210.S=Der Name des Lademoduls f\u00FCr die gespeicherte Prozedur auf dem Server wurde nicht gefunden.

XJ211.S=W\u00E4hrend der Batchverarbeitung ist eine Kettenunterbrechungsausnahme eingetreten, nach der keine Wiederherstellung m\u00F6glich ist. Der Batch wird nicht atomar beendet.

# Arguments:
#
#    {0} = attributeSyntax
#
XJ212.S=Ung\u00FCltige Attributsyntax: {0}

XJ213.C=Die Verbindungseigenschaft "traceLevel" hat kein g\u00FCltiges Format f\u00FCr eine Zahl.

XJ214.S=Beim Aufrufen von free() f\u00FCr ein CLOB oder BLOB ist ein I/O-Fehler aufgetreten.

XJ215.S=Es k\u00F6nnen keine weiteren java.sql.Clob/java.sql.Blob-Methoden aufgerufen werden, nachdem die free()-Methode aufgerufen oder nachdem die Blob/Clob-Transaktion ausgef\u00FChrt oder zur\u00FCckgerollt wurde.

XJ216.S=Die L\u00E4nge dieses BLOB/CLOB ist noch nicht verf\u00FCgbar. Wenn ein BLOB oder CLOB als ein Stream zug\u00E4nglich ist, wird die L\u00E4nge erst verf\u00FCgbar, nachdem der gesamte Stream verarbeitet wurde.

XJ217.S=Der f\u00FCr dieses CLOB/BLOB angegebene Locator ist ung\u00FCltig

# Arguments:
#
#    {0} = reason
#
XK000.S=Die Sicherheits-Policy konnte nicht neu geladen werden: {0}

XK001.S=Benutzername in SYS.SYSUSERS nicht gefunden.

XN001.S=Innerhalb einer Arbeitseinheit ist eine Zur\u00FCcksetzung der Verbindung nicht zul\u00E4ssig.

XN008.S=Abfrageverarbeitung wurde wegen eines Fehlers auf dem Server abgebrochen.

XN009.S=Fehler beim Abrufen der L\u00E4nge des BLOB/CLOB. Die Ausnahme folgt.

XN010.S=Prozedurname muss ungleich null sein.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XN011.S=L\u00E4nge {0} des Prozedurnamens liegt au\u00DFerhalb des g\u00FCltigen Bereichs von 1 bis {1}.

# Arguments:
#
#    {0} = operatingSystemName
#    {1} = versionNumber
#    {2} = versionNumber
#
XN012.S=Auf {0}-Plattformen unterst\u00FCtzt XA Version {1} und h\u00F6her. Dies ist Version {2}.

XN013.S=Ung\u00FCltige Scrollrichtung

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN014.S=Beim Lesen aus einem durch den Parameter #{0} festgelegten Stream ist eine Ausnahme aufgetreten. Die verbleibenden vom Server erwarteten Daten wurden mit 0x0 aufgef\u00FCllt. Die Ausnahme generierte folgende Meldung: {1}.

# Arguments:
#
#    {0} = number
#
XN015.S=Netzwerkprotokollfehler: Die angegebene Gr\u00F6\u00DFe des Input-Streams, Parameter {0}, unterschreitet die tats\u00E4chliche InputStream-L\u00E4nge.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN016.S=Beim Versuch, die L\u00E4nge des durch den Parameter #{0} festgelegten Streams zu verifizieren, wurde eine Ausnahme festgestellt. Die Ausnahme generierte folgende Meldung: {1}.

# Arguments:
#
#    {0} = number
#
XN017.S=Beim Lesen eines durch den Parameter #{0} festgelegten Streams wurde das Ende des Streams zu fr\u00FCh erreicht. Die verbleibenden vom Server erwarteten Daten wurden mit 0x0 aufgef\u00FCllt.

# Arguments:
#
#    {0} = number
#
XN018.S=Netzwerkprotokollfehler: Die angegebene Reader-Gr\u00F6\u00DFe (Parameter {0}) liegt unter der tats\u00E4chlichen InputStream-L\u00E4nge.

# Arguments:
#
#    {0} = xaFunctionName
#    {1} = xaError
#
XN019.S=Fehler beim Ausf\u00FChren von {0}. Der Server hat Folgendes zur\u00FCckgegeben: {1}

# Arguments:
#
#    {0} = messageDetail
#
XN020.S=Fehler beim Marshalling oder Unmarshalling eines benutzerdefinierten Typs: {0}

# Arguments:
#
#    {0} = sourceClassName
#    {1} = targetClassName
#
XN021.S=Ein Objekt des Typs {0} kann nicht in ein Objekt des Typs {1} umgeformt werden.

XRE00=Dieses LogFactory-Modul unterst\u00FCtzt keine Replikation.

XRE01=Das von Master empfangene Log ist fehlerhaft.

XRE02=Master und Slave haben verschiedene Versionen. Fortsetzung der Replikation nicht m\u00F6glich.

XRE03=Unerwarteter Fehler bei Replikation. Details finden Sie in derby.log.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = portname
#
XRE04.C.1=Eine Verbindung zum Peer der replizierten Datenbank ''{0}'' in Adresse ''{1}:{2}'' konnte nicht hergestellt werden.

# Arguments:
#
#    {0} = dbname
#
XRE04.C.2=Verbindung zu replizierter Datenbank ''{0}'' unterbrochen.

# Arguments:
#
#    {0} = dbname
#    {1} = masterfile
#    {2} = masteroffset
#    {3} = slavefile
#    {4} = slaveoffset
#
XRE05.C=Die Logdateien auf Master und Slave stimmen f\u00FCr die replizierte Datenbank ''{0}'' nicht \u00FCberein. Die Master-Logadresse ist {1}:{2}, w\u00E4hrend die Slave-Logadresse {3}:{4} ist. Dies ist ein schwerwiegender Fehler f\u00FCr die Replikation - Replikation wird gestoppt.

# Arguments:
#
#    {0} = dbname
#
XRE06=Die Verbindungsversuche mit dem Replication Slave f\u00FCr Datenbank {0} \u00FCberschreiten den festgelegten Timeoutzeitraum.

XRE07=Vorgang konnte nicht ausgef\u00FChrt werden, da sich die Datenbank nicht im Replication Master-Modus befindet.

# Arguments:
#
#    {0} = dbname
#
XRE08=Replication Slave-Modus erfolgreich gestartet f\u00FCr Datenbank ''{0}''. Verbindung zur\u00FCckgewiesen, da sich Datenbank im Replication Slave-Modus befindet. 

# Arguments:
#
#    {0} = dbname
#
XRE09.C=Replication Slave-Modus f\u00FCr Datenbank ''{0}'' kann nicht gestartet werden. Die Datenbank wurde bereits gebootet.

# Arguments:
#
#    {0} = attribute
#
XRE10=Es wurden Konflikte verursachende Attribute angegeben. Entnehmen Sie dem Referenzhandbuch die zul\u00E4ssigen Attribute im Zusammenhang mit dem Replikationsattribut ''{0}''.

# Arguments:
#
#    {0} = command
#    {1} = dbname
#
XRE11.C=Vorgang ''{0}'' konnte nicht ausgef\u00FChrt werden, weil die Datenbank ''{1}'' nicht gebootet wurde.

# Arguments:
#
#    {0} = dbname
#    {1} = expectedtype
#    {2} = receivedtype
#
XRE12=Replikations-Netzwerkprotokollfehler f\u00FCr Datenbank ''{0}''. Erwarteter Meldungstyp war ''{1}'', tats\u00E4chlich empfangener Typ ist ''{2}''.

# Arguments:
#
#    {0} = dbname
#
XRE20.D=Failover erfolgreich ausgef\u00FChrt f\u00FCr Datenbank ''{0}'', die Datenbank wurde heruntergefahren.

# Arguments:
#
#    {0} = dbname
#
XRE21.C=Bei der Ausf\u00FChrung des Failovers f\u00FCr die Datenbank ''{0}'' ist ein Fehler aufgetreten. Failover-Versuch wurde abgebrochen.

# Arguments:
#
#    {0} = dbname
#
XRE22.C=Replication Master wurde bereits f\u00FCr Datenbank ''{0}'' gebootet

XRE23=Replication Master kann nicht gestartet werden, da unprotokollierte Vorg\u00E4nge ausgef\u00FChrt werden, lassen Sie die unprotokollierten Vorg\u00E4nge beenden und starten Sie die Replikation neu

XRE40=Vorgang konnte nicht ausgef\u00FChrt werden, da sich die Datenbank nicht im Replication Slave-Modus befindet.

XRE41.C=Replikationsvorgang "failover" oder "stopSlave" wurde f\u00FCr die Slave-Datenbank abgelehnt, weil die Verbindung zum Master funktioniert. Setzen Sie den Vorgang "failover" oder "stopMaster" stattdessen auf der Master-Datenbank ab.

# Arguments:
#
#    {0} = dbname
#
XRE42.C=Replizierte Datenbank ''{0}'' heruntergefahren.

XRE43=Unerwarteter Fehler bei dem Versuch, den Replication Slave-Modus anzuhalten. Zum Stoppen des Replication Slave-Modus verwenden Sie die Vorg\u00E4nge "stopSlave" oder "failover".

# Arguments:
#
#    {0} = conglomerateNumber
#
XSAI2.S=Das angeforderte Konglomerat ({0}) ist nicht vorhanden.

XSAI3.S=Feature nicht implementiert.

# Arguments:
#
#    {0} = interfaceName
#
XSAM0.S=Beim Versuch, ein Modul f\u00FCr ''{0}'' zu booten, wurde eine Ausnahme festgestellt.

# Arguments:
#
#    {0} = conglomID
#
XSAM2.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' zum L\u00F6schen vorhanden.

# Arguments:
#
#    {0} = conglomID
#
XSAM3.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' vorhanden.

# Arguments:
#
#    {0} = sortName
#
XSAM4.S=Es gibt keine Sortierung ''{0}''.

XSAM5.S=Sie m\u00FCssen den Scan \u00F6ffnen und positionieren, indem Sie vor allen anderen Aufrufen next() aufrufen.

# Arguments:
#
#    {0} = containerName
#    {1} = pageNumber
#    {2} = recordNumber
#
XSAM6.S=Datensatz {2} auf Seite {1} im Container {0} wurde nicht gefunden.

XSAS0.S=Es wurde eine Schnittstellenmethode des Scancontrollers aufgerufen, die f\u00FCr das Durchsuchen einer Sortierung nicht geeignet ist.

XSAS1.S=Es wurde versucht, eine Zeile vor Beginn oder nach Beendigung einer Suche abzurufen.

XSAS3.S=Der Typ einer in eine Sortierung eingef\u00FCgten Zeile stimmt nicht mit der Sortiervorlage \u00FCberein.

XSAS6.S=Es konnten keine Ressourcen f\u00FCr die Sortierung angefordert werden.

XSAX0.S=Fehlerhaftes XA-Protokoll.

XSAX1.S=Es wurde versucht, eine globale Transaktion mit der XID einer vorhandenen globalen Transaktion zu starten.

XSCB0.S=Container konnte nicht erstellt werden.

# Arguments:
#
#    {0} = containerName
#
XSCB1.S=Container {0} wurde nicht gefunden.

# Arguments:
#
#    {0} = propertyName
#
XSCB2.S=In der f\u00FCr createConglomerate() f\u00FCr den Sekund\u00E4rindex einer Baumstruktur bereitgestellten Eigenschaftsliste wurde die erforderliche Eigenschaft {0} nicht gefunden.

XSCB3.S=Nicht implementiertes Feature.

# Arguments:
#
#    {0} = number
#
XSCB4.S=F\u00FCr einen begonnenen Scan in einer B-Baumstruktur wurde eine Methode aufgerufen, bevor der Scan in der ersten Zeile positioniert wurde (d.h. next() wurde noch nicht aufgerufen). Der aktuelle Status des Scans ist ({0}).

XSCB5.S=W\u00E4hrend des logischen Widerrufs eines Einf\u00FCgen- oder L\u00F6schvorgangs f\u00FCr eine B-Baumstruktur konnte die Zeile im Baum nicht gefunden werden.

XSCB6.S=Einschr\u00E4nkung: Der Datensatz f\u00FCr den Sekund\u00E4rindex einer B-Baumstruktur kann wegen unzureichenden Speicherplatzes auf der Seite nicht aktualisiert oder eingef\u00FCgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00E4nkung zu umgehen.

# Arguments:
#
#    {0} = trueOrFalse
#    {1} = trueOrFalse
#
XSCB7.S=Beim Scan einer B-Baumstruktur wurde ein interner Fehler festgestellt; current_rh ist null \\= {0}; der Positionsschl\u00FCssel ist null \\= {1}.

# Arguments:
#
#    {0} = conglomerateNumber
#
XSCB8.S=Das B-Baum-Konglomerat {0} ist geschlossen.

XSCB9.S=F\u00FCr Testzwecke reserviert.

XSCG0.S=Eine Vorlage konnte nicht erstellt werden.

XSCH0.S=Container konnte nicht erstellt werden.

# Arguments:
#
#    {0} = containerName
#
XSCH1.S=Container {0} wurde nicht gefunden.

XSCH4.S=Ein Konglomerat konnte nicht erstellt werden.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSCH5.S=In einer Basistabelle wich die Anzahl der angeforderten Spalten {0} von der maximalen Spaltenanzahl {1} ab.

# Arguments:
#
#    {0} = containerID
#
XSCH6.S=Heap mit Container-ID {0} ist geschlossen.

XSCH7.S=Der Scan ist nicht positioniert.

XSCH8.S=Das Feature ist nicht implementiert.

XSDA1.S=Es wurde versucht, auf einer Seite auf eine Stelle au\u00DFerhalb des Bereiches zuzugreifen.

XSDA2.S=Es wurde versucht, einen gel\u00F6schten Datensatz zu aktualisieren.

XSDA3.S=Einschr\u00E4nkung: Der Datensatz f\u00FCr den Sekund\u00E4rindex einer B-Baumstruktur kann wegen unzureichenden Speicherplatzes auf der Seite nicht aktualisiert oder eingef\u00FCgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00E4nkung zu umgehen.

XSDA4.S=Es wurde eine unerwartete Ausnahme ausgel\u00F6st.

XSDA5.S=Es wurde versucht, das L\u00F6schen eines nicht gel\u00F6schten Datensatzes zu widerrufen.

# Arguments:
#
#    {0} = columnName
#
XSDA6.S=Spalte {0} der Zeile ist gleich null. Sie muss so konfiguriert werden, dass sie auf ein Objekt zeigt.

# Arguments:
#
#    {0} = className
#
XSDA7.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde versucht, mehr Daten zu lesen, als urspr\u00FCnglich gespeichert wurden.

# Arguments:
#
#    {0} = className
#
XSDA8.S=Ausnahme beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0}.

# Arguments:
#
#    {0} = className
#
XSDA9.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde die Klasse nicht gefunden.

# Arguments:
#
#    {0} = timestamp
#
XSDAA.S=Ung\u00FCltiger Zeitstempel {0}. Der Zeitstempel stammt von einer anderen Seite oder von einer inkompatiblen Implementierung.

XSDAB.S=Ein Nullzeitstempel kann nicht festgelegt werden.

XSDAC.S=Es wurde versucht, Zeilen oder Seiten von einem Container in einen anderen zu verschieben.

XSDAD.S=Es wurde versucht, Nullzeilen von einer Seite auf eine andere zu verschieben.

XSDAE.S=Ein Datensatz-Handle kann nur f\u00FCr eine bestimmte Datensatz-Handle-ID erstellt werden.

XSDAF.S=Ein besonderer Datensatz-Handle wird wie ein normaler Datensatz-Handle verwendet.

XSDAG.S=Der Container kann nicht durch die erste verschachtelte Zuordnungstransaktion ge\u00F6ffnet werden.

# Arguments:
#
#    {0} = page
#
XSDAI.S=Seite {0}, die gerade entfernt wird, ist bereits gesperrt, um freigegeben zu werden.

XSDAJ.S=Ausnahme beim Schreiben eines serialisierbaren oder SQLData-Objekts.

# Arguments:
#
#    {0} = recordHandle
#
XSDAK.S=F\u00FCr Datensatz-Handle {0} wurde eine falsche Seite abgerufen.

# Arguments:
#
#    {0} = recordHandle
#
XSDAL.S=Datensatz-Handle {0} verweist auf \u00DCberlaufbereich.

# Arguments:
#
#    {0} = className
#
XSDAM.S=Ausnahme beim Wiederherstellen eines SQLData-Objekts der Klasse {0}. Angegebene Klasse kann nicht instanziiert werden.

# Arguments:
#
#    {0} = className
#
XSDAN.S=Ausnahme beim Wiederherstellen eines SQLData-Objekts der Klasse {0}. Die angegebene Klasse hat eine Ausnahme aufgrund eines nicht zul\u00E4ssigen Zugriffs festgestellt.

# Arguments:
#
#    {0} = pageNumber
#
XSDAO.S=Interner Fehler: Beim Versuch, auf die Seite {0} zuzugreifen, traten zwei Latches auf.

# Arguments:
#
#    {0} = page
#
XSDB0.D=Unerwartete Ausnahme auf der speicherinternen Seite {0}

# Arguments:
#
#    {0} = page
#
XSDB1.D=Unbekanntes Seitenformat auf der Seite {0}

# Arguments:
#
#    {0} = containerName
#    {1} = number
#
XSDB2.D=Unbekanntes Containerformat bei Container {0}: {1}

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSDB3.D=Einmal geschriebene Containerinformationen k\u00F6nnen nicht ge\u00E4ndert werden. Vorheriger Stand: {0}; aktueller Stand: {1}

# Arguments:
#
#    {0} = page
#    {1} = versionNumber
#    {2} = versionNumber
#
XSDB4.D=Seite {0} hat Version {1}. Die Logdatei enth\u00E4lt die \u00C4nderungsversion {2}. Es fehlen Logdatens\u00E4tze dieser Seite oder die Seite wurde nicht ordnungsgem\u00E4\u00DF auf den Datentr\u00E4ger geschrieben.

# Arguments:
#
#    {0} = page
#
XSDB5.D=Der \u00C4nderungsdatensatz befindet sich auf Seite {0} des Logs. Seite befindet sich au\u00DFerhalb des Containerendes.

# Arguments:
#
#    {0} = databaseName
#
XSDB6.D=Die Datenbank {0} wurde m\u00F6glicherweise bereits von einer anderen Derby-Instanz gebootet.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB7.D=Warnung: Derby (Instanz {0}) versucht, die Datenbank {1} zu booten, obwohl Derby (Instanz {2}) noch aktiv sein k\u00F6nnte. Eine Datenbank sollte immer nur von jeweils einer Derby-Instanz gebootet werden. Es k\u00F6nnen schwerwiegende und irreparable Sch\u00E4den eingetreten sein oder noch eintreten.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB8.D=Warnung: Derby (Instanz {0}) versucht, die Datenbank {1} neu zu booten, obwohl Derby (Instanz {2}) m\u00F6glicherweise immer noch aktiv ist. Eine Datenbank sollte immer nur von einer Derby-Instanz gebootet werden. Wenn zwei Instanzen von Derby mit derselben Datenbank zur selben Zeit einen Bootvorgang durchf\u00FChren, kann dies zu schwerwiegenden und unwiderruflichen Besch\u00E4digungen f\u00FChren. Die Eigenschaft "derby.database.forceDatabaseLock=true" wurde festgelegt, sodass die Datenbank erst dann gebootet wird, wenn die Datei db.lck nicht mehr vorhanden ist. Normalerweise wird diese Datei entfernt, wenn die erste Instanz von Derby, die einen Bootvorgang an der Datenbank ausf\u00FChrt, vorhanden ist. Sie kann jedoch bei manchen Herunterfahrvorg\u00E4ngen zur\u00FCckbleiben. In diesem Fall muss die Datei manuell entfernt werden. Es ist wichtig, dass Sie sicherstellen, dass keine andere VM auf die Datenbank zugreift, bevor Sie die Datei db.lck manuell l\u00F6schen.

# Arguments:
#
#    {0} = containerName
#
XSDB9.D=Stream-Container {0} ist besch\u00E4digt.

# Arguments:
#
#    {0} = object
#
XSDBA.D=Der Versuch, das Objekt {0} zuzuordnen, war nicht erfolgreich.

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#
XSDBB.D=Unbekanntes Seitenformat auf der Seite {0}, Seitenspeicherauszug: {1}

# Arguments:
#
#    {0} = container
#
XSDBC.D=Das Schreiben von Container-Informationen auf Seite 0 von Container {0} war nicht erfolgreich. Weitere Informationen finden Sie im verschachtelten Fehler. 

# Arguments:
#
#    {0} = fileName
#
XSDF0.S=Datei {0} konnte nicht erstellt werden, da sie bereits vorhanden ist.

# Arguments:
#
#    {0} = fileName
#
XSDF1.S=Beim Erstellen der Datei {0} f\u00FCr den Container ist eine Ausnahme eingetreten.

# Arguments:
#
#    {0} = fileName
#    {1} = exceptionText
#
XSDF2.S=Beim Erstellen der Datei {0} f\u00FCr den Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. Ausnahme: {1}.

# Arguments:
#
#    {0} = segmentName
#
XSDF3.S=Segment {0} kann nicht erstellt werden.

# Arguments:
#
#    {0} = fileName
#    {1} = detailedException
#
XSDF4.S=Beim Entfernen der Datei {0} f\u00FCr den gel\u00F6schten Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. {1}.

# Arguments:
#
#    {0} = page
#
XSDF6.S=Zuordnungsseite {0} wurde nicht gefunden.

# Arguments:
#
#    {0} = pageKey
#
XSDF7.S=Die neu erstellte Seite {0} konnte nicht gesperrt werden.

# Arguments:
#
#    {0} = page
#
XSDF8.S=Die wiederzuverwendende Seite {0} wurde nicht gefunden.

XSDFB.S=Vorgang wird von einer schreibgesch\u00FCtzten Datenbank nicht unterst\u00FCtzt.

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#    {2} = hexDump
#
XSDFD.S=Auf Seite {0} wurden in zwei I/O-Inhalte verschiedene Seitenimages gelesen. Das erste Image hat die falsche Pr\u00FCfsumme und das zweite die richtige. Seitenimages: {1} {2}

XSDFF.S=Der angeforderte Vorgang war aufgrund einer unerwarteten Ausnahme nicht erfolgreich.

# Arguments:
#
#    {0} = fileName
#
XSDFH.S=Die Datenbank kann nicht gesichert werden. Beim Schreiben in die Backupcontainerdatei {0} wurde eine I/O-Ausnahme empfangen.

# Arguments:
#
#    {0} = page
#
XSDFI.S=Bei dem Versuch, w\u00E4hrend der Datenbankwiederherstellung Daten auf Datentr\u00E4ger zu schreiben, wurde ein Fehler festgestellt. \u00DCberpr\u00FCfen Sie, ob der Datentr\u00E4ger mit der Datenbank voll ist. Sollte dies der Fall sein, l\u00F6schen Sie nicht ben\u00F6tigte Dateien und versuchen Sie erneut, eine Verbindung zur Datenbank herzustellen. Es kann auch sein, dass das Dateisystem schreibgesch\u00FCtzt ist oder ein Datentr\u00E4gerfehler vorliegt. Das System hat bei der Verarbeitung der Seite {0} einen Fehler festgestellt.

# Arguments:
#
#    {0} = page
#
XSDG0.D=Seite {0} konnte nicht vom Datentr\u00E4ger gelesen werden.

# Arguments:
#
#    {0} = page
#
XSDG1.D=Seite {0} konnte nicht auf den Datentr\u00E4ger geschrieben werden. Pr\u00FCfen Sie, ob der Datentr\u00E4ger voll ist oder eine Dateisystembegrenzung wie beispielsweise ein bestimmtes Kontingent oder eine maximale Dateigr\u00F6\u00DFe erreicht wurden.

# Arguments:
#
#    {0} = page
#    {1} = number
#    {2} = number
#    {3} = hexDump
#
XSDG2.D=Ung\u00FCltige Pr\u00FCfsumme auf der Seite {0}. Erwartet: {1}, Version auf Datentr\u00E4ger: {2}. Seitenspeicherauszug: {3}

# Arguments:
#
#    {0} = containerName
#    {1} = type
#    {2} = file
#
XSDG3.D=Auf die Metadaten f\u00FCr {0} konnte nicht zugegriffen werden in {1} {2}

XSDG5.D=Datenbank befand sich nicht im Erstellungsmodus, als createFinished aufgerufen wurde.

# Arguments:
#
#    {0} = directoryPath
#
XSDG6.D=Bei der Wiederherstellung wurde das Datensegmentverzeichnis nicht in Backup {0} gefunden. Vergewissern Sie sich, dass es sich um das richtige Backup handelt und dieses nicht besch\u00E4digt ist.

# Arguments:
#
#    {0} = directoryName
#
XSDG7.D=Bei der Wiederherstellung konnte das Verzeichnis {0} nicht entfernt werden. Vergewissern Sie sich, dass die notwendigen Berechtigungen vorliegen.

# Arguments:
#
#    {0} = directoryName
#    {1} = directoryName
#
XSDG8.D=Bei der Wiederherstellung konnte das Verzeichnis ''{0}'' nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00FCgbar ist und dass die notwendigen Berechtigungen vorliegen. 

XSDG9.D=Derby-Thread wurde w\u00E4hrend eines Datentr\u00E4ger-I/O-Vorgangs unterbrochen. \u00DCberpr\u00FCfen Sie Ihre Anwendung, um die Ursache der Unterbrechung festzustellen.

# Arguments:
#
#    {0} = filePath
#
XSLA0.D=Die freigegebene Logdatei kann nicht auf den Datentr\u00E4ger {0} geschrieben werden.

# Arguments:
#
#    {0} = object
#
XSLA1.D=Logdatensatz wurde an den Stream gesendet, kann jedoch nicht auf den Speicher (Objekt {0}) angewendet werden. Dies kann zu Fehlern bei der Wiederherstellung f\u00FChren.

XSLA2.D=System wird heruntergefahren. Beim Zugriff auf die Logdatei wurde eine I/O-Ausnahme empfangen.

XSLA3.D=Log ist besch\u00E4digt. Der Logdaten-Stream enth\u00E4lt ung\u00FCltige Daten.

XSLA4.D=Fehler beim Versuch zu schreiben in das Transaktionwiederherstellungslog.  Wahrscheinlich ist der Datentr\u00E4ger die das Wiederherstellungslog h\u00E4lt voll. Wenn der Datentr\u00E4ger voll ist, soll man Speicherplatz auf dem Datentr\u00E4ger freigeben entweder durch dazuf\u00FCgen von Speicherplatz, oder durch erweiteren von Dateien, die nicht mit Derby zusammenhangen. Es ist auch m\u00F6glich, dass das Dateisystem und/oder den Datentr\u00E4ger worauf den Transaktionwiederherstellungslog sich aufh\u00E4lt, schreibgesch\u00FCtzt ist. Der Fehler kann auch auftreten, wenn der Datentr\u00E4ger oder das Dateisystem fehlgeschlagen ist. 

# Arguments:
#
#    {0} = transactionID
#
XSLA5.D=Logdaten-Stream f\u00FCr das Zur\u00FCcksetzen der Transaktion {0} kann nicht gelesen werden.

XSLA6.D=Die Datenbank kann nicht wiederhergestellt werden.

# Arguments:
#
#    {0} = operation
#
XSLA7.D=Vorgang {0} im Log kann nicht wiederholt werden.

# Arguments:
#
#    {0} = transactionID
#    {1} = undoableOperation
#    {2} = compensationOperation
#
XSLA8.D=Transaktion {0} kann nicht zur\u00FCckgesetzt werden. Es wird versucht, den Vorgang {1} durch {2} zu kompensieren.

XSLAA.D=Der Speicher wurde von einer fr\u00FCheren Ausnahme zum Herunterfahren vorgemerkt.

# Arguments:
#
#    {0} = logfileName
#
XSLAB.D=Logdatei {0} nicht gefunden. Vergewissern Sie sich, dass die Eigenschaft "logDevice" ordnungsgem\u00E4\u00DF und mit dem richtigen Pfadtrennzeichen f\u00FCr Ihre Plattform angegeben ist.

# Arguments:
#
#    {0} = directoryPath
#
XSLAC.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Sie wurde m\u00F6glicherweise mit einer neueren Version erstellt oder erweitert.

# Arguments:
#
#    {0} = length
#    {1} = length
#    {2} = logInstant
#    {3} = logfileName
#
XSLAD.D=Logdatensatz bei Adresse {2} in Logdatei {3} ist besch\u00E4digt. Erwartete Logdatensatzl\u00E4nge: {0}; tats\u00E4chliche L\u00E4nge: {1}.

# Arguments:
#
#    {0} = fileName
#
XSLAE.D=Kontrolldatei in {0} kann nicht geschrieben oder aktualisiert werden.

XSLAF.D=Eine schreibgesch\u00FCtzte Datenbank wurde mit benutzten Datenpuffern erstellt.

XSLAH.D=Sie aktualisieren eine schreibgesch\u00FCtzte Datenbank.

XSLAI.D=Der Checkpoint-Logdatensatz kann nicht protokolliert werden.

XSLAJ.D=Das Logging-System wird aufgrund eines fr\u00FCheren Fehlers heruntergefahren und l\u00E4sst weitere Vorg\u00E4nge erst wieder zu, wenn Sie das System heruntergefahren haben und wieder neu starten.

# Arguments:
#
#    {0} = number
#
XSLAK.D=Datenbank hat die h\u00F6chste Logdateinummer {0} \u00FCberschritten.

# Arguments:
#
#    {0} = logfileName
#    {1} = position
#    {2} = size
#    {3} = size
#
XSLAL.D=Logdatensatzgr\u00F6\u00DFe {2} \u00FCberschreitet die maximal zul\u00E4ssige Gr\u00F6\u00DFe der Logdatei von {3}. In Logdatei {0} wurde bei Position {1} ein Fehler festgestellt.

# Arguments:
#
#    {0} = exceptionDetails
#    {1} = directoryPath
#
XSLAM.D=Das Format der Datenbank in {1} kann aufgrund einer IOException nicht gepr\u00FCft werden: {0}

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAN.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Die Datenbank wurde mit der Version {1} erstellt oder erweitert.

# Arguments:
#
#    {0} = detailedMessage
#
XSLAO.D=Wiederherstellung war aufgrund des unerwarteten Problems nicht erfolgreich: {0}.

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAP.D=Datenbank in {0} hat die Version {1}. F\u00FCr Betadatenbanken ist kein Upgrade m\u00F6glich.

# Arguments:
#
#    {0} = directoryName
#
XSLAQ.D=Im Verzeichnis {0} kann keine Logdatei erstellt werden.

# Arguments:
#
#    {0} = logfileName
#    {1} = logFileName
#
XSLAR.D=Bei der Wiederherstellung konnte die Logdatei ''{0}'' nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00FCgbar ist und dass die notwendigen Berechtigungen vorliegen. 

# Arguments:
#
#    {0} = directoryName
#
XSLAS.D=Bei der Wiederherstellung wurde das Logverzeichnis {0} nicht im Backup gefunden. Vergewissern Sie sich, dass es sich um das richtige Backup handelt und dieses nicht besch\u00E4digt ist.

# Arguments:
#
#    {0} = directoryName
#
XSLAT.D=Das Logverzeichnis ''{0}'' ist vorhanden, geh\u00F6rt m\u00F6glicherweise jedoch zu einer anderen Datenbank. \u00DCberpr\u00FCfen Sie, ob die f\u00FCr das Attribut logDevice angegebene Position stimmt.

# Arguments:
#
#    {0} = logOperation
#
XSLB1.S=Logvorgang {0} hat beim Schreiben ihrer Daten in den Logdaten-Stream einen Fehler festgestellt. Die Ursache kann ein falscher Logvorgang oder die Ersch\u00F6pfung der Kapazit\u00E4t des internen Logpuffers durch einen zu umfangreichen Logvorgang sein.

# Arguments:
#
#    {0} = logOperation
#
XSLB2.S=Logvorgang {0} protokolliert zu viele Daten und f\u00FCllt dadurch den internen Logpuffer.

# Arguments:
#
#    {0} = logInstant
#    {1} = truncationPoint
#    {2} = logInstant
#    {3} = logInstant
#
XSLB5.S=Nicht zul\u00E4ssiger truncationLWM-Zeitpunkt {1} f\u00FCr Truncation-Punkt {0}. Der g\u00FCltige Bereich liegt zwischen {2} und {3}.

XSLB6.S=Es wurde versucht, einen Logdatensatz mit der L\u00E4nge 0 oder -ve zu protokollieren.

# Arguments:
#
#    {0} = logInstant
#    {1} = logInstant
#
XSLB8.S=Es wurde versucht, einen Scan auf {0} zur\u00FCckzusetzen. Dieser Wert liegt au\u00DFerhalb der Begrenzung {1}.

XSLB9.S=Es k\u00F6nnen keine weiteren \u00C4nderungen ausgegeben werden. Die Log-Factory wurde gestoppt.

XSRS0.S=Die Datenbank kann nicht eingefroren werden, da sie bereits eingefroren ist.

# Arguments:
#
#    {0} = directoryPath
#
XSRS1.S=Die Datenbank kann nicht in {0} gesichert werden, da es sich nicht um ein Verzeichnis handelt.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XSRS4.S=Fehler beim Umbenennen der Datei von {0} in {1} w\u00E4hrend des Backups.

# Arguments:
#
#    {0} = path
#    {1} = path
#
XSRS5.S=Fehler beim Kopieren der Datei von {0} nach {1} w\u00E4hrend des Backups.

# Arguments:
#
#    {0} = directoryName
#
XSRS6.S=Backupverzeichnis {0} kann nicht erstellt werden.

XSRS7.S=Backup hat eine unerwartete Ausnahme abgefangen.

XSRS8.S=Log-Device kann nur beim Erstellen der Datenbank definiert und w\u00E4hrend der Verarbeitung nicht ge\u00E4ndert werden.

# Arguments:
#
#    {0} = recordName
#
XSRS9.S=Datensatz {0} nicht mehr vorhanden.

XSRSA.S=Die Datenbank kann nicht gesichert werden, solange nicht protokollierte Vorg\u00E4nge noch nicht festgeschrieben sind. Schreiben Sie die Transaktionen mit den Vorg\u00E4ngen fest, die das Backup blockieren. 

XSRSB.S=F\u00FCr eine Transaktion mit nicht protokollierten und nicht festgeschriebenen Vorg\u00E4ngen kann kein Backup ausgef\u00FChrt werden.

# Arguments:
#
#    {0} = directoryLocation
#
XSRSC.S=Die Datenbank kann nicht in {0} gesichert werden, da es sich nicht um ein Datenbankverzeichnis handelt.

XSTA2.S=Es wurde versucht, eine Transaktion zu aktivieren, obwohl bereits eine andere Transaktion aktiv war.

XSTB0.M=Beim Abbrechen der Transaktion wurde eine Ausnahme ausgel\u00F6st.

XSTB2.M=Die Transaktions\u00E4nderungen k\u00F6nnen nicht protokolliert werden. M\u00F6glicherweise versuchen Sie, in eine schreibgesch\u00FCtzte Datenbank zu schreiben.

XSTB3.M=Die Transaktion kann nicht abgebrochen werden, weil der Logmanager - wahrscheinlich aufgrund eines fr\u00FCheren Fehlers - nicht angegeben ist.

XSTB5.M=Beim Erstellen einer Datenbank mit deaktiviertem Logging wurde ein unerwarteter Fehler festgestellt.

XSTB6.M=Eine Transaktionstabelle kann nicht durch eine andere ersetzt werden, solange eine der beiden Tabellen verwendet wird.

XXXXX.C.6=Normale Beendigung der Datenbanksession.

02000=F\u00FCr FETCH, UPDATE oder DELETE wurde keine Zeile gefunden oder das Ergebnis einer Abfrage ist eine leere Tabelle.

# Arguments:
#
#    {0} = operatorName
#    {1} = detailedError
#
10000=Bei der Auswertung des XML-Abfrageausdrucks f\u00FCr den Operator {0} wurde ein Fehler festgestellt: {1}

42Z00.U=Java-Methodenaufruf oder Feldreferenz

42Z01.U=Nicht typisiert

# Arguments:
#
#    {0} = javaClassName
#
42Z10=Die an einen benutzerdefinierten Typ gebundene Java-Klasse darf nicht intern von Derby verwendet werden: ''{0}''.

# Arguments:
#
#    {0} = dataType
#
42Z12.U=Interner Fehler: Ung\u00FCltiger Versuch, auf {0} als Stream zuzugreifen

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z30.U=Zeit f\u00FCr dieses ResultSet =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z31.U=Zeit f\u00FCr dieses ResultSet und folgende =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z32.U=Aufgliederung Gesamtzeit:

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z33.U=Konstruktorzeit (Millisekunden) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z34.U=Zeit f\u00FCr open (Millisekunden) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z35.U=Zeit f\u00FCr next (Millisekunden) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z36.U=Zeit f\u00FCr close (Millisekunden) =

# Translators: This is part of query plan printout; the string is complete as is.
# This is a start or stop position for a scan.
#
42Z37.U=Kein

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z38.U=Es ist keine Positionierungsinformation verf\u00FCgbar, weil dieses ResultSet nie ge\u00F6ffnet wurde.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = exceptionMessage
#
42Z39.U=Unerwartete Ausnahme {0} beim Anfordern des Positionierers.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = searchOperator
#    {1} = number
#
42Z40.U={0} f\u00FCr die ersten {1} Spalten.

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z41.U=Semantik mit Nullsortierung in den folgenden Spalten:

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z42.U=Spalten-ID

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z43.U=Operator

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z44.U=Nullsortierung

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z45.U=Unbekannter R\u00FCckgabewert

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z46.U=Vergleichsergebnis negieren

# Arguments:
#
#    {0} = className
#
42Z47.U=Das Abrufen des Abfrageplans als Zeichenfolge wird f\u00FCr {0} derzeit nicht unterst\u00FCtzt

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = term
#    {1} = columnNumber
#
42Z48.U=ID f\u00FCr Spalte [{0}][{1}]

42Z54.U=Diese Ausnahme stoppt die Anweisung nach dem Parsing. Keine weitere Verarbeitung erforderlich.

42Z55.U=Ausf\u00FChrung wurde nach dem Parsing von dem Debugkennzeichen StopAfterParsing gestoppt.

42Z56.U=Ausf\u00FChrung wurde nach Binding von dem Debugkennzeichen StopAfterBinding gestoppt.

42Z57.U=Ausf\u00FChrung wurde nach der Optimierung von dem Debugkennzeichen StopAfterOptimizing gestoppt.

42Z58.U=Ausf\u00FChrung wurde nach der Generierung von dem Debugkennzeichen StopAfterGenerating gestoppt.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z80.U=serializable

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z81.U=read committed

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "exclusive lock".
#
42Z82.U=exclusive

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z83.U=instantaneous share

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z84.U=share

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z85.U=table

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z86.U=row

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z87.U=share table

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z88.U=share row

# Translators: This is part of query plan printout; the string is complete as is.
#
43X00.U=Zugeordnet zu

# Translators: This is part of query plan printout; the string is complete as is.
#
43X01.U=Nummer der ersten Unterabfrage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X02.U=ANY-ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X03.U=Anzahl \u00D6ffnungsvorg\u00E4nge

# Translators: This is part of query plan printout; the string is complete as is.
#
43X04.U=Angezeigte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X05.U=Quellergebnismenge

# Translators: This is part of query plan printout; the string is complete as is.
#
43X06.U=Nummer der letzten Unterabfrage

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X07.U=Vom Optimizer gesch\u00E4tzte Zeilenzahl: {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X08.U=Vom Optimizer gesch\u00E4tzte Kosten: {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X09.U=Sekunden

# Translators: This is part of query plan printout; the string is complete as is.
#
43X11.U=Knoten

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
43X12.U={0} ist derzeit nicht f\u00FCr {1} implementiert.

# Translators: This is part of query plan printout; the string is complete as is.
#
43X13.U=DELETE-ResultSet mit

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X14.U=Tabelle wird gesperrt

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X15.U=Zeile wird gesperrt

# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "deferred update".
#
43X16.U=verz\u00F6gert

# Translators: This is part of query plan printout; the string is complete as is.
#
43X17.U=Gel\u00F6schte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X18.U=Aktualisierte Indizes

43X19.U=L\u00F6schen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X20.U=ResultSet f\u00FCr spezifisches skalares Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43X21.U=Eingegebene Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X22.U=Spezifisches skalares Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X23.U=ResultSet des spezifischen Scans f\u00FCr {0} mit {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X26.U=ResultSet des spezifischen Scans f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X27.U=bei Isolationsebene {0} unter Verwendung einer Sperre des Typs {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X28.U=Scaninformationen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X29.U=Die spezifische Spalte hat die Nummer

# Translators: This is part of query plan printout; the string is complete as is.
#
43X30.U=Die spezifischen Spalten haben die Nummern

# Translators: This is part of query plan printout; the string is complete as is.
#
43X31.U=Gr\u00F6\u00DFe der Hash-Tabelle

# Translators: This is part of query plan printout; the string is complete as is.
#
43X32.U=Gefilterte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X33.U=Zeit f\u00FCr next in Millisekunden/Zeile

# Translators: This is part of query plan printout; the string is complete as is.
#
43X34.U=Anfangspunkt

# Translators: This is part of query plan printout; the string is complete as is.
#
43X35.U=Endpunkt

# Translators: This is part of query plan printout; the string is complete as is.
#
43X36.U=Scan-Qualifier

# Translators: This is part of query plan printout; the string is complete as is.
#
43X37.U=Next Qualifier

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X38.U=f\u00FCr {0} mit {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X39.U=Spezifischer Scan

# Translators: This is part of query plan printout; the string is complete as is.
#
43X40.U=Sortierungsinformationen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X41.U=ResultSet f\u00FCr gruppiertes Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43X42.U=Mit spezifischem Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43X43.U=In sortierter Reihenfolge

# Translators: This is part of query plan printout; the string is complete as is.
#
43X44.U=Gruppiertes Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43X45.U=Hash Join EXISTS

# Translators: This is part of query plan printout; the string is complete as is.
#
43X46.U=ResultSet f\u00FCr Hash Join EXISTS

# Translators: This is part of query plan printout; the string is complete as is.
#
43X47.U=Hash Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X48.U=Hash Join ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X49.U=Hash Left Outer Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X50.U=ResultSet f\u00FCr Hash Left Outer Join

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X51.U=ResultSet des Hash-Scans f\u00FCr {0} mit {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X52.U=Hash-Scan-ResultSet f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X53.U=Hash-Schl\u00FCssel ist die Spaltennummer

# Translators: This is part of query plan printout; the string is complete as is.
#
43X54.U=Hash-Schl\u00FCssel sind die Spaltennummern

# Translators: This is part of query plan printout; the string is complete as is.
#
43X55.U=Hash-Scan

# Translators: This is part of query plan printout; the string is complete as is.
#
43X56.U=Zugeordnete Unterabfragen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X57.U=ResultSet f\u00FCr Hash-Tabelle

# Translators: This is part of query plan printout; the string is complete as is.
#
43X58.U=Hash-Tabelle

# Translators: This is part of query plan printout; the string is complete as is.
# Shorthand for "all columns".
#
43X59.U=alle

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X60.U=ResultSet Indexzeile zu Basiszeile f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X61.U=Spalten, auf die aus Heap zugegriffen wurde

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X62.U=f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X63.U=Indexzeile zu Basiszeile

# Translators: This is part of query plan printout; the string is complete as is.
#
43X64.U=INSERT-Modus: Bulk-Einf\u00FCgung

# Translators: This is part of query plan printout; the string is complete as is.
#
43X65.U=INSERT-Modus: Normal (Bulk-Einf\u00FCgung ist nicht m\u00F6glich, da die Tabelle nicht leer ist)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X66.U=INSERT-Modus: Normal

# Translators: This is part of query plan printout; the string is complete as is.
#
43X67.U=INSERT-ResultSet mit

# Translators: This is part of query plan printout; the string is complete as is.
#
43X68.U=Eingef\u00FCgte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X69.U=Einf\u00FCgen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X70.U=Join

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X71.U=ResultSet des letzten Schl\u00FCsselindexscans f\u00FCr {0} mit Index {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X72.U=bei Isolationsebene {0} mit Sperre {1} wurde vom Optimizer ausgew\u00E4hlt

# Translators: This is part of query plan printout; the string is complete as is.
#
43X73.U=Table Scan

# Translators: This is part of query plan printout; the string is complete as is.
#
43X74.U=Index Scan

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X75.U=f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X76.U=Materialized ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X77.U=Erstellungszeit f\u00FCr tempor\u00E4res Konglomerat (Millisekunden)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X78.U=Abrufzeit f\u00FCr tempor\u00E4res Konglomerat (Millisekunden)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X79.U=Angezeigte Zeilen von links

# Translators: This is part of query plan printout; the string is complete as is.
#
43X80.U=Angezeigt Zeilen von rechts

# Translators: This is part of query plan printout; the string is complete as is.
#
43X81.U=Zur\u00FCckgegebene Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X82.U=Ergebnismenge Left Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X83.U=Ergebnismenge Right Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X84.U=Nested Loop Exists Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X85.U=Nested Loop Exists Join ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X86.U=Nested Loop Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X87.U=Nested Loop Join ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X88.U=Zur\u00FCckgegebene leere rechte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
43X89.U=Nested Loop Left Outer Join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X90.U=Nested Loop Left Outer Join ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X91.U=ResultSet normalisieren

# Translators: This is part of query plan printout; the string is complete as is.
#
43X92.U=Einzelwert-ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X93.U=ResultSet f\u00FCr eingeschr\u00E4nkte Projektion

# Translators: This is part of query plan printout; the string is complete as is.
#
43X94.U=Einschr\u00E4nkung

# Translators: This is part of query plan printout; the string is complete as is.
#
43X95.U=Projektion

# Translators: This is part of query plan printout; the string is complete as is.
#
43X96.U=Einschr\u00E4nkungszeit (Millisekunden)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X97.U=Projektionszeit (Millisekunden)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X98.U=Eingeschr\u00E4nkte Projektion

# Translators: This is part of query plan printout; the string is complete as is.
#
43X99.U=Zeilen-ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9A.U=Zeilenanzahl-ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9B.U=Zeilenanzahl

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9C.U=Fenster-ResultSet: 

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y00.U=ResultSet f\u00FCr skalares Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y01.U=Optimierung f\u00FCr Indexschl\u00FCssel

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y02.U=Skalares Aggregat

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y03.U=Scroll-insensitives ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y04.U=Anzahl Lesevorg\u00E4nge in der Hash-Tabelle

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y05.U=Anzahl Schreibvorg\u00E4nge in der Hash-Tabelle

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y06.U=ResultSet f\u00FCr Sortierung

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y07.U=Duplikate eliminieren

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y08.U=Sortieren

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43Y09.U=Index Scan ResultSet f\u00FCr {0} mit {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43Y10.U=Table Scan ResultSet f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y11.U=Tats\u00E4chlich verwendete Sperre: Sperre auf Tabellenebene.

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y12.U=Abrufgr\u00F6\u00DFe

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y13.U=Qualifier

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y14.U=UNION ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableOrRow
#
43Y16.U=ResultSet mit Sperre f\u00FCr {0} aktualisieren

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y17.U=Aktualisierte Zeilen

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = javaClassName
#
43Y19.U=VTI-ResultSet f\u00FCr {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y20.U=VTI

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y21.U=Materialized Subqueries

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y22.U=Anweisungsname

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y23.U=Anweisungstext

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y24.U=Parsing-Zeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y25.U=Binding-Zeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y26.U=Optimierungszeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y27.U=Generierungszeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y28.U=Kompilierzeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y29.U=Ausf\u00FChrungszeit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y30.U=Zeitstempel Kompilierungsbeginn

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y31.U=Zeitstempel Kompilierungsende

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y32.U=Zeitstempel Ausf\u00FChrungsbeginn

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y33.U=Zeitstempel Ausf\u00FChrungsende

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y44.U=Text des Plans f\u00FCr die Anweisungsausf\u00FChrung

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43Y45.U=Laufzeit 100 %, {0} Sekunden

43Y46.U=VTI-ResultSet einf\u00FCgen

43Y47.U=VTI-ResultSet l\u00F6schen

43Y49.U=VTI einf\u00FCgen

43Y50.U=VTI l\u00F6schen

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y51.U=ResultSet f\u00FCr kaskadierendes L\u00F6schen

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y52.U=ResultSet f\u00FCr kaskadierendes L\u00F6schen mit

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y53.U=Referenzielle Aktionen f\u00FCr abh\u00E4ngige Tabellen

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y54.U=Referenzielle Aktion f\u00FCr abh\u00E4ngige Tabelle beginnen

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y55.U=Referenzielle Aktion f\u00FCr abh\u00E4ngige Tabelle beenden

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = userSuppliedOptimizerOverrides
#
43Y56.U=Benutzer hat f\u00FCr {0} folgende vorrangigen Optimizer-Werte angegeben: {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = userSuppliedOptimizerOverrides
#
43Y57.U=Benutzer hat f\u00FCr Join folgende vorrangigen Optimizer-Werte angegeben: {0}

44X00.U=Name des SQL-Typs

# Arguments:
#
#    {0} = url
#
46001=Ausnahme beim Zugriff auf die JAR-Datei mit URL ''{0}''.

46J01=Die Signatur der Java-Methode hat ein ung\u00FCltiges Format.

# Arguments:
#
#    {0} = number
#    {1} = number
#
46J02=Die Signatur der Java-Methode enth\u00E4lt eine falsche Anzahl von Parametern ({0}). Erwartet wurden {1} Parameter.

# Arguments:
#
#    {0} = prefix
#
54002=Eine mit ''{0}'' beginnende Zeichenfolgenkonstante ist zu lang.

54004=SELECT-Anweisung enth\u00E4lt zu viele Elemente in GROUP BY, ORDER BY oder SELECT-Liste.

# Arguments:
#
#    {0} = operator
#    {1} = number
#
54006=Die aus Vorgang {0} resultierende L\u00E4nge ist gr\u00F6\u00DFer als {1}.

54008=Die Anweisung CREATE INDEX gibt zu viele Spalten an. (Das Maximum liegt bei 16.)

# Arguments:
#
#    {0} = number
#    {1} = tableOrViewName
#    {2} = number
#
54011=F\u00FCr die Tabelle oder View {1} wurden zu viele Spalten ({0}) angegeben. Die Grenze liegt bei {2}.

# Arguments:
#
#    {0} = number
#    {1} = procedureName
#    {2} = number
#
54023=Die maximale Anzahl von Parametern f\u00FCr eine Prozedur wurde \u00FCberschritten. Die Begrenzung liegt bei {0} und die Anzahl der Parameter f\u00FCr die Prozedur {1} betr\u00E4gt {2}.

54038=Maximale Verschachtelungstiefe f\u00FCr Trigger wurde \u00FCberschritten.

BIN01=(Bin\u00E4rer Datenwert wird nicht angezeigt)

# Arguments:
#
#    {0} = columnName
#
S0022=Spalte ''{0}'' wurde nicht gefunden.

# Arguments:
#
#    {0} = errorMessage
#    {1} = exceptionClassName
#
XJ001.U=Java-Ausnahme: ''{1}: {0}''.

# Arguments:
#
#    {0} = oldVersion
#    {1} = newVersion
#
XJ050.U=F\u00FCr die Datenbankversion {0} ist ein Upgrade erforderlich. Setzen Sie f\u00FCr die JDBC-Verbindungs-URL das Attribut "upgrade\\=true", um ein Upgrade auf Version {1} zu erm\u00F6glichen.

XJ082.U=BLOB-/CLOB-Werte sind als Methodenparameter oder Empf\u00E4nger nicht zul\u00E4ssig.

# Arguments:
#
#    {0} = operation
#
XJ083.U=''{0}'' ist nicht zul\u00E4ssig, weil das ResultSet nicht aktualisierbar ist. 

# Arguments:
#
#    {0} = methodName
#
XJ084.U=Spalte entspricht keiner Spalte in der Basistabelle. ''{0}'' kann nicht f\u00FCr diese Spalte abgesetzt werden.

# Arguments:
#
#    {0} = xmlPackageName
#
XML00=Die API oder Implementierungsklassen f\u00FCr ''{0}'' wurden nicht gefunden. XML-Vorg\u00E4nge sind nur zul\u00E4ssig, wenn diese Klassen im Classpath vorhanden sind.

# Arguments:
#
#    {0} = errorMessage
#
XML01=Bei der XML-Verarbeitung wurde ein unerwarteter Fehler festgestellt: {0} 

XN002.U=SECTKN wurde nicht zur\u00FCckgegeben.

XSAJ0.U=Scantyp

XSAJ1.U=Anzahl besuchte Seiten

XSAJ2.U=Anzahl besuchte Zeilen

XSAJ3.U=Anzahl gel\u00F6schter, besuchter Zeilen

XSAJ4.U=Anzahl qualifizierte Zeilen

XSAJ5.U=Anzahl abgerufene Spalten

XSAJ6.U=Bits abgerufene Spalten

XSAJ7.U=Baumstrukturtiefe

XSAJ8.U=Sortiertyp

XSAJA.U=Anzahl eingegebene Zeilen

XSAJB.U=Anzahl ausgegebene Zeilen

XSAJC.U=Anzahl MergeSort-Ausf\u00FChrungen

XSAJD.U=Gr\u00F6\u00DFe von MergeSort-Ausf\u00FChrungen

XSAJE.U=Alle

# This is a type of conglomerate.
#
XSAJF.U=B-Baumstruktur

# This is a type of conglomerate.
#
XSAJG.U=Heap

XSAJH.U=Sortierung

# This is a type of sort.
#
XSAJI.U=externe

# This is a type of sort.
#
XSAJJ.U=interne

A001=Schwerwiegender Fehler: Kein Authentifizierungsservice f\u00FCr das System.

A002=Schwerwiegender Fehler: Kein Authentifizierungsservice f\u00FCr die Datenbank.

# Arguments:
#
#    {0} = propertyName
#
A011=Warnung: In Eigenschaft {0} ist kein LDAP-Server-/Hostname angegeben. Es wird localhost:389 verwendet.

A020=Ung\u00FCltige Authentifizierung.

# Arguments:
#
#    {0} = className
#    {1} = fileName
#    {2} = errorMessage
#
C000=Die Klasse {0} wurde in die Datei {1} geschrieben. Stellen Sie Unterst\u00FCtzung f\u00FCr die Datei und die folgende Ausnahme bereit: {2}

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C001=Die Klasse {0} enth\u00E4lt in der JAR-Datei {1} einen unbekannten Zertifikattyp. Es wurde ein X509-Zertifikat erwartet.

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = errorMessage
#
C002=Beim Zugriff auf die Klasse {0} in der JAR-Datei {1} wurde die folgende Sicherheitsausnahme ausgel\u00F6st: {2}

# Arguments:
#
#    {0} = jarName
#    {1} = errorMessage
#
C003=Ausnahme beim Laden der Datenbank-JAR-Datei {0} - {1}

# Arguments:
#
#    {0} = className
#
C004=Veralteter Class Loader f\u00FCr Klasse {0}

# Arguments:
#
#    {0} = classpath
#
C005=Datenbank-Class Loader wurde gestartet - derby.database.classpath=''{0}''

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C006={0} wurde aus der Datenbank-JAR-Datei {1} geladen.

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = detailedError
#
C007=Beim Laden der Klasse {0} aus der JAR-Datei {1} eingetretene Ausnahme: {2}

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D000=:\nBooten von Derby (Version {0}) Instanz {1}\nf\u00FCr Datenbankverzeichnis {2} In READ ONLY-Modus mit Class Loader {3}\nGeladen aus {4}

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D001=:\nBooten von Derby-Version {0}: Instanz {1}\nf\u00FCr Datenbankverzeichnis {2} mit Class Loader {3}\nGeladen aus {4}

# Arguments:
#
#    {0} = id
#    {1} = dbDirectory
#    {2} = classloader
#
D002=:\nInstanz {0} im Datenbankverzeichnis {1} mit Class Loader {2} wird heruntergefahren

# Arguments:
#
#    {0} = databaseName
#    {1} = filePath
#
D004=Backup f\u00FCr Datenbank in {0} wurde unter {1} gestartet.

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D005=Altes Backup wurde von {0} nach {1} verschoben.

# Arguments:
#
#    {0} = filePath
#
D006=Backup des Datensegments in {0} ist abgeschlossen. 

D007=F\u00FCr die Datenbank wurde service.properties editiert, um das standardm\u00E4\u00DFige Log-Device verwenden zu k\u00F6nnen.

# Arguments:
#
#    {0} = errorMessage
#
D008=Fehler beim Editieren von service.properties f\u00FCr die Datenbank. Backup abgebrochen: {0}

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D009=Das Logverzeichnis wurde von {0} nach {1} kopiert.

D010=Backup wurde wegen eines Fehlers abgebrochen.

# Arguments:
#
#    {0} = filePath
#
D011=Altes Backup in {0} entfernt.

# Arguments:
#
#    {0} = backupInstant
#
D012=Backup abgeschlossen. Logadresse: {0} \n

# Arguments:
#
#    {0} = durabilityProperty
#    {1} = noSync
#
D013=Warnung: Die Datenbank wird mit {0}={1} gebootet. Bei Verwendung dieses Modus kann die Datenbank m\u00F6glicherweise nicht wiederhergestellt werden. Festgeschriebene Transaktionen k\u00F6nnen verloren gehen. Es ist m\u00F6glich, dass die Datenbank einen inkonsistenten Status hat. Verwenden Sie diesen Modus nur, wenn Sie die genannten Folgen bewusst in Kauf nehmen m\u00F6chten. \n

D015=Weiterlesen nicht m\u00F6glich, da der Wert von einer anderen Transaktion ge\u00E4ndert wurde.

I024=Datenbank nicht verf\u00FCgbar.

I025=JDBC-Treiber nicht verf\u00FCgbar.

# Arguments:
#
#    {0} = errorMessage
#
I026=JDBC-Treiberregistrierung mit java.sql.DriverManager nicht erfolgreich: {0}

I027=Keine Markierung festgelegt oder Mark Read-Ahead-Limit \u00FCberschritten.

I028=Clientseitiger Stream-Lesefehler beim \u00DCbertragen von Benutzerdaten auf den Server.

# Arguments:
#
#    {0} = expectedCount
#    {1} = gotCount
#
I029=Dateiende vorzeitig erreicht; {0} erwartet, {1} festgestellt.

# Arguments:
#
#    {0} = timestamp
#
J003={0}: Derby-Engine wird heruntergefahren

J004=Datenbankidentit\u00E4t

J005=Derby herunterfahren

J006=Registrierung von AutoloadedDriver aufheben

J007=Datenbank erstellen

J008=Keine Details

J010=Datenbank auf Datentr\u00E4ger verschl\u00FCsseln

J013=Datenbank upgraden

J016=Verschl\u00FCsselungsserviceprovider

J017=Verschl\u00FCsselungsalgorithmus

J018=L\u00E4nge des Verschl\u00FCsselungsschl\u00FCssels

J019=Externer Verschl\u00FCsselungsschl\u00FCssel

J020=Geheimer Verschl\u00FCsselungsschl\u00FCssel

J021=Gebiet f\u00FCr die Datenbank

J022=Benutzername

J023=Benutzerkennwort

J025=Logverzeichnispfad

J028=Backuppfad f\u00FCr Rollforward Recovery

J029=Backuppfad f\u00FCr die Erstellung der Datenbank aus Backup

J030=Backuppfad f\u00FCr die Wiederherstellung der Datenbank aus Backup

J031=Sortierung f\u00FCr Zeichendatentypen

# Arguments:
#
#    {0} = className
#
J100=Die Netzserverklasse {0} wurde nicht gefunden. Ihr Classpath muss derbynet.jar enthalten.

# Arguments:
#
#    {0} = className
#    {1} = errorMessage
#
J101=Die Netzserverklasse {0} konnte nicht geladen werden. {1}. \u00DCberpr\u00FCfen Sie die Integrit\u00E4t Ihrer Datei derbynet.jar.

# Arguments:
#
#    {0} = errorMessage
#
J102=Beim Starten des Netzwerkservers wurde eine Ausnahme ausgel\u00F6st. {0}

# Arguments:
#
#    {0} = errorMessage
#
J103=Beim Herunterfahren des Netzwerkservers wurde eine Ausnahme ausgel\u00F6st. {0}

J104=Das Objekt ist bereits geschlossen.

J105=Gesamtstellenzahl \u00FCberschreitet 31 Stellen.

J107=Fehler bei Batchelement

# Arguments:
#
#    {0} = propertyName
#
J108=Security Manager erlaubt nicht den Zugriff auf Systemeigenschaft {0}.

# Arguments:
#
#    {0} = errorMessage
#
J109=Es wurde eine inkorrekte TCP/IP-Clientkonfiguration festgestellt. Die IP-Adresse Ihres lokalen Hosts kann nicht bestimmt werden: ''{0}''. Stellen Sie sicher, dass die IP-Adresse Ihres Clientrechners ordnungsgem\u00E4\u00DF konfiguriert ist.

J110=Sicherheitsverfahren wird nicht unterst\u00FCtzt

J111=Kennwort fehlt

J112=Benutzer-ID fehlt

J113=Benutzer-ID oder Kennwort ung\u00FCltig

J114=Benutzer-ID entzogen

J115=Neues Kennwort ung\u00FCltig

J116=Fehler bei lokalem Sicherheitsservice bei einem Vorgang, der nicht wiederholt werden kann.

J117=Im ACCSEC-Befehl fehlt das erforderliche Sicherheitstoken (SECTKN) oder das Token ist ung\u00FCltig

J118=Kennwort abgelaufen

J120=Nicht angegebener Verbindungsfehler

J121=Der Benutzer ist nicht berechtigt, auf die Datenbank zuzugreifen.

J122=Vor dem Befehl, mit dem der Zugriff auf die Datenbank angefordert wird (ACCRDB), wurde ein Befehl abgesetzt, der Services der Datenbank anfordert.

J123=Der angeforderte Befehl hat eine implementierungsspezifische, nicht in der Spezifikation enthaltene Bedingung festgestellt, f\u00FCr die keine Meldung implementiert ist (weitere Informationen finden Sie ggf. in der Datei derby.log auf dem Server).

J124=Der Befehl f\u00FCr den Zugriff auf die relationale Datenbank (ACCRDB) kann nicht abgesetzt werden, weil der Zugriff auf die Datenbank bereits erfolgte.

J125=Es wurde ein Fehler durch einen abweichenden Datendeskriptor festgestellt.

# Arguments:
#
#    {0} = hexNumber
#
J126=Es wurde ein Dialogprotokollfehler festgestellt. Grund: 0x{0}.

J128=Der Cursor ist nicht offen.

J129=F\u00FCr eine bereits ge\u00F6ffnete Abfrage wurde ein Befehl "Open Query" abgesetzt.

J130=Es wurde ein Protokollfehler (Ung\u00FCltige FDOCA-Beschreibung) festgestellt.

# Arguments:
#
#    {0} = hexNumber
#
J131=Ein Protokollfehler (Daten-Stream-Syntaxfehler) wurde ermittelt. Ursache: 0x{0}. M\u00F6glicherweise ist dies ein Versuch, eine Nur-Textverbindung zu einem SSL-f\u00E4higen Server herzustellen.

J132=Benutzername f\u00FCr die Verbindung

J133=Kennwort des Benutzers f\u00FCr die Verbindung

# Arguments:
#
#    {0} = maxStatements
#
J134=Negative Werte sind f\u00FCr die Eigenschaft "maxStatements" nicht zul\u00E4ssig: {0}

# Arguments:
#
#    {0} = transactionXid
#
J135=Bei der XA-Transaktion ist ein Timeout aufgetreten, und sie wird zur\u00FCckgesetzt. Die Transaktions-XID lautet {0}.

# Arguments:
#
#    {0} = transactionXid
#
J136=Mit der zu schlie\u00DFenden Verbindung ist eine XA-Transaktion verkn\u00FCpft. Die Transaktion wird zur\u00FCckgesetzt. Die Transaktions-XID lautet {0}.

L001=------------  Anfang Fehlermeldung -------------\n

L002=------------  Ende Fehlermeldung -------------\n

L003=\n------------  Anfang Herunterfahren von Fehler-Stack -------------\n

L004=\n------------  Ende Herunterfahren von Fehler-Stack -------------\n

L005=\n------------  Anfang Fehler-Stack -------------\n

L006=\n------------  Ende Fehler-Stack -------------\n

L007=Warnung: Die Logdatei wurde nicht gefunden. Es wird ein neues Log erstellt. M\u00F6glicherweise ist die Datenbank inkonsistent.

# Arguments:
#
#    {0} = fileName
#
L008=Die inkompatible alte Logdatei {0} wird gel\u00F6scht

# Arguments:
#
#    {0} = fileName
#
L009=Die alte Logdatei {0} wird gel\u00F6scht

# Arguments:
#
#    {0} = fileName
#    {1} = position
#    {2} = position
#
L010=In der Datei {0} wurde ein unvollst\u00E4ndiger Logdatensatz gefunden. Der Inhalt der Logdatei wird von Position {1} bis zum Dateiende bei {2} gel\u00F6scht.

L011=Checkpoint Daemon hat eine Standardausnahme abgefangen.

# Arguments:
#
#    {0} = transactionID
#
L012=Logdatensatz ist nicht als erster Satz der Transaktion markiert. Transaktion nicht in Transaktionstabelle gefunden. {0}

# Arguments:
#
#    {0} = transactionID
#
L013=Logdatensatz ist als erster Satz der Transaktion markiert. Transaktion ist bereits in Transaktionstabelle vorhanden. {0}

L014=Falsche Anfangsadresse

# Arguments:
#
#    {0} = fileName
#
L015=Es ist bereits eine neue Logdatei vorhanden, die nicht gel\u00F6scht werden kann. {0}

# Arguments:
#
#    {0} = fileName
#
L016=Neue Logdatei {0} kann nicht erstellt werden.

# Arguments:
#
#    {0} = fileName
#    {1} = errorMessage
#
L017=Neue Logdatei {0} kann nicht erstellt werden aufgrund von {1}.

# Arguments:
#
#    {0} = fileName
#
L018=System hat m\u00F6glicherweise einen inkonsistenten Status. Fehlende Datei: {0}

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#
L020=Warnung: Die Datenbank wurde mindestens einmal mit {0}={1} gebootet. Durch die Verwendung dieses Modus kann die Datenbank m\u00F6glicherweise nicht wiederhergestellt werden. Festgeschriebene Transaktionen k\u00F6nnen verloren gegangen sein. Es ist m\u00F6glich, dass die Datenbank einen inkonsistenten Status hat. Dies kann zu unerwarteten Fehlern f\u00FChren.\n

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#    {2} = testModeProperty
#    {3} = testMode
#
L021=Warnung: Die Datenbank wurde zu einem fr\u00FCheren Zeitpunkt oder aktuell mit {0} = {1} gebootet. Bei Verwendung des Modus {0}={1} ist die Wiederherstellbarkeit nicht gew\u00E4hrleistet. Wahrscheinlich ist das die Ursache f\u00FCr diesen Boot-Fehler.\n

L022=Warnung: Aufgrund von Berechtigungsproblemen beim Zugriff auf die Logdateien wird die Datenbank schreibgesch\u00FCtzt. \n               

# Arguments:
#
#    {0} = timestamp
#
R001=----  Anfang Replikationsfehlermeldung ({0}) ----

R002=--------------------  Ende Replikationsfehlermeldung ---------------------

# Arguments:
#
#    {0} = dbname
#
R003=Replication Slave-Rolle gestartet f\u00FCr Datenbank ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R004=Replication Slave-Rolle gestoppt f\u00FCr Datenbank ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R005=Schwerwiegender Fehler bei Replication Slave f\u00FCr Datenbank ''{0}''. Replikation wird gestoppt.

# Arguments:
#
#    {0} = dbname
#
R006=Verbindung unterbrochen zum Replication Master von Datenbank ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R007=Replication Master-Rolle gestartet f\u00FCr Datenbank ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R008=Replication Master-Rolle gestoppt f\u00FCr Datenbank ''{0}''.

R009=Fehler beim Log-Shipping.

# Arguments:
#
#    {0} = dbname
#
R010=Replication Master versucht Wiederaufnahme der Verbindung mit Slave f\u00FCr Datenbank ''{0}''.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = port
#
R011=Replication Slave-Datenbank ''{0}'' horcht auf Verbindungen von Master auf ''{1}:{2}''.

R012=Replikationsverbindungs-Handle ist ung\u00FCltig.

# Arguments:
#
#    {0} = timestamp
#    {1} = message
#
R013=Replikationsmeldung ({0}): {1}

# Arguments:
#
#    {0} = dbname
#
R020=Failover erfolgreich ausgef\u00FChrt f\u00FCr Datenbank ''{0}''.

# Translators: Please translate the ALL CAPS words.
#
M001=\n# ********************************************************************\n# ***                Diese Datei darf nicht bearbeitet werden.                 ***\n# *** \u00C4nderungen an dieser Datei k\u00F6nnen zu Datenbesch\u00E4digungen f\u00FChren. ***\n# ********************************************************************

M002=Fehlende/besch\u00E4digte Serviceeigenschaften aus Backupdatei wiederhergestellt.

M003=Fr\u00FChere Backupdatei mit Serviceeigenschaften gel\u00F6scht.

# Arguments:
#
#    {0} = servicePropertiesBackupFile
#
M004=Fr\u00FChere Backupdatei mit Serviceeigenschaften konnte nicht gel\u00F6scht werden. L\u00F6schen Sie sie manuell: {0}

N001=Dieser Fehler wird durch folgenden Fehler verursacht.
