# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

###############################################################################
#
# Text for exceptions
#
###############################################################################

# Monitor
XBM01.D=Der Systemstart ist aufgrund einer Ausnahme gescheitert. Details enth\u00e4lt die n\u00e4chste Ausnahme. 
XBM02.D=Der Systemstart ist aufgrund fehlender Funktionalit\u00e4t f\u00fcr {0} gescheitert. Stellen Sie sicher, dass der Klassenpfad die richtige Derby-Software enth\u00e4lt.
XBM05.D=Der Systemstart ist aufgrund der fehlenden Produktversionsnummer f\u00fcr {0} gescheitert.
XBM06.D=Der Systemstart ist gescheitert. Auf eine verschl\u00fcsselte Datenbank kann nur mit dem richtigen Boot-Kennwort zugegriffen werden. 
XBM07.D=Der Systemstart ist gescheitert. Das Boot-Passwort muss eine Mindestl\u00e4nge von 8 Bytes haben.
XBM08.D=Die StorageFactory-Klasse {1} unter {0} konnte nicht instanziiert werden.

XBM0G.D=Die Verschl\u00fcsselungssteuerkomponente konnte nicht gestartet werden. Vergewissern Sie sich, dass Sie Java 2 ausf\u00fchren und einen Verschl\u00fcsselungsprovider wie JCE heruntergeladen und in den Klassenpfad aufgenommen haben. 
XBM0H.D=Das Verzeichnis {0} kann nicht erstellt werden.
XBM0I.D=Das Verzeichnis {0} kann nicht entfernt werden.
XBM0J.D=Das Verzeichnis {0} ist bereits vorhanden.
XBM0K.D=Unbekanntes Unterprotokoll f\u00fcr den Datenbanknamen {0}.
XBM0L.D=Die angegebene Authentifizierungsschemaklasse {0} implementiert nicht die Authentifizierungsschnittstelle {1}.
XBM0M.D=Fehler beim Erstellen einer Instanz der Authentifizierungsschemaklasse {0}.
XBM0N.D=Die JDBC-Treiberregistrierung mit java.sql.DriverManager ist gescheitert. Details enth\u00e4lt die n\u00e4chste Ausnahme. 
XBM0P.D=Der Serviceprovider ist schreibgesch\u00fctzt. Die Operation ist unzul\u00e4ssig. 
XBM0S.D=Die Datei ''{0}'' kann nicht in ''{1}'' umbenannt werden.
XBM0T.D=Mehrdeutiges Unterprotokoll f\u00fcr den Datenbanknamen {0}. 
XBM0U.S=F\u00fcr die ID {0} wurde keine Klasse registriert.
XBM0V.S=Beim Laden der f\u00fcr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00f6st.
XBM0W.S=Beim Erstellen einer Instanz der f\u00fcr die ID {0} registrierten Klasse {1} wurde eine Ausnahme ausgel\u00f6st.
XBM0X.D=Das angegebene Gebietsschema ''{0}'' ist ung\u00fcltig. Erwartet wurde ln[_CO[_variant]]\nln = zwei Kleinbuchstaben des ISO-639-Sprachencodes, CO = zwei Gro\u00dfbuchstaben der ISO-3166-Sprachencodes. Siehe java.util.Locale.
XBM0Y.D=Das Sicherungsdatenbankverzeichnis {0} wurde nicht gefunden. Vergewissern Sie sich, dass der angegebene Sicherungspfad stimmt.
XBM0Z.D=Die Datei ''{0}'' kann nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 
XBM0Q.D=Die Datei {0} wurde nicht gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XBM0R.D=Die Datei {0} kann nicht entfernt werden.


# Upgrade
XCW00.D=Ein Upgrade von ''{0}'' auf ''{1}'' wird nicht unterst\u00fctzt.

# Feature not supported


# COntext service
08000=Die Verbindung wurde von einer unbekannten Unterbrechung aufgehoben.
08000.S.1=Eine Verbindung mit einer aktiven Transaktion kann nicht geschlossen werden. Die Transaktion bleibt offen. Die Verbindung wurde nicht geschlossen.


#../java/com/ibm/db2j/protocol/BasicServices/LockManager/messages.properties
40001=Eine Sperre konnte aufgrund eines Deadlock nicht angefordert werden. Zyklus der Sperren und beantragten Sperren:\n{0}. Die ausgew\u00e4hlte Opfertransaktion ist XID : {1}.

40XL1=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden.
40XL2=Eine Sperre konnte innerhalb der vorgegebenen Zeit nicht angefordert werden. Speicherauszug der Sperrentabelle: {0}

# ClassManager
XBCM1.S=Beim Laden der generierten Klasse {0} wurde ein Java-Verbindungsfehler ausgel\u00f6st.
XBCM2.S=Es kann keine Instanz der generierten Klasse {0} erstellt werden.
XBCM3.S=Die Methode {1}() ist in der generierten Klasse {0} nicht vorhanden.
XBCM4.S=In der generierten Klasse {0} wurde die Formatbegrenzung f\u00fcr Java-Klassendateien {1} \u00fcberschritten.

# Properties

XCY00.S=Ung\u00fcltiger Wert f\u00fcr das Merkmal ''{0}''=''{1}''.
XCY02.S=Die angeforderte Merkmal\u00e4nderung wird nicht unterst\u00fctzt; ''{0}''=''{1}''.
XCY03.S=Das erforderliche Merkmal ''{0}'' wurde nicht definiert.
XCY04.S=Ung\u00fcltige Syntax f\u00fcr vorrangige Optimizer-Werte. G\u00fcltige Syntax: DERBY-PROPERTIES Merkmalname = Wert [, Merkmalname = Wert]*


# Cryptography
XBCX0.S=Ausnahme vom Verschl\u00fcsselungsprovider. Details enth\u00e4lt die n\u00e4chste Ausnahme.
XBCX1.S=Sie initialisieren das Verschl\u00fcsselungsverfahren mit einem ung\u00fcltigen Modus. Der Modus muss ENCRYPT oder DECRYPT sein.
XBCX2.S=Sie initialisieren das Verschl\u00fcsselungsverfahren mit einem zu kurzen Boot-Kennwort. Das Kennwort muss aus mindestens {0} Zeichen bestehen. 
XBCX5.S=Das Boot-Kennwort kann nicht in eine Nullzeichenfolge ge\u00e4ndert werden.
XBCX6.S=Das Boot-Kennwort kann nicht in einen serialisierbaren Typ, der keine Zeichenfolge ist, ge\u00e4ndert werden.
XBCX7.S=Falsches Format f\u00fcr das \u00c4ndern des Boot-Kennworts. G\u00fcltiges Format: altes_Boot-Kennwort, neues_Boot-Kennwort.
XBCX8.S=Das Boot-Kennwort f\u00fcr eine nicht verschl\u00fcsselte Datenbank kann nicht ge\u00e4ndert werden.
XBCX9.S=Das Boot-Kennwort f\u00fcr eine schreibgesch\u00fctzte Datenbank kann nicht ge\u00e4ndert werden. 
XBCXA.S=Falsches Boot-Kennwort.
XBCXB.S=Die Verschl\u00fcsselungsauff\u00fcllung ''{0}'' ist fehlerhaft oder es wurde keine Auff\u00fcllung angegeben. Es muss ''Keine Auff\u00fcllung'' verwendet werden.
XBCXC.S=Der Verschl\u00fcsselungsalgorithmus ''{0}'' ist nicht vorhanden. \u00dcberpr\u00fcfen Sie, ob der ausgew\u00e4hlte Provider ''{1}'' diesen Algorithmus unterst\u00fctzt.
XBCXD.S=Der Verschl\u00fcsselungsalgorithmus kann nach dem Erstellen der Datenbank nicht ge\u00e4ndert werden.
XBCXE.S=Der Verschl\u00fcsselungsprovider kann nach dem Erstellen der Datenbank nicht ge\u00e4ndert werden.
XBCXF.S=Die Klasse ''{0}'', die den Verschl\u00fcsselungsprovider repr\u00e4sentiert, wurde nicht gefunden.
XBCXG.S=Der Verschl\u00fcsselungsprovider ''{0}'' ist nicht vorhanden.
XBCXH.S=Der Verschl\u00fcsselungsalgorithmus ''{0}'' hat nicht das richtige Format. Korrektes Format: Algorithmus/Feedbackmodus/Keine Auff\u00fcllung.
XBCXI.S=Der Feedbackmodus ''{0}'' wird nicht unterst\u00fctzt. Unterst\u00fctzte Feedbackmodi sind CBC, CFB, OFB und ECB.
XBCXJ.S=Die Anwendung verwendet eine \u00e4ltere JCE-Version (Java Cryptography Extension) als 1.2.1. F\u00fchren Sie ein Upgrade auf JCE 1.2.1 durch und wiederholen Sie die Operation. 
XBCXK.S=Der angegebene Chiffrierschl\u00fcssel stimmt nicht mit dem bei der Erstellung der Datenbank verwendeten Chiffrierschl\u00fcssel \u00fcberein. Vergewissern Sie sich, dass Sie den richtigen Chiffrierschl\u00fcssel verwenden, und versuchen Sie es erneut. 
XBCXL.S=Der Pr\u00fcfprozess f\u00fcr den Chiffrierschl\u00fcssel war nicht erfolgreich. Als Ursache kommt ein Fehler beim Zugriff auf die Datei f\u00fcr die Ausf\u00fchrung des Pr\u00fcfprozesses in Frage. Details enth\u00e4lt die n\u00e4chste Ausnahme. 
XBCXM.S=Die L\u00e4nge des externen Chiffrierschl\u00fcssels muss eine gerade Zahl sein.
XBCXN.S=Der externe Chiffrierschl\u00fcssel enth\u00e4lt mindestens ein ung\u00fcltiges Zeichen. Zul\u00e4ssige Zeichen f\u00fcr Hexadezimalzahlen sind 0-9, a-f und A-F.
XBCXO.S=Die Datenbank kann nicht verschl\u00fcsselt werden, wenn eine vorbereitete globale Transaktion vorliegt.
XBCXP.S=Die Datenbank kann nicht mit einem anderen Boot-Kennwort oder einem externen Chiffrierschl\u00fcssel neu verschl\u00fcsselt werden, wenn eine vorbereitete globale Transaktion vorliegt.
XBCXQ.S=Eine schreibgesch\u00fctzte Datenbank kann nicht f\u00fcr Verschl\u00fcsselung konfiguriert werden.
XBCXR.S=Eine schreibgesch\u00fctzte Datenbank kann nicht mit einem anderen Boot-Kennwort oder einem externen Chiffrierschl\u00fcssel neu verschl\u00fcsselt werden.
XBCXS.S=Eine Datenbank im Protokollarchivmodus kann nicht f\u00fcr Verschl\u00fcsselung konfiguriert werden.
XBCXT.S=Eine Datenbank im Protokollarchivmodus kann nicht mit einem anderen Boot-Kennwort oder einem externen Chiffrierschl\u00fcssel neu verschl\u00fcsselt werden.
XBCXU.S=Die Verschl\u00fcsselung einer unverschl\u00fcsselten Datenbank ist gescheitert: {0}
XBCXV.S=Die Verschl\u00fcsselung einer verschl\u00fcsselten Datenbank mit einem neuen Schl\u00fcssel oder einem neuen Kennwort ist gescheitert: {0}

#../java/com/ibm/db2j/impl/BasicServices/CacheService/Generic/messages.properties

# CacheStatementException messages
# sqlstate range: XBCA0 to XBCAZ

XBCA0.S=Im {0}-Cache kann kein neues Objekt mit dem Schl\u00fcssel {1} erstellt werden, da es bereits im Cache vorhanden ist. 


# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface.
# sqlstate range: XSAI0 to XSAIZ
XSAI2.S=Das angeforderte Konglomerat ({0}) ist nicht vorhanden.
XSAI3.S=Ein Feature ist nicht implementiert.

# java/com/ibm/db2j/protocol/Database/Storage/Access/Interface
# RunTimeStatistics properties messages.
# sqlstate range: XSAJ0 to XSAJZ
XSAJ0.U=Suchtyp
XSAJ1.U=Anzahl der besuchten Seiten
XSAJ2.U=Anzahl der besuchten Zeilen
XSAJ3.U=Anzahl der gel\u00f6schten besuchten Zeilen
XSAJ4.U=Anzahl der qualifizierten Zeilen
XSAJ5.U=Anzahl der abgerufenen Spalten
XSAJ6.U=Bits der abgerufenen Spalten
XSAJ7.U=Tiefe der Baumstruktur
XSAJ8.U=Sortiertyp
XSAJA.U=Anzahl der eingegebenen Zeilen
XSAJB.U=Anzahl der ausgegebenen Zeilen
XSAJC.U=Anzahl der Mischvorg\u00e4nge
XSAJD.U=Umfang der Mischvorg\u00e4nge
XSAJE.U=Alle

#NOTE: The next three messages are the names of types of scans.
XSAJF.U=B-Baumstruktur
XSAJG.U=Heap-Speicher
XSAJH.U=Sortierung

#NOTE: The next two messages are types of sorts
XSAJI.U=\u00e4u\u00dfere
XSAJJ.U=innere

# java/com/ibm/db2j/protocol/Database/Storage/Access/XA.
# sqlstate range: XSAX0 to XSAXZ
XSAX0.S=Fehlerhaftes XA-Protokoll.
XSAX1.S=Es wurde versucht, eine globale Transaktion mit der XID einer vorhandenen globalen Transaktion zu starten.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/AccessManager/Generic
# sqlstate range: XSAM0 to XSAMZ
XSAM0.S=Bei dem Versuch, ein Modul f\u00fcr ''{0}'' zu booten, ist eine Ausnahme eingetreten.
XSAM2.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' zum Freigeben vorhanden.
XSAM3.S=Es ist kein Index oder Konglomerat mit der Konglomerat-ID ''{0}'' vorhanden.
XSAM4.S=Es gibt keine Sortierung mit der Bezeichnung ''{0}''.
XSAM5.S=Sie m\u00fcssen die Suche \u00f6ffnen und positionieren, indem Sie vor allen anderen Methoden next() aufrufen.
XSAM6.S=Der Datensatz {2} auf Seite {1} im Container {0} wurde nicht gefunden.


#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Generic
# sqlstate range: XSCG0 to XSCGZ
XSCG0.S=Eine Schablone konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/Heap
# sqlstate range: XSCH0 to XSCHZ

XSCH8.S=Das Feature ist nicht implementiert.
XSCH7.S=Die Suche ist nicht positioniert.
XSCH6.S=Der Heap-Container mit der Container-ID {0} ist geschlossen.
XSCH5.S=In einer Basistabelle wich die Anzahl der angeforderten Spalten ({0}) von der maximalen Spaltenanzahl ({1}) ab.
XSCH4.S=Ein Konglomerat konnte nicht erstellt werden.
XSCH1.S=Der Container {0} wurde nicht gefunden.
XSCH0.S=Ein Container konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Conglomerate/BTree/Generic
# sqlstate range: XSCB0 to XSCBZ
XSCB9.S=F\u00fcr Testzwecke reserviert.
XSCB8.S=Das B-Baum-Konglomerat {0} ist geschlossen.
XSCB7.S=Beim Durchsuchen einer B-Baumstruktur ist ein interner Fehler aufgetreten; current_rh ist null = {0}; der Positionsschl\u00fcssel ist null = {1}.
XSCB6.S=Einschr\u00e4nkung: Der Datensatz f\u00fcr den Sekund\u00e4rindex einer B-Baumstruktur kann wegen unzureichenden Speicherbereichs auf der Seite nicht aktualisiert oder eingef\u00fcgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00e4nkung zu umgehen.
XSCB5.S=W\u00e4hrend des logischen Widerrufs einer Einf\u00fcge- oder L\u00f6schoperation f\u00fcr eine B-Baumstruktur kann die Zeile in der Baumstruktur nicht gefunden werden.
XSCB4.S=F\u00fcr eine begonnene Suche in einer B-Baumstruktur wurde eine Methode aufgerufen, bevor die Suche in der ersten Zeile positioniert wurde (d. h. next() wurde noch nicht aufgerufen). Der aktuelle Status der Suche ist ({0}).
XSCB3.S=Nicht implementiertes Feature.
XSCB2.S=In der f\u00fcr createConglomerate() f\u00fcr den Sekund\u00e4rindex einer Baumstruktur bereitgestellten Merkmalliste wurde das erforderliche Merkmal {0} nicht gefunden.
XSCB1.S=Der Container {0} wurde nicht gefunden.
XSCB0.S=Ein Container konnte nicht erstellt werden.

#../java/com/ibm/db2j/impl/Database/Storage/Access/Raw/Sort/External
# sqlstate range: XSAS0 to XSASZ

XSAS6.S=Es konnten keine Ressourcen f\u00fcr die Sortierung angefordert werden.
XSAS3.S=Der Typ einer in eine Suche eingef\u00fcgten Zeile stimmt nicht mit der Suchschablone \u00fcberein.
XSAS1.S=Es wurde versucht, eine Zeile vor Beginn oder nach Beendigung einer Suche abzurufen.
XSAS0.S=Es wurde eine Schnittstellenmethode des Suchcontrollers aufgerufen, die f\u00fcr das Durchsuchen einer Sortierung nicht geeignet ist.

# java/com/ibm/db2j/protocol/Database/Storage/RawStore/Interface.
# statement errors.
# sqlstate range: XSRS0 to XSRSZ
XSRS0.S=Die Datenbank kann nicht eingefroren werden, da sie bereits eingefroren ist.
XSRS1.S=Die Datenbank kann nicht in {0} gesichert werden, da es sich nicht um ein Verzeichnis handelt.
XSRS4.S=W\u00e4hrend der Sicherung ist ein Fehler beim Umbenennen der Datei von {0} in {1} aufgetreten.
XSRS5.S=W\u00e4hrend der Sicherung ist ein Fehler beim Kopieren der Datei von {0} in {1} aufgetreten.
XSRS6.S=Das Sicherungsverzeichnis {0} kann nicht erstellt werden.
XSRS7.S=Die Sicherung hat eine unerwartete Ausnahme abgefangen.
XSRS8.S=Die Protokolleinheit kann nur beim Erstellen der Datenbank definiert und w\u00e4hrend der Verarbeitung nicht ge\u00e4ndert werden.
XSRS9.S=Der Datensatz {0} ist nicht mehr vorhanden.
XSRSA.S=Die Datenbank kann nicht gesichert werden, solange nicht protokollierte Operationen noch nicht festgeschrieben sind. Schreiben Sie die Transaktionen mit den Operationen fest, die die Sicherung blockieren. 
XSRSB.S=F\u00fcr eine Transaktion mit nicht protokollierten und nicht festgeschriebenen Operationen kann keine Sicherung durchgef\u00fchrt werden.
XSRSC.S=Die Datenbank kann nicht in {0} gesichert werden, da es sich nicht um ein Datenbankverzeichnis handelt.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# statement errors.
# sqlstate range: XSLB0 to XSLBZ
XSLB9.S=Es k\u00f6nnen keine weiteren \u00c4nderungen ausgegeben werden. Die Protokoll-Factory wurde gestoppt.
XSLB8.S=Es wurde versucht, eine Suche auf {0} zur\u00fcckzusetzen. Dieser Wert liegt au\u00dferhalb der Begrenzung {1}.
XSLB6.S=Es wurde versucht, einen Protokollsatz mit der L\u00e4nge 0 oder -ve zu protokollieren.
XSLB5.S=Unzul\u00e4ssiger truncationLWM-Zeitpunkt {1} f\u00fcr Abschneidepunkt {0}. Der g\u00fcltige Bereich liegt zwischen {2} und {3}.
XSLB4.S=truncationLWM {0} wurde nicht gefunden.
XSLB2.S=Die Protokolloperation {0} protokolliert zu viele Daten. Sie hat den internen Protokollpuffer gef\u00fcllt.
XSLB1.S=Die Protokolloperation {0} hat beim Schreiben ihrer Daten in den Protokolldatenstrom einen Fehler festgestellt. Die Ursache kann eine falsche Protokolloperation oder die Ersch\u00f6pfung der Kapazit\u00e4t des internen Protokollpuffers durch eine zu umfangreiche Protokolloperation sein.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Log/Generic
# database errors.
# sqlstate range: XSLA0 to XSLAZ
XSLAT.D=Das Protokollverzeichnis ''{0}'' ist vorhanden, geh\u00f6rt m\u00f6glicherweise jedoch zu einer anderen Datenbank. \u00dcberpr\u00fcfen Sie, ob die f\u00fcr das Attribut logDevice angegebene Position stimmt.
XSLAS.D=Bei der Wiederherstellung wurde das Protokollverzeichnis {0} nicht in der Sicherung gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XSLAR.D=Bei der Wiederherstellung konnte die Protokolldatei ''{0}'' nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 
XSLAQ.D=Im Verzeichnis {0} kann keine Protokolldatei erstellt werden.
XSLAP.D=Die Datenbank in {0} hat die Version {1}. F\u00fcr Betadatenbanken ist kein Upgrade m\u00f6glich.
XSLAO.D=Die Wiederherstellung ist aufgrund des unerwarteten Fehlers {0} gescheitert.
XSLAN.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Die Datenbank wurde mit der Version {1} erstellt oder erweitert.
XSLAM.D=Das Format der Datenbank in {1} kann aufgrund einer E/A-Ausnahme nicht gepr\u00fcft werden.
XSLAL.D=Die Protokollsatzgr\u00f6\u00dfe {2} \u00fcberschreitet die maximal zul\u00e4ssige Gr\u00f6\u00dfe der Protokolldatei von {3}. In der Protokolldatei {0} wurde an der Position {1} ein Fehler festgestellt.
XSLAK.D=Die Datenbank hat die h\u00f6chste Protokolldateinummer {0} \u00fcberschritten.
XSLAJ.D=Das Protokollierungssystem wurde wegen eines fr\u00fcheren Fehlers zum Herunterfahren vorgemerkt und l\u00e4sst weitere Operationen erst nach einem Systemabschluss und einem Neustart des Systems zu.
XSLAI.D=Der Pr\u00fcfpunktprotokollsatz kann nicht protokolliert werden.
XSLAH.D=Sie aktualisieren eine schreibgesch\u00fctzte Datenbank.
XSLAF.D=Eine schreibgesch\u00fctzte Datenbank wurde mit benutzten Datenpuffern erstellt.
XSLAE.D=Die Steuerdatei in {0} kann nicht geschrieben oder aktualisiert werden.
XSLAD.D=Der Protokollsatz an der Adresse {2} in der Protokolldatei {3} ist besch\u00e4digt. Erwartete Protokollsatzl\u00e4nge: {0}; tats\u00e4chliche L\u00e4nge: {1}.
XSLAC.D=Das Format der Datenbank in {0} ist nicht mit der aktuellen Version der Software kompatibel. Sie wurde m\u00f6glicherweise mit einer neueren Version erstellt oder erweitert.
XSLAB.D=Die Protokolldatei {0} wurde nicht gefunden. Vergewissern Sie sich, dass das Merkmal logDevice ordnungsgem\u00e4\u00df und mit dem richtigen Pfadtrennzeichen f\u00fcr Ihre Plattform angegeben ist.
XSLAA.D=Der Speicher wurde von einer fr\u00fcheren Ausnahme zum Herunterfahren vorgemerkt.
XSLA8.D=Die Transaktion {0} kann nicht zur\u00fcckgesetzt werden. Es wird versucht, die Operation {1} durch {2} zu kompensieren.
XSLA7.D=Die Operation {0} im Protokoll kann nicht wiederholt werden.
XSLA6.D=Die Datenbank kann nicht wiederhergestellt werden.
XSLA5.D=Der Protokolldatenstrom f\u00fcr das Zur\u00fccksetzen der Transaktion {0} kann nicht gelesen werden.
XSLA4.D=Es kann nicht in das Protokoll geschrieben werden. Wahrscheinlich ist das Protokoll voll. L\u00f6schen Sei nicht ben\u00f6tigte Dateien. Es kann auch sein, dass das Dateisystem schreibgesch\u00fctzt ist oder ein Datentr\u00e4gerfehler vorliegt.

XSLA3.D=Das Protokoll ist besch\u00e4digt. Der Protokolldatenstrom enth\u00e4lt ung\u00fcltige Daten.
XSLA2.D=Das System wird heruntergefahren. Beim Zugriff auf die Protokolldatei wurde eine E/A-Ausnahme empfangen.
XSLA1.D=Der Protokollsatz wurde an den Datenstrom gesendet, kann jedoch nicht in den Speicher (Objekt {0}) gestellt werden. Dies kann zu Fehlern bei der Wiederherstellung f\u00fchren.
XSLA0.D=Die freigegebene Protokolldatei kann nicht auf den Datentr\u00e4ger {0} geschrieben werden.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# statement errors.
# sqlstate range: XSTA0 to XSTAZ
# changed XSTA0 and XSTA1 to match DB2 sqlstates - bug 4466
3B501.S=In der aktuellen Transaktion ist bereits ein Sicherungspunkt mit dem \u00fcbergebenen Namen vorhanden.
3B502.S=Es wurde RELEASE oder ROLLBACK TO SAVEPOINT angegeben. Der Sicherungspunkt ist jedoch nicht vorhanden.
3B001.S=Der Sicherungspunkt {0} ist nicht vorhanden oder in der aktuellen Transaktion nicht aktiv.
3B002.S=Die maximale Anzahl von Sicherungspunkten ist erreicht. 
XSTA2.S=Es wurde versucht, eine Transaktion zu aktivieren, obwohl bereits eine andere Transaktion aktiv war.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# transaction errors.
# sqlstate range: 40XT0 to 40XTZ
40XT0=Das Modul RawStore hat einen internen Fehler festgestellt.
40XT1=Beim Festschreiben der Transaktion wurde eine Ausnahme ausgel\u00f6st.
40XT2=Beim Zur\u00fccksetzen eines Sicherungspunktes wurde eine Ausnahme ausgel\u00f6st.
40XT4=Es wurde versucht. eine noch aktive Transaktion zu schlie\u00dfen. Die Transaktion wurde abgebrochen.
40XT5=W\u00e4hrend einer internen Transaktion wurde eine Ausnahme ausgel\u00f6st.
40XT6=Die Datenbank ist stillgelegt, so dass die Transaktion nicht aktiviert werden kann. Warten Sie, bis die Datenbank vom Stilllegungsstatus in einen anderen Status wechselt.
40XT7=Die Operation wird in einer internen Transaktion nicht unterst\u00fctzt.

#
# 2D, 24, 57,58 - DRDA errors with SQLStates required by the spec
2D521.S.1=setAutoCommit(true) ist f\u00fcr eine globale Transaktion ung\u00fcltig.
2D521.S.2=COMMIT oder ROLLBACK ist f\u00fcr eine Anwendungsausf\u00fchrungsumgebung ung\u00fcltig. 
24501.S=Der angegebene Cursor ist nicht ge\u00f6ffnet.
# 58009.C is a generic message
# MAKE SURE YOU INTERNATIONALIZE THE REASON STRING AS WELL - Use the JXXX 
# codes below.  Add constants for the JXXX codes in reference.MessageId.java
58009.C=Es wurde ein Netzprotokollfehler gefunden. Die Verbindung wurde beendet. {0}
58009.C.2=SocketException: ''{0}''
58009.C.3=Es wurde ein \u00dcbertragungsfehler festgestellt. {0}
58009.C.4=W\u00e4hrend des verz\u00f6gerten Zur\u00fccksetzens einer Verbindung ist ein Fehler aufgetreten. Die Verbindung wurde beendet. Details finden Sie in den zugeh\u00f6rigen Ausnahmen.
58009.C.5=Unzureichende Daten beim Lesen aus dem Netz. Erwartet wurden mindestens {0} Bytes, empfangen wurden jedoch nur {1} Bytes. Die Verbindung wurde beendet.
58009.C.6=Es wurde versucht, LOB-Daten vollst\u00e4ndig zu speichern, die f\u00fcr die JVM zu umfangreich sind. Die Verbindung wurde beendet.
58009.C.7=Netzprotokollausnahme: Die SCLDTA-L\u00e4nge {0} ist f\u00fcr RDBCOLID ung\u00fcltig. Die Verbindung wurde beendet.
58009.C.8=Netzprotokollausnahme: Die SCLDTA-L\u00e4nge {0} ist f\u00fcr PKGID ung\u00fcltig. Die Verbindung wurde beendet.
58009.C.9=Netzprotokollausnahme: Die SCLDTA-L\u00e4nge {0} ist f\u00fcr SQLAM {1} ung\u00fcltig. Die Verbindung wurde beendet.
58009.C.10=Netzprotokollausnahme: Nur die VCM-L\u00e4nge oder nur die VCS-L\u00e4nge darf gr\u00f6\u00dfer als 0 sein. Die Verbindung wurde beendet.
58009.C.11=Die Verbindung wurde beendet, weil die Codierung nicht unterst\u00fctzt wird.
58009.C.12=Netzprotokollausnahme: Der tats\u00e4chliche Codepunkt {0} stimmt nicht mit dem erwarteten Codepunkt {1} \u00fcberein. Die Verbindung wurde beendet.
58009.C.13=Netzprotokollausnahme: Die DDM-Objektgruppe enth\u00e4lt weniger als 4 Bytes Daten. Die Verbindung wurde beendet.
58009.C.14=Netzprotokollausnahme: Der Objekt-Stack ist zum Ende der Syntaxanalyse der DDS-Kette nicht leer. Die Verbindung wurde beendet.
58009.C.15=Netzprotokollausnahme: Die L\u00e4nge eines DDS-Segments war zum Ende der Syntaxanalyse der DDS-Kette gr\u00f6\u00dfer als 0. Die Verbindung wurde beendet.
58009.C.16=Netzprotokollausnahme: Das n\u00e4chste DDS-Segment der Kette hat dieselbe ID wie das aktuelle Segment. Die Verbindung wurde beendet.
58009.C.17=Netzprotokollausnahme: Beim Lesen des Eingabedatenstroms (Parameter {0}) wurde das Ende des Datenstroms vorzeitig erreicht. Die Verbindung wurde beendet.
58009.C.18=Netzprotokollausnahme: Ung\u00fcltiges FDOCA-LID. Die Verbindung wurde beendet.
58009.C.19=Netzprotokollausnahme: SECTKN wurde nicht zur\u00fcckgegeben. Die Verbindung wurde beendet.
58009.C.20=Netzprotokollausnahme: Nur NVCM oder nur NVCS darf ungleich null sein. Die Verbindung wurde beendet.
58009.C.21=Netzprotokollausnahme: Die SCLDTA-L\u00e4nge {0} ist f\u00fcr RDBNAM ung\u00fcltig. Die Verbindung wurde beendet.


58010.C=Es wurde ein Netzprotokollfehler gefunden. Es konnte keine Verbindung hergestellt werden, weil der Manager {0} der Version {1} vom Server nicht unterst\u00fctzt wird. 
58014.C=Der DDM-Befehl 0x{0} wird nicht unterst\u00fctzt. Die Verbindung wurde beendet.
58015.C=Das DDM-Objekt 0x{0} wird nicht unterst\u00fctzt. Die Verbindung wurde beendet.
58016.C=Der DDM-Parameter 0x{0} wird nicht unterst\u00fctzt. Die Verbindung wurde beendet.
58017.C=Der DDM-Parameterwert 0x{0} wird nicht unterst\u00fctzt. M\u00f6glicherweise liegt eine eingegebene Hostvariable nicht in dem vom Server unterst\u00fctzten Bereich. Die Verbindung wurde beendet.
57017.C=Eine Konvertierung von der Quellen-Codepage {0} in die Ziel-Codepage {1} ist nicht verf\u00fcgbar. Die Verbindung wurde beendet.


#
#java/com/ibm/db2j/internalUtil
#	Id Parse Errors       			XCXA0-XCXAZ
#  	Db Class Path Parse Errors 	 	XCXB0-XCXBZ
# 	Id List Parse Errors			XCXC0-XCXCZ
#  	IO Errors						XCXD0-XCXDZ
#	LocaleFinder Errors				XCXE0-XCXEZ
XCXA0.S=Ung\u00fcltige Kennung.
XCXB0.S=Ung\u00fcltiger Datenbankklassenpfad: ''{0}''.
XCXC0.S=Ung\u00fcltige ID-Liste.
XCXE0.S=Sie versuchen, eine Operation auszuf\u00fchren, die das Gebietsschema der Datenbank verwendet. F\u00fcr die Datenbank ist jedoch kein Gebietsschema festgelegt.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Transactions/Basic
# system errors.
# sqlstate range: XSTB0 to XSTBZ
XSTB0.M=Beim Abbrechen der Transaktion wurde eine Ausnahme ausgel\u00f6st.
XSTB2.M=Die Transaktions\u00e4nderungen k\u00f6nnen nicht protokolliert werden. M\u00f6glicherweise versuchen Sie, in eine schreibgesch\u00fctzte Datenbank zu schreiben.
XSTB3.M=Die Transaktion kann nicht abgebrochen werden, weil der Protokollmanager - wahrscheinlich aufgrund eines fr\u00fcheren Fehlers - nicht angegeben ist.
XSTB5.M=Beim Erstellen einer Datenbank mit inaktivierter Protokollierung ist ein unerwarteter Fehler aufgetreten.
XSTB6.M=Eine Transaktionstabelle kann nicht durch eine andere ersetzt werden, solange eine der beiden Tabellen verwendet wird.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# transaction errors.
# sqlstate range: 40XD0 to 40XDZ
40XD0=Der Container wurde geschlossen.
40XD1=Der Container wurde im Schreibschutzmodus ge\u00f6ffnet.
40XD2=Der Container {0} kann nicht ge\u00f6ffnet werden. Er wurde gel\u00f6scht oder ist nicht vorhanden.


# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# statement errors.
# sqlstate range: XSDA0 to XSDAZ
XSDA1.S=Es wurde versucht, auf einer Seite auf eine Stelle au\u00dferhalb des Bereiches zuzugreifen.
XSDA2.S=Es wurde versucht, einen gel\u00f6schten Datensatz zu aktualisieren.
XSDA3.S=Einschr\u00e4nkung: Der Datensatz wegen unzureichenden Speicherbereichs auf der Seite nicht aktualisiert oder eingef\u00fcgt werden. Verwenden Sie den Parameter derby.storage.pageSize und/oder derby.storage.pageReservedSpace, um diese Einschr\u00e4nkung zu umgehen.
XSDA4.S=Es wurde eine unerwartete Ausnahme ausgel\u00f6st.
XSDA5.S=Es wurde versucht, das L\u00f6schen eines nicht gel\u00f6schten Datensatzes zu widerrufen.
XSDA6.S=Die Spalte {0} der Zeile ist gleich null. Sie muss so konfiguriert werden, dass sie auf ein Objekt zeigt.
XSDA7.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde versucht, mehr Daten zu lesen, als urspr\u00fcnglich gespeichert wurden.
XSDA8.S=Ausnahme beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0}.
XSDA9.S=Beim Wiederherstellen eines serialisierbaren oder SQLData-Objekts der Klasse {0} wurde die Klasse nicht gefunden.
XSDAA.S=Ung\u00fcltige Zeitmarke {0}. Die Zeitmarke stammt von einer anderen Seite oder von einer inkompatiblen Implementierung.
XSDAB.S=Eine Nullzeitmarke kann nicht gesetzt werden.
XSDAC.S=Es wurde versucht, Zeilen oder Seiten von einem Container in einen anderen zu verschieben.
XSDAD.S=Es wurde versucht, Nullzeilen von einer Seite auf eine andere zu verschieben.
XSDAE.S=Eine interne Datensatzkennung kann nur f\u00fcr eine spezifische Kennungs-ID erstellt werden.
XSDAF.S=Eine spezifische interne Datensatzkennung wird wie eine normale interne Kennung verwendet.
XSDAG.S=Der Container kann nicht durch die erste verschachtelte Zuordnungstransaktion ge\u00f6ffnet werden.
XSDAI.S=Die Seite {0}, die gerade entfernt wird, ist bereits gesperrt, um freigegeben zu werden.
XSDAJ.S=Ausnahme beim Schreiben eines serialisierbaren oder SQLData-Objekts.
XSDAK.S=F\u00fcr die interne Datensatzkennung {0} wurde die falsche Seite abgerufen.
XSDAL.S=Die interne Datensatzkennung {0} zeigt unerwartet auf die \u00dcberlaufseite.
XSDAM.S=Ausnahme beim Wiederherstellen eines SQLData-Objekts der Klasse {0}. Es k\u00f6nnen keine Instanzen der angegebenen Klasse erstellt werden.
XSDAN.S=Ausnahme beim Wiederherstellen eines SQLData-Objekts der Klasse {0}. Die angegebene Klasse hat eine Ausnahme durch unzul\u00e4ssigen Zugriff festgestellt.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/Generic
# database errors.
# sqlstate range: XSDB0 to XSDBZ
XSDB0.D=Unerwartete Ausnahme auf der speicherinternen Seite {0}
XSDB1.D=Unbekanntes Seitenformat auf der Seite {0}
XSDB2.D=Unbekanntes Containerformat im Container {0}: {1}
XSDB3.D=Einmal geschriebene Containerinformationen k\u00f6nnen nicht ge\u00e4ndert werden. Vorheriger Stand: {0}; aktueller Stand: {1}
XSDB4.D=Die Seite {0} hat den Versionsstand {1}. Die Protokolldatei enth\u00e4lt die \u00c4nderungsversion {2}. Es fehlen Protokolls\u00e4tze dieser Seite oder die Seite wurde nicht ordnungsgem\u00e4\u00df auf den Datentr\u00e4ger geschrieben.
XSDB5.D=Der \u00c4nderungssatz befindet sich auf Seite {0} des Protokolls, die sich au\u00dferhalb des Containerendes befindet.
XSDB6.D=Die Datenbank {0} wurde m\u00f6glicherweise bereits von einer anderen Derby-Instanz gebootet.
XSDB7.D=WARNUNG: Derby (Instanz {0}) versucht, die Datenbank {1} zu booten, obwohl Derby (Instanz {2}) noch aktiv sein k\u00f6nnte. Eine Datenbank sollte immer nur von jeweils einer Derby-Instanz gebootet werden. Es k\u00f6nnen schwerwiegende und irreparable Sch\u00e4den eingetreten sein oder noch eintreten.
XSDB8.D=WARNUNG: Derby (Instanz {0}) versucht, die Datenbank {1} zu booten, obwohl Derby (Instanz {2}) noch aktiv sein k\u00f6nnte. Eine Datenbank sollte immer nur von jeweils einer Derby-Instanz gebootet werden. Es k\u00f6nnen schwerwiegende und irreparable Sch\u00e4den eintreten, wenn zwei Instanzen von Derby gleichzeitig dieselbe Datenbank booten. Das Merkmal db2j.database.forceDatabaseLock=true wurde gesetzt, so dass die Datenbank erst gebootet wird, wenn db.lck nicht mehr vorhanden ist. Diese Datei wird normalerweise entfernt, wenn die erste Derby-Instanz zum Booten der Datenbank vorhanden ist. Es kann jedoch vorkommen, dass sie beim Herunterfahren nicht gel\u00f6scht wird. In diesem Fall muss die Datei manuell entfernt werden. Vergewissern Sie sich vor dem manuellen L\u00f6schen der Datei db.lck unbedingt, dass keine andere VM auf die Datenbank zugreift.
XSDB9.D=Der Datenstromcontainer {0} ist besch\u00e4digt.
XSDBA.D=Der Versuch, das Objekt {0} zuzuordnen, ist gescheitert.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# statment errors.
# sqlstate range: XSDF0 to XSDFZ
XSDF0.S=Die Datei {0} konnte nicht erstellt werden, da sie bereits vorhanden ist.
XSDF1.S=Beim Erstellen der Datei {0} f\u00fcr den Container ist eine Ausnahme eingetreten.
XSDF2.S=Beim Erstellen der Datei {0} f\u00fcr den Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. Ausnahme: {1}.
XSDF3.S=Das Segment {0} kann nicht erstellt werden.
XSDF4.S=Beim Entfernen der Datei {0} f\u00fcr den gel\u00f6schten Container ist eine Ausnahme eingetreten. Die Datei konnte nicht entfernt werden. {1}.
XSDF6.S=Die Zuordnungsseite {0} wurde nicht gefunden.
XSDF7.S=Die neu erstellte Seite {0} konnte nicht gesperrt werden.
XSDF8.S=Die wiederzuverwendende Seite {0} wurde nicht gefunden.
XSDFB.S=Die Operation wird von einer schreibgesch\u00fctzten Datenbank nicht unterst\u00fctzt.
XSDFD.S=Auf Seite {0} wurde in zwei Ein-/Ausgaben verschiedene Seitenimages gelesen. Das erste Image hat die falsche Kontrollsumme und das zweite die richtige. Seitenimages: {1} {2}
XSDFF.S=Die angeforderte Operation ist durch eine unerwartete Ausnahme gescheitert.
XSDFH.S=Die Datenbank kann nicht gesichert werden. Beim Schreiben in die Backup-Containerdatei {0} wurde eine E/A-Ausnahme empfangen.
XSDFI.S=Bei dem Versuch, w\u00e4hrend der Datenbankwiederherstellung Daten auf Platte zu schreiben, wurde ein Fehler festgestellt. \u00dcberpr\u00fcfen Sie, ob die Platte mit der Datenbank voll ist. Sollte dies der Fall sein, l\u00f6schen Sie nicht ben\u00f6tigte Dateien und versuchen Sie erneut, eine Verbindung zur Datenbank herzustellen. Es kann auch sein, dass das Dateisystem schreibgesch\u00fctzt ist oder ein Datentr\u00e4gerfehler vorliegt. Das System hat bei der Verarbeitung der Seite {0} einen Fehler festgestellt.

# java/com/ibm/db2j/impl/Database/Storage/RawStore/Data/FileSystem
# database errors.
# sqlstate range: XSDG0 to XSDGZ
XSDG0.D=Die Seite {0} konnte nicht vom Datentr\u00e4ger gelesen werden.
XSDG1.D=Die Seite {0} konnte nicht auf den Datentr\u00e4ger geschrieben werden. Pr\u00fcfen Sie, ob der Datentr\u00e4ger voll ist.
XSDG2.D=Ung\u00fcltige Kontrollsumme auf der Seite {0}. Erwartet: {1}, Version auf Datentr\u00e4ger: {2}. Seitenspeicherauszug: {3}
XSDG3.D=Auf die Metadaten f\u00fcr den Container {0} konnte nicht zugegriffen werden.
XSDG5.D=Die Datenbank befand sich nicht im Erstellungsmodus, als createFinished aufgerufen wurde.
XSDG6.D=Bei der Wiederherstellung wurde das Datensegmentverzeichnis nicht in der Sicherung {0} gefunden. Vergewissern Sie sich, dass es sich um die richtige Sicherungskopie handelt und dass diese nicht besch\u00e4digt ist.
XSDG7.D=Bei der Wiederherstellung konnte das Verzeichnis {0} nicht entfernt werden. Vergewissern Sie sich, dass die notwendigen Berechtigungen vorliegen.
XSDG8.D=Bei der Wiederherstellung konnte das Verzeichnis ''{0}'' nicht nach ''{1}'' kopiert werden. Vergewissern Sie sich, dass genug Speicherplatz verf\u00fcgbar ist und dass die notwendigen Berechtigungen vorliegen. 

# language
01500=Die Integrit\u00e4tsbedingung {0} in Tabelle {1} wurde gel\u00f6scht.
01501=Die Ansicht {0} wurde gel\u00f6scht.
01502=Der Ausl\u00f6ser {0} in Tabelle {1} wurde gel\u00f6scht.
01503=Die Spalte {0} in Tabelle {1} wurde durch das Hinzuf\u00fcgen einer Integrit\u00e4tsbedingung ungleich null ge\u00e4ndert.
01504=Der neue Index ist ein Duplikat eines vorhandenen Indexes: {0}.
01505=Der Wert {0} ist m\u00f6glicherweise abgeschnitten.
01522=Das neu definierte Synonym ''{0}'' wurde in das Objekt ''{1}'' aufgel\u00f6st, das derzeit nicht definiert ist.
01001=Es wurde versucht, eine bereits gel\u00f6schte Zeile zu aktualisieren oder zu l\u00f6schen. Keine Zeile wurde aktualisiert oder gel\u00f6scht.
01003=Aus dem Argument einer Spaltenfunktion wurden Nullwerte eliminiert.
01006=Die Berechtigung wurde dem Benutzer {0} nicht entzogen.
0100E=XX Es wurde versucht, zu viele Ergebnislisten zur\u00fcckzugeben. 
02000=F\u00fcr FETCH, UPDATE oder DELETE wurde keine Zeile gefunden oder das Ergebnis einer Abfrage ist eine leere Tabelle.
# Next one is generic XQuery error per SQL/XML[2006]
10000=Bei der Auswertung des XML-Abfrageausdrucks f\u00fcr den Operator {0} wurde ein Fehler festgestellt: {1}
21000=Eine skalare Unterabfrage darf nur eine Zeile zur\u00fcckgeben.
22001=Bei dem Versuch, {0} ''{1}'' auf die L\u00e4nge {2} zu k\u00fcrzen, ist ein Abschneidefehler aufgetreten.
54006=Die aus der Operation {0} resultierende L\u00e4nge ist gr\u00f6\u00dfer als {1}.
22003=Der resultierende Wert liegt au\u00dferhalb des Bereichs f\u00fcr den Datentyp {0}.
22003.S.1=Die Jahresangabe ({0}) \u00fcberschreitet den Maximalwert ''{1}''.
22003.S.2=Eine Dezimalzahl darf nicht mehr als 31 Stellen haben.
22003.S.3=Bei der Konvertierung eines numerischen Datentyps von ''{0}'' in {1} ist es zu einem \u00dcberlauf gekommen.
22004.S.4=Die L\u00e4nge ({0}) \u00fcberschreitet das Maximum f\u00fcr den Datentyp ({1}).
22005=Es wurde versucht, einen Datenwert des Typs ''{0}'' aus einem Datenwert des Typs ''{1}'' abzurufen.
22005.S.1=Ein Wert des Typs ''{0}'' kann nicht in den Typ ''{1}'' konvertiert werden. Die Codierung wird nicht unterst\u00fctzt.
22005.S.2=Der erforderliche Zeichenumsetzer ist nicht verf\u00fcgbar.
22005.S.3=Eine Unicode-Zeichenfolge kann nicht in eine EBCDIC-Zeichenfolge konvertiert werden.
22005.S.4=Nicht erkannter JDBC-Typ. Typ: {0}, Spaltennummer: {1}, Spaltenindex: {2}
22005.S.5=Ung\u00fcltiger JDBC-Typ f\u00fcr den Parameter {0}
22005.S.6=Nicht erkannter Java-SQL-Typ {0}
22007.S.180=Die Zeichenfolgendarstellung eines datetime-Wertes liegt au\u00dferhalb des Bereichs.
22007.S.181=Die Syntax der Zeichenfolgendarstellung eines datetime-Wertes ist fehlerhaft.
22008.S=''{0}'' ist ein ung\u00fcltiges Argument f\u00fcr die Funktion {1}.
22011=Das zweite oder dritte Argument der Funktion SUBSTR liegt au\u00dferhalb des Bereichs.
22012=Es wurde eine Division durch null versucht.
22013=Es wurde versucht, die Quadratwurzel einer negativen Zahl (''{0}'') zu ziehen.
22014=Die Anfangsposition f\u00fcr LOCATE ist ung\u00fcltig. Sie muss eine positive ganze Zahl sein. Der Index, bei dem die Suche beginnen soll, ist ''{2}''. Zu suchende Zeichenfolge: ''{0}''. Die Zeichenfolge, bei der die Suche beginnen soll, ist ''{1}''. 
22015=Die Funktion ''{0}'' ist f\u00fcr die folgenden Typen unzul\u00e4ssig. Der erste Operand ist vom Typ ''{1}''.  Der zweite Operand ist vom Typ ''{2}''. Der dritte Operand (Anfangsposition) ist vom Typ ''{3}''.
22015.S.1= Ung\u00fcltige Datenkonvertierung. Bei der angeforderten Konvertierung w\u00fcrde einen Genauigkeitsverlust von {0} nach sich ziehen.
22018=Ung\u00fcltiges Zeichenfolgenformat f\u00fcr den Typ {0}
22019=Die Escape-Zeichenfolge ''{0}'' ist ung\u00fcltig. Die Escape-Zeichenfolge muss aus genau einem Zeichen bestehen. Sie muss ungleich null sein und darf nicht mehr als ein Zeichen enthalten.
22025=Auf das Escape-Zeichen muss ein Escape-Zeichen ''_'' oder ''%'' folgen. Ein anderes Folgezeichen ist unzul\u00e4ssig. Das Escape-Zeichen darf auch nicht das letzte Zeichen des Musters sein.
22027=Die integrierte Funktion TRIM() unterst\u00fctzt nur das Entfernen eines Zeichens. Die integrierten Funktionen LTRIM() und RTRIM() unterst\u00fctzen das Entfernen mehrerer Zeichen.
22028=Die Zeichenfolge \u00fcberschreitet die maximale L\u00e4nge von {0}.
22501=Eine ESCAPE-Klausel NULL gibt nicht definierte Ergebnisse zur\u00fcck und ist unzul\u00e4ssig.

## SQL/XML errors.
2200L=XML-Spalten zugeordnete Werte m\u00fcssen korrekt formatierte DOCUMENT-Knoten sein.
2200M=Ung\u00fcltiges XML DOCUMENT: {0}
2200V=Ung\u00fcltiges Kontextelement f\u00fcr den Operator {0}. Kontextelemente m\u00fcssen korrekt formatierte DOCUMENT-Knoten sein.
2200W=XQuery-Serialisierungsfehler: Es wurde versucht, mindestens einen ATTRIBUTE-Knoten der Ausgangsebene zu serialisieren.
# end SQL/XML errors.

23502=Die Spalte ''{0}'' akzeptiert keinen Nullwert.
23505=Die Anweisung wurde abgebrochen, weil sie in einer f\u00fcr ''{1}'' definierten Vorgabe f\u00fcr einen eindeutigen oder Prim\u00e4rschl\u00fcssel bzw. f\u00fcr einen von ''{0}'' bezeichneten eindeutigen Index zu einem duplizierten Schl\u00fcsselwert gef\u00fchrt h\u00e4tte.
23503={2} in Tabelle ''{1}'' hat f\u00fcr Schl\u00fcssel {3} die Integrit\u00e4tsbedingung ''{0}'' f\u00fcr Fremdschl\u00fcssel verletzt. Die Anweisung wurde zur\u00fcckgesetzt.
23513=Die Bedingung ''{1}'' f\u00fcr die Integrit\u00e4tspr\u00fcfung wurde beim Ausf\u00fchren von INSERT oder UPDATE f\u00fcr Tabelle ''{0}'' verletzt.
38000=Bei der Auswertung eines Ausdrucks wurde die Ausnahme ''{0}'' ausgel\u00f6st.
38001=Die externe Routine ist nicht berechtigt, SQL-Anweisungen auszuf\u00fchren.
38002=Die Routine hat versucht, Daten zu modifizieren, wurde jedoch nicht als MODIFIES SQL DATA definiert.
38004=Die Routine hat versucht, Daten zu lesen, wurde jedoch nicht als READS SQL DATA definiert.
39004=An eine Methode mit einem Parameter des Primitive-Typs ''{0}'' kann kein Nullwert \u00fcbergeben werden.
40XC0=Nicht mehr verwendbare Anweisung. Die Ursache kann das Abfangen eines Transaktionsfehlers bestimmter Wertigkeit innerhalb dieser Anweisung sein.
# this error is retired in 1.3
42000=Syntaxfehler oder Verletzung einer Zugriffsregel. Details k\u00f6nnen Sie den zus\u00e4tzlichen Fehlernachrichten entnehmen.
42500=Der Benutzer ''{0}'' hat keine {1}-Berechtigung f\u00fcr die Tabelle ''{2}''.''{3}''.
42501=Dem Benutzer ''{0}'' wurde keine {1}-Berechtigung f\u00fcr die Tabelle ''{2}''.''{3}'' mit GRANT erteilt.
42502=Der Benutzer ''{0}'' hat keine {1}-Berechtigung f\u00fcr Spalte ''{2}'' der Tabelle ''{3}''.''{4}''.
42503=Dem Benutzer ''{0}'' wurde keine {1}-Berechtigung f\u00fcr Spalte ''{2}'' der Tabelle ''{3}''.''{4}'' mit GRANT erteilt.
42504=Der Benutzer ''{0}'' hat keine Ausf\u00fchrungsberechtigung f\u00fcr {1} ''{2}''.''{3}''.
42505=Dem Benutzer ''{0}'' wurde keine Ausf\u00fchrungsberechtigung f\u00fcr {1} ''{2}''.''{3}'' mit GRANT erteilt.
42506=Der Benutzer ''{0}'' ist nicht der Eigner von {1} ''{2}''.''{3}''.
42507=Der Benutzer ''{0}'' darf die Operation im Schema ''{1}'' nicht ausf\u00fchren.
42508=Der Benutzer ''{0}'' darf das Schema ''{1}'' nicht erstellen. Diese Anweisung kann nur vom Datenbankeigner abgesetzt werden.
42509=Die angegebene Operation GRANT oder REVOKE ist f\u00fcr das Objekt ''{0}'' nicht zul\u00e4ssig.
4250A=Dem Benutzer ''{0}'' wurde keine Berechtigung f\u00fcr das Objekt ''{2}''.''{3}'' mit {1} erteilt.
4250B=Ung\u00fcltiges Datenbankberechtigungsmerkmal ''{0}={1}''.
4250C=Benutzer ''{0}'' d\u00fcrfen nicht gleichzeitig in Berechtigungslisten f\u00fcr Lesezugriff und Vollzugriff enthalten sein.
4250D=Benutzer ''{1}'' wiederholt in der Zugriffsliste ''{0}'';
4250E=Interner Fehler: Ung\u00fcltige ID {0} in der Liste der Anweisungsberechtigungen.

# DB2 error for max length violation by char, varchar and long varchar. In future, this error message will be used for other purposes too
42601=Die Spalte ''{0}'' wurde in einer Anweisung ALTER TABLE als NOT NULL angegeben und die Klausel DEFAULT wurde nicht oder als DEFAULT NULL angegeben.
42601.S.372=Die Anweisung ALTER TABLE kann keine Spalte IDENTITY zu einer Tabelle hinzuf\u00fcgen.
42606=Es wurde eine ung\u00fcltige Hexadezimalkonstante gefunden, die mit ''{0}'' beginnt.
54002=Eine mit ''{0}'' beginnende Zeichenfolgekonstante ist zu lang.
42611=Das Attribut length, precision oder scale f\u00fcr die Spalte oder Typzuordnung ''{0}'' ist ung\u00fcltig. 

42605=Die Anzahl der Argumente f\u00fcr die Funktion ''{0}'' ist falsch.
42610=Es k\u00f6nnen nicht alle Argumente f\u00fcr die Funktion COALESCE/VALUE Parameter sein. Mindestens ein Argument darf kein Parameter sein.

42613=Es liegen mehrere oder in Konflikt stehende Schl\u00fcsselw\u00f6rter mit der Klausel ''{0}'' vor.
42621=Eine mit ''{0}'' definierte Bedingung f\u00fcr die Integrit\u00e4tspr\u00fcfung oder generierte Spalte ist ung\u00fcltig.
42734=Der im Kontext ''{1}'' angegebene Name ''{0}'' ist nicht eindeutig.
# DB2 error for invalid set schema
42802=Die Anzahl der zugeordneten Werte stimmt nicht mit der Anzahl der angegebenen oder impliziten Spalten \u00fcberein.
42815.S.713=Der Ersatzwert f\u00fcr ''{0}'' ist ung\u00fcltig.
42815.S.171=Die Argumente ''{0}'' und ''{1}'' sind nach Datentyp, L\u00e4nge oder Argumentwerten inkompatibel.
42820=Das Gleitkommaliteral ''{0}'' enth\u00e4lt mehr als 30 Zeichen.
42824=Ein Operand von LIKE ist keine Zeichenfolge, oder der erste Operand ist keine Spalte.
42831=''{0}'' kann Nullwerte enthalten und daher keine Spalte eines Prim\u00e4rschl\u00fcssels oder eines eindeutigen Schl\u00fcssels sein.
42834=SET NULL kann nicht angegeben werden, weil der Fremdschl\u00fcssel ''{0}'' keine Nullwerte enthalten darf. 
42884=Es wurde keine autorisierte Routine ''{0}'' des Typs ''{1}'' mit kompatiblen Argumenten gefunden.
42886=Der ''{0}''-Parameter ''{1}'' erfordert eine Parametermarke ''?''.
42894=Der DEFAULT-Wert oder der Wert des Attributs IDENTITY ist f\u00fcr die Spalte ''{0}'' ung\u00fcltig.
428C1=Pro Tabelle ist nur eine Identit\u00e4tsspalte zul\u00e4ssig.
42903=Ung\u00fcltige Verwendung einer Aggregatfunktion.
42908=Die Anweisung CREATE VIEW enth\u00e4lt keine Spaltenliste.
42915=Der Fremdschl\u00fcssel ''{0}'' ist wegen ''{1}'' ung\u00fcltig. 
42916=Das Synonym ''{0}'' kann nicht f\u00fcr ''{1}'' erstellt werden, da dies zu einer Synonymkette in Form einer Schleife f\u00fchren w\u00fcrde.
42972=Eine einem JOIN-Operator zugeordnete ON-Klausel ist ung\u00fcltig.
42X01=Syntaxfehler: {0}.
42X02={0}.
42X03=Der Spaltenname ''{0}'' findet sich in mehr als einer Tabelle der FROM-Liste.
42X04=Die Spalte ''{0}'' ist in keiner Tabelle der FROM-Liste enthalten, erscheint in einer Verkn\u00fcpfungsspezifikation und befindet sich au\u00dferhalb des Geltungsbereichs derselben oder erscheint in einer HAVING-Klausel und ist nicht in der ''GROUP BY''-Liste enthalten. Wenn es sich um eine Anweisung CREATE oder ALTER TABLE handelt, ist ''{0}'' keine Spalte in der Zieltabelle.
42X05=Die Tabelle/Ansicht ''{0}'' ist nicht vorhanden.
42X06=F\u00fcr die Tabelle ''{0}'' wurden zu viele Ergebnisspalten angegeben.
42X07=Null ist nur in einer VALUES-Klausel innerhalb einer INSERT-Anweisung zul\u00e4ssig.
42X08=Der Konstruktor f\u00fcr die Klasse ''{0}'' kann nicht als \u00e4u\u00dfere virtuelle Tabelle verwendet werden, da die Klasse ''{1}'' nicht implementiert. 
42X09=Die Tabelle oder der Aliasname ''{0}'' wird in der FROM-Liste mehr als einmal verwendet.
42X10=''{0}'' ist kein in diesem Bereich angezeigter Tabellenname.
42622=Der Name ''{0}'' ist zu lang. Die maximale L\u00e4nge liegt bei ''{1}''.
42X12=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE TABLE mehr als einmal. 
54011=F\u00fcr die Tabelle oder Ansicht {1} wurden zu viele Spalten ({0}) angegeben. Die Begrenzung liegt bei {2}.
42Z9F=Zu viele Indizes ({0}) f\u00fcr die Tabelle {1}. Die Begrenzung liegt bei {2}.

42X13=Der Spaltenname ''{0}'' erscheint in der Spaltenliste einer INSERT-Anweisung mehr als einmal. 
42X14=''{0}'' ist keine Spalte in der Tabelle oder in VTI ''{1}''.
42X15=Der Spaltenname ''{0}'' erscheint in einer Anweisung ohne eine FROM-Liste.
42X16=Der Spaltenname ''{0}'' erscheint mehrfach in der SET-Klausel einer UPDATE-Anweisung.
42X17=Der Wert ''{0}'' ist in der Merkmalliste einer FROM-Klausel nicht als joinOrder-Spezifikation g\u00fcltig. Es sind nur die Werte FIXED und UNFIXED g\u00fcltig.

42803=Ein Ausdruck mit der Spalte ''{0}'' erscheint in der SELECT-Liste und ist nicht Bestandteil einer ''GROUP BY''-Klausel.
42818=Der Vergleich von ''{0}'' und ''{1}'' wird nicht unterst\u00fctzt.
42X19=Die WHERE- oder HAVING-Klausel oder die Definition CHECK CONSTRAINT ist ein Ausdruck des Typs ''{0}''. Es muss ein Boolescher Ausdruck sein.
42X23=Der Cursor {0} kann nicht aktualisiert werden.
#42X24=The unary ''-'' operator is not allowed on the ''{0}'' type.
42X25=Die Funktion ''{0}'' ist f\u00fcr den Typ ''{1}'' nicht zul\u00e4ssig.
42X26=Die Klasse ''{0}'' f\u00fcr die Spalte ''{1}'' ist nicht vorhanden oder nicht zug\u00e4nglich. Diese Situation kann eintreten, wenn die Klasse nicht \u00f6ffentlich ist.
42X28=Die zu l\u00f6schende Tabelle ''{0}'' ist keine Zieltabelle des Cursors ''{1}''.
42X29=Die zu aktualisierende Tabelle ''{0}'' ist nicht die Zieltabelle des Cursors ''{1}''.
42X30=Der Cursor ''{0}'' wurde nicht gefunden. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
42X31=Die Spalte ''{0}'' ist nicht in der ''FOR UPDATE''-Liste des Cursors ''{1}'' enthalten.
42X42=F\u00fcr die Spalte ''{0}'' ist kein Korrelationsname zul\u00e4ssig, weil die Spalte in der ''FOR UPDATE''-Liste enthalten ist.
42X32=Die Spaltenanzahl in der abgeleiteten Spaltenliste muss mit der Spaltenanzahl der Tabelle ''{0}'' \u00fcbereinstimmen.
42X33=Die abgeleitete Spaltenliste enth\u00e4lt zweimal den Spaltennamen ''{0}''.
42X34=Die Liste enth\u00e4lt einen ?-Parameter. Dies ist unzul\u00e4ssig.
42X35=Es ist unzul\u00e4ssig, dass beide Operanden von ''{0}'' ?-Parameter sind.
42X36=F\u00fcr den Operator ''{0}'' darf kein ?-Parameter als Operand angegeben werden.
42X37=Der un\u00e4re Operator ''{0}'' ist f\u00fcr den Typ ''{1}'' nicht zul\u00e4ssig.
42X38=''SELECT *'' ist nur in den Unterabfragen EXISTS und NOT EXISTS zul\u00e4ssig.
42X39=Eine Unterabfrage darf nur eine Spalte zur\u00fcckgeben.
42X40=Ein Operand einer NOT-Anweisung ist kein Boolescher Operand. Das Ergebnis der Auswertung f\u00fcr den Operanden von NOT muss TRUE, FALSE oder UNKNOWN sein.

42X41=Das Merkmal ''{0}'' ist in der Merkmalklausel einer FROM-Liste ung\u00fcltig. (Das Merkmal wurde auf ''{1}'' gesetzt.) 
42821=Spalten vom Typ ''{0}'' d\u00fcrfen keine Werte des Typs ''{1}'' enthalten. 
42X43=Die von der Klasse bzw. dem Objekt ''{0}'' zur\u00fcckgegebenen ResultSetMetaData waren Nulldaten. Die ResultSetMetaData m\u00fcssen ungleich null sein, wenn diese Klasse als \u00e4u\u00dfere virtuelle Tabelle verwendet werden soll. 
42X44=Ung\u00fcltige L\u00e4nge ''{0}'' in der Spaltenspezifikation.
42X45={0} ist ein ung\u00fcltiger Typ f\u00fcr das Argument {1} von {2}.
42X46=Es gibt mehrere Funktionen mit dem Namen ''{0}''. Verwenden Sie die vollst\u00e4ndige Signatur oder den spezifischen Namen.
42X47=Es gibt mehrere Prozeduren mit dem Namen ''{0}''. Verwenden Sie die vollst\u00e4ndige Signatur oder den spezifischen Namen.
42X48=Der Wert ''{1}'' hat eine f\u00fcr ''{0}'' nicht g\u00fcltige Genauigkeit.
42X49=Der Wert ''{0}'' ist kein g\u00fcltiges ganzzahliges Literal.
42X50=Es wurde keine mit dem Methodenaufruf {0}.{1}({2}) \u00fcbereinstimmende Methode gefunden, obwohl alle Kombinationen von Objekttypen und Primitive-Typen und alle m\u00f6glichen Typumsetzungen f\u00fcr die zul\u00e4ssigen Parameter des Methodenaufrufs versucht wurden. M\u00f6glicherweise ist die Methode vorhanden, jedoch keine \u00f6ffentliche und/oder statische Methode. Es kann auch sein, dass die Parametertypen beim Aufruf der Methode nicht konvertierbar sind.
42X51=Die Klasse ''{0}'' ist nicht vorhanden oder es kann nicht auf die Klasse zugegriffen werden. Diese Situation kann eintreten, wenn die Klasse nicht \u00f6ffentlich ist.
42X52=Das Aufrufen einer Methode (''{0}'') mit dem Java-Primitive-Typ ''{1}'' als Empf\u00e4nger ist unzul\u00e4ssig.
42X53=Das Pr\u00e4dikat LIKE kann nur mit dem Operand ''CHAR'' oder ''VARCHAR'' verwendet werden. Der Typ ''{0}'' ist unzul\u00e4ssig.
42X54=Der Empf\u00e4nger der Java-Methode ''{0}'' ist ein ?. Dies ist unzul\u00e4ssig.
42X55=Der Tabellenname ''{1}'' muss mit ''{0}'' identisch sein.
42X56=Die Spaltenanzahl in der angezeigten Spaltenliste stimmt nicht mit der Spaltenanzahl im zugrundeliegen Abfrageausdruck in der Anzeigedefinition f\u00fcr ''{0}'' \u00fcberein.
42X57=getColumnCount() f\u00fcr die \u00e4u\u00dfere virtuelle Tabelle ''{0}'' hat den ung\u00fcltigen Wert ''{1}'' zur\u00fcckgegeben. G\u00fcltige Werte sind gr\u00f6\u00dfer als oder gleich 1. 
42X58=Die Spaltenanzahl auf der linken Seite von {0} muss mit der auf der rechten Seite \u00fcbereinstimmen.
42X59=Die Spaltenanzahl muss in allen VALUES-Konstruktoren identisch sein.
42X60=F\u00fcr die Tabelle ''{1}'' wurde f\u00fcr das Merkmal insertMode der ung\u00fcltige Wert ''{0}'' angegeben.
42X61=Die Typen ''{0}'' und ''{1}'' sind nicht mit {2} kompatibel.
42X62=''{0}'' ist im Schema ''{1}'' nicht zul\u00e4ssig.
42X63=Die USING-Klausel hat keine Ergebnisse geliefert. Es k\u00f6nnen keine Parameter gesetzt werden. 
42X64=In der Merkmalliste wurde f\u00fcr das Merkmal useStatistics der ung\u00fcltige Wert ''{0}'' angegeben. Es sind nur die Werte TRUE und FALSE g\u00fcltig. 
42X65=Der Index ''{0}'' ist nicht vorhanden.
42X66=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE INDEX mehr als einmal.
42X68=Es wurde kein Feld ''{0}'', das zur Klasse ''{1}'' geh\u00f6rt, gefunden. M\u00f6glicherweise ist das Feld vorhanden, jedoch nicht \u00f6ffentlich. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00f6ffentlich ist.
42X69=Es ist unzul\u00e4ssig, mit einem Verweisausdruck des Java-Primitive-Typs ''{1}'' auf ein Feld (''{0}'') zu verweisen.
42X72=Es wurde kein statisches Feld ''{0}'', das zur Klasse ''{1}'' geh\u00f6rt, gefunden. M\u00f6glicherweise ist das Feld vorhanden, jedoch nicht \u00f6ffentlich und/oder statisch. Es kann auch sein, dass die Klasse nicht vorhanden oder nicht \u00f6ffentlich ist. 
42X73=Die Methodenaufl\u00f6sung f\u00fcr die Signatur {0}.{1}({2}) war mehrdeutig. (Es gibt keine Methode mit maximaler Spezifik.)
42X74=Ung\u00fcltige Syntax f\u00fcr Anweisung CALL.
42X75=Es wurde kein Konstruktor mit der Signatur {0}({1}) gefunden. M\u00f6glicherweise sind die Parametertypen beim Aufruf der Methode nicht konvertierbar.
42X76=F\u00fcr mindestens eine Spalte (''{0}'') des hinzuzuf\u00fcgenden prim\u00e4ren Schl\u00fcssels besteht keine Eintragspflicht. F\u00fcr alle Spalten eines Prim\u00e4rschl\u00fcssels muss Eintragspflicht gelten.
42X77=Die Spaltenposition ''{0}'' befindet sich au\u00dferhalb des Bereichs f\u00fcr den Abfrageausdruck.
42X78=Die Spalte ''{0}'' ist nicht im Ergebnis des Abfrageausdrucks enthalten.
42X79=Der Spaltenname ''{0}'' erscheint mehr als einmal im Ergebnis des Abfrageausdrucks.
42877=Der qualifizierte Spaltenname ''{0}'' ist in der ''ORDER BY''-Klausel nicht zul\u00e4ssig.
42X80=Die VALUES-Klausel muss mindestens einen Eintrag enthalten und keiner der Eintr\u00e4ge darf leer sein. 
42X82=Die USING-Klausel hat mehr als eine Zeile zur\u00fcckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00e4ssig.
42X83=Die Integrit\u00e4tsbedingungen f\u00fcr die Spalte ''{0}'' erfordern, dass f\u00fcr die Spalte sowohl Eintragspflicht als auch keine Eintragspflicht gilt.
42X84=Der Index ''{0}'' wurde erstellt, um die Integrit\u00e4tsbedingung ''{1}'' durchzusetzen. Der Index kann nur gel\u00f6scht werden, wenn die Integrit\u00e4tsbedingung gel\u00f6scht wird.
42X85=Die Integrit\u00e4tsbedingung ''{0}'' muss sich in demselben Schema wie die Tabelle ''{1}'' befinden.
42X86=ALTER TABLE ist gescheitert. F\u00fcr die Tabelle ''{1}'' gibt es keine Integrit\u00e4tsbedingung ''{0}''. 
42X87=Mindestens ein Ergebnisausdruck (THEN oder ELSE) des Ausdrucks ''{0}'' muss ''?'' sein. 
42X88=Ein Bedingungsausdruck enth\u00e4lt einen nicht-Booleschen Operanden. Das Ergebnis der Auswertung f\u00fcr den Operanden eines Bedingungsausdrucks muss TRUE, FALSE oder UNKNOWN sein. 
42X89=Die Typen ''{0}'' und ''{1}'' sind untereinander nicht kompatibel. Keiner der Typen kann dem jeweils anderen zugeordnet werden. 
42X90=F\u00fcr die Tabelle ''{0}'' wurde mehr als eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel angegeben.
42X91=Der Integrit\u00e4tsbedingungsname ''{0}'' erscheint in der Anweisung CREATE TABLE mehr als einmal. 
42X92=Der Spaltenname ''{0}'' erscheint mehr als einmal in der Spaltenliste einer Integrit\u00e4tsbedingung.
42X93=Die Tabelle ''{0}'' enth\u00e4lt die Definition einer Integrit\u00e4tsbedingung mit der Spalte ''{1}'', die nicht in der Tabelle ist.
42Z93=Die Integrit\u00e4tsbedingungen ''{0}'' und ''{1}'' haben dieselben Spaltengruppen. Dies ist unzul\u00e4ssig. 
42Z9B=Die externe virtuelle Tabellenschnittstelle unterst\u00fctzt keine BLOB- oder CLOB-Spalten. ''{0}''-Spalte ''{1}''. 
42Z9D=''{0}''-Anweisungen sind in ''{1}''-Ausl\u00f6sern nicht zul\u00e4ssig.
42Z9D.S.1=In BEFORE-Ausl\u00f6sern sind keine Prozeduren erlaubt, die SQL-Daten modifizieren.
42Z9E=Die Integrit\u00e4tsbedingung ''{0}'' ist keine {1}-Integrit\u00e4tsbedingung.
42X94={0} ''{1}'' ist nicht vorhanden.
42X96=Der Datenbankklassenpfad enth\u00e4lt die unbekannte JAR-Datei ''{0}''.
42X98=In einer VIEW-Definition sind Parameter nicht zul\u00e4ssig.
42Y00=Die Klasse ''{0}'' implementiert nicht org.apache.derby.iapi.db.AggregateDefinition und kann deshalb nicht als Aggregatausdruck verwendet werden.
42Y01=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig.
42Y03=''{0}'' wurde nicht als Funktion oder Prozedur erkannt.
42ZA0=Anweisung zu komplex. Versuchen Sie, die Abfrage weniger komplex zu schreiben. Dieser Fehler l\u00e4sst sich h\u00e4ufig dadurch beheben, dass viele duplizierte Ausdr\u00fccke entfernt werden oder dass die Abfrage unterteilt wird und Zwischenergebnisse in einer tempor\u00e4ren Tabelle gespeichert werden.
42ZA1=Ung\u00fcltige SQL im Batch: ''{0}''


# EXTERNAL NAME is SQL keyword - do not translate
42Y04=F\u00fcr die Funktion mit EXTERNAL NAME ''{0}'' kann kein Prozedur oder Funktion erstellt werden, weil keine Liste in Schreibweise mit Trennzeichen vorliegt. Das erwartete Format ist <vollst\u00e4ndiger Java-Pfad>.<Methodenname>. 
42Y05=Es gibt keinen Fremdschl\u00fcssel mit dem Namen ''{0}''.
42Y07=Das Schema ''{0}'' ist nicht vorhanden.
42Y08=F\u00fcr Systemtabellen sind Integrit\u00e4tsbedingungen f\u00fcr Fremdschl\u00fcssel unzul\u00e4ssig.
42Y09=Void-Methoden sind nur in einer CALL-Anweisung erlaubt.
42Y10=Bei einem Tabellenkonstruktor, der nicht in einer INSERT-Anweisung enthalten ist, befinden sich alle ?-Parameter in einer der Spalten. F\u00fcr jede Spalte muss mindestens eine der Zeilen einen nichtparametrischen Wert enthalten.
42Y11=F\u00fcr die Klausel ''{0}'' ist eine Verkn\u00fcpfungsspezifikation erforderlich.
42Y12=Die ON-Klausel f\u00fcr ein JOIN ist ein Ausdruck vom Typ ''{0}''. Es muss ein Boolescher Ausdruck sein.
42Y13=Der Spaltenname ''{0}'' erscheint in der Anweisung CREATE VIEW mehr als einmal.
42Z97=Die Umbenennung der Spalte ''{0}'' verletzt die Bedingung ''{1}'' f\u00fcr die Integrit\u00e4tspr\u00fcfung.
42Z99=Ein Zeichenfolgen- oder Hexadezimalliteral darf 64 K nicht \u00fcberschreiten.
42Y16=In der Klasse ''{1}'' wurde keine \u00f6ffentliche statische Methode ''{0}'' gefunden. M\u00f6glicherweise ist die Methode vorhanden, jedoch keine \u00f6ffentliche und/oder statische Methode.  
42846=Die Typen ''{0}'' k\u00f6nnen nicht in ''{1}'' konvertiert werden.
#42Y19=''{0}'' appears multiple times in the GROUP BY list. Columns in the GROUP BY list must be unambiguous.
42Y22=Das Aggregat {0} kann nicht f\u00fcr den Typ {1} verwendet werden.
42Y23=F\u00fcr Spalte {0} wurde eine falsche JDBC-Typangabe zur\u00fcckgegeben.
42Y24=Die Ansicht ''{0}'' kann nicht aktualisiert werden. (Es ist derzeit nicht m\u00f6glich, Ansichten zu aktualisieren.) 
42Y25=''{0}'' ist eine Systemtabelle. Benutzer d\u00fcrfen den Inhalt dieser Tabelle nicht \u00e4ndern.
42Y26=Aggregate sind in der ''GROUP BY''-Liste nicht zul\u00e4ssig.
42Y27=Parameter sind in der Ausl\u00f6seaktion unzul\u00e4ssig.
42Y29=Die SELECT-Liste einer nicht gruppierten Abfrage enth\u00e4lt mindestens einen ung\u00fcltigen Ausdruck. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00e4lt, m\u00fcssen alle Eintr\u00e4ge g\u00fcltige Aggregatausdr\u00fccke sein.
42Y30=Die SELECT-Liste einer gruppierten Abfrage enth\u00e4lt mindestens einen ung\u00fcltigen Ausdruck. Eine SELECT-Liste mit GROUP BY darf nur g\u00fcltige Gruppierungsausdr\u00fccke und g\u00fcltige Aggregatausdr\u00fccke enthalten. 
42Y32=Die Aggregatorklasse ''{0}'' f\u00fcr das Aggregat ''{1}'' des Typs {2} implementiert nicht com.ibm.db2j.aggregates.Aggregator. 
42Y33=Das Aggregat {0} enth\u00e4lt ein oder mehrere Aggregat(e).
42Y34=Der Spaltenname ''{0}'' stimmt mit mehr als einer Ergebnisspalte in der Tabelle ''{1}'' \u00fcberein.
42Y35=Der Spaltenverweis ''{0}'' ist ung\u00fcltig. Wenn die SELECT-Liste mindestens ein Aggregat enth\u00e4lt, m\u00fcssen alle Eintr\u00e4ge g\u00fcltige Aggregatausdr\u00fccke sein. 
42Y36=Der Spaltenverweis ''{0}'' ist ung\u00fcltig. Eine SELECT-Liste mit GROUP BY darf nur g\u00fcltige Gruppierungsausdr\u00fccke und g\u00fcltige Aggregatausdr\u00fccke enthalten. 
42Y37=''{0}'' ist ein Java-Primitive-Typ und kann nicht mit diesem Operator verwendet werden.
42Y38=insertMode = replace ist f\u00fcr eine Einf\u00fcgung unzul\u00e4ssig, bei der sich SELECT auf die Zieltabelle ''{0}'' bezieht.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y39=''{0}'' darf nicht in einer ''CHECK CONSTRAINT''-Definition erscheinen, da dies zu unvorhersehbaren Ergebnissen f\u00fchren k\u00f6nnte.
42Y40=''{0}'' erscheint mehrfach in der Spalte UPDATE OF des Ausl\u00f6sers ''{1}''.
42Y41=''{0}'' kann nicht direkt mit EXECUTE STATEMENT aufgerufen werden, da dieses Objekt Teil eines Ausl\u00f6sers ist.
42Y42=Die Nachkommastellenangabe ''{1}'' ist keine g\u00fcltige Angabe f\u00fcr {0}.
42Y43=Die Nachkommastellenangabe ''{0}'' ist keine g\u00fcltige Angabe mit einer Genauigkeit von ''{1}''.
42Y44=In der Merkmalliste einer FROM-Liste wurde der ung\u00fcltige Schl\u00fcssel ''{0}'' angegeben. Derzeit werden folgende Schl\u00fcssel unter Beachtung der Gro\u00df-/Kleinschreibung unterst\u00fctzt: ''{1}'' 
42Y45=Der VTI ''{0}'' kann nicht gebunden werden, weil es sich um einen spezifischen Ausl\u00f6ser-VTI handelt und diese Anweisung nicht zu einer Ausl\u00f6seaktion oder WHEN-Klausel geh\u00f6rt.
42Y46=Ung\u00fcltige Merkmalliste in FROM-Liste. F\u00fcr die Tabelle ''{1}'' gibt es keinen Index ''{0}''.
42Y48=Ung\u00fcltige Merkmalliste in FROM-Liste. Entweder gibt es f\u00fcr Tabelle ''{1}'' keine benannte Integrit\u00e4tsbedingung ''{0}'' oder es gibt keinen Sicherungsindex f\u00fcr die Integrit\u00e4tsbedingung.
42Y49=F\u00fcr den Merkmalschl\u00fcssel ''{0}'' wurden mehrere Werte angegeben. 
42Y50=Die Merkmalliste f\u00fcr die Tabelle ''{0}'' darf Indexwerte oder Werte f\u00fcr Integrit\u00e4tsbedingungen enthalten, jedoch nicht beide zusammen.
42Y55=''{0}'' kann nicht f\u00fcr ''{1}'' ausgef\u00fchrt werden, da dieses Objekt nicht vorhanden ist.
42Y56=In der Merkmalliste f\u00fcr die Tabelle ''{1}'' wurde die ung\u00fcltige Verkn\u00fcpfungsstrategie ''{0}'' angegeben. Derzeit werden folgende Werte als Verkn\u00fcpfungsstrategie unterst\u00fctzt: ''hash'' und ''nestedloop''.
42Y58=Beim Konvertieren des Wertes ''{0}'' f\u00fcr den vorrangigen Optimizer-Wert ''{1}'' ist eine NumberFormatException eingetreten.
42Y59=F\u00fcr das \u00dcberschreiben von hashInitialCapacity wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss gr\u00f6\u00dfer als 0 sein.
42Y60=F\u00fcr das \u00dcberschreiben von hashLoadFactor wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss gr\u00f6\u00dfer als  0.0 und kleiner als oder gleich 1.0 sein.
42Y61=F\u00fcr das \u00dcberschreiben von hashMaxCapacity wurde der ung\u00fcltige Wert ''{0}'' angegeben. Der Wert muss gr\u00f6\u00dfer als 0 sein.
42Y62=''{0}'' ist f\u00fcr ''{1}'' nicht zul\u00e4ssig, weil es sich um eine Ansicht handelt.
42Y63=Eine Hash-Verkn\u00fcpfung erfordert ein optimierbares equijoin-Pr\u00e4dikat f\u00fcr eine Spalte im ausgew\u00e4hlten Index oder Heap-Speicher. Die Tabelle bzw. der Index ''{0}'' enth\u00e4lt f\u00fcr keine Spalte ein optimierbares equijoin-Pr\u00e4dikat. Verwenden Sie den vorrangigen Optimizer-Wert ''index'', um einen Index oder Heap-Speicher f\u00fcr die Tabelle ''{1}'' anzugeben.
42Y64=Der bulkFetch-Wert ''{0}'' ist ung\u00fcltig. der Mindestwert f\u00fcr bulkFetch ist 1.
42Y65=bulkFetch ist f\u00fcr ''{0}''-Verkn\u00fcpfungen nicht zul\u00e4ssig.
42Y66=bulkFetch ist f\u00fcr aktualisierbare Cursor nicht zul\u00e4ssig. 
42Y67=Das Schema ''{0}'' kann nicht gel\u00f6scht werden.
42Y69=F\u00fcr diese Anweisung wurde kein g\u00fcltiger Ausf\u00fchrungsplan gefunden. Dies kann eine der beiden folgenden Ursachen haben: Sie haben eine Hash-Verkn\u00fcpfungsstrategie angegeben, obwohl keine Hash-Verkn\u00fcpfung erlaubt ist (kein optimierbares equijoin) oder Sie versuchen, zwei externe virtuelle Tabellen zu verkn\u00fcpfen, die jeweils aufeinander verweisen, so dass die Anweisung nicht ausgewertet werden kann.

42Y70=Der Benutzer hat eine unzul\u00e4ssige Verkn\u00fcpfungsreihenfolge angegeben. Dies kann daran liegen, dass eine zu verkn\u00fcpfende Spalte einer inneren Tabelle als Parameter an eine \u00e4u\u00dfere virtuelle Tabelle \u00fcbergeben wird.
42Y71=Die Systemfunktion oder Prozedur ''{0}'' kann nicht gel\u00f6scht werden.
42Y82=Die vom System generierte gespeicherte vorbereitete Anweisung ''{0}'' kann mit DROP STATEMENT nicht gel\u00f6scht werden. Sie geh\u00f6rt zu einem Ausl\u00f6ser.

42Y83=Eine Nullangabe ohne Typ ist kein zul\u00e4ssiges Argument f\u00fcr das Aggregat {0}. Setzen Sie die Nullangabe in einen geeigneten Typ um.
# NOTE: The parameter to this message is a keyword used as a noun phrase.
# Some possible values are "subquery", "CurrentDate", and "?".
42Y84=''{0}'' darf in einer DEFAULT-Definition nicht erscheinen.
42Y85=Das Schl\u00fcsselwort DEFAULT ist in einer VALUES-Klausel nur zul\u00e4ssig, wenn die VALUES-Klausel in einer INSERT-Anweisung erscheint.
42Y90=FOR UPDATE ist f\u00fcr diesen Anweisungstyp unzul\u00e4ssig. 
42Y91=Die USING-Klausel ist in EXECUTE STATEMENT f\u00fcr eine Ausl\u00f6seaktion nicht zul\u00e4ssig.
42Y92={0}-Ausl\u00f6ser k\u00f6nnen nur auf \u00dcbergangsvariablen/Tabellen des Typs {1} Bezug nehmen.
42Y93=Ung\u00fcltige REFERENCING-Klausel: F\u00fcr jede Art von \u00dcbergangsvariable/-tabelle ist nur ein Name zul\u00e4ssig.
42Y94=Ein AND oder OR verwendet einen nicht-Booleschen Operanden. Das Ergebnis der Auswertung f\u00fcr die Operanden von AND und OR muss TRUE, FALSE oder UNKNOWN sein.

42Y95=Der Operator ''{0}'' mit dem linken Operanden vom Typ ''{1}'' und dem rechten Operanden vom Typ ''{2}'' wird nicht unterst\u00fctzt.
42Y96.U=UNKNOWN
42Y97=Ung\u00fcltiges Escape-Zeichen in Zeile ''{0}'', Spalte ''{1}''.
42Y98.U=In Zeile {1}, Spalte {2}, wurde "{0}" gefunden
42Y99.U=Lexikalischer Fehler in Zeile {0}, Spalte {1}. Festgestellt wurde: {2}
42Z00.U=Java-Methodenaufruf oder Feldverweis
# This message is put into message 42X75 when a parameter doesn't have a
# datatype. For example, from the parameterWidening test:
#
# values (java.lang.Integer::toString(?, null));
# ERROR 42X50: No method was found with the signature
# java.lang.Integer.toString(UNTYPED, UNTYPED).  It may be that the method
# exists, but it is not public and/or static, or that the parameter types
# are not method invocation convertible.
42Z01.U=UNTYPED
42Z02=Mehrere DISTINCT-Aggregate werden zur Zeit nicht unterst\u00fctzt.
42Z07=Aggregate sind in der ON-Klausel nicht erlaubt.
42Z08=F\u00fcr ''{0}'' gibt es einen aktivierten Ausl\u00f6ser ({1}). Eine Ersetzung durch Masseneinf\u00fcgung ist deshalb unzul\u00e4ssig.
42Z09.U=COLUMN DEFAULT f\u00fcr
#
# The following message is used in error messages where we want to say that
# certain operations on streams are illegal. The word "stream" is not a
# keyword or method name, so it should be translated.
42Z11.U=Datenstrom

# alter table modify column error messages.
#####
42Z15=F\u00fcr die Spalte ''{0}'' wurde ein ung\u00fcltiger Typ angegeben. Der Typ einer Spalte kann nicht ge\u00e4ndert werden.

42Z16=Die L\u00e4nge kann nur f\u00fcr Spalten des Typs VARCHAR ge\u00e4ndert werden. 
42Z17=F\u00fcr die Spalte ''{0}'' wurde eine ung\u00fcltige L\u00e4nge angegeben. Der L\u00e4ngenwert muss gr\u00f6\u00dfer als die aktuelle Spaltenl\u00e4nge sein.
42Z18=Die Spalte ''{0}'' geh\u00f6rt zur Integrit\u00e4tsbedingung ''{1}'' f\u00fcr Fremdschl\u00fcssel. Wenn Sie die L\u00e4nge dieser Spalte \u00e4ndern m\u00f6chten, sollten Sie zun\u00e4chst die Integrit\u00e4tsbedingung l\u00f6schen. F\u00fchren Sie dann ALTER TABLE aus und erstellen Sie die Integrit\u00e4tsbedingung neu.
42Z19=Die Spalte ''{0}'' wird von mindestens einer Integrit\u00e4tsbedingung ''{1}'' f\u00fcr Fremdschl\u00fcssel referenziert. Wenn Sie die L\u00e4nge dieser Spalte \u00e4ndern m\u00f6chten, sollten Sie zun\u00e4chst die verweisenden Integrit\u00e4tsbedingungen l\u00f6schen. F\u00fchren Sie dann ALTER aus und erstellen Sie die Integrit\u00e4tsbedingungen neu.

42Z20=Die Eintragspflicht f\u00fcr die Spalte ''{0}'' kann nicht aufgehoben werden. Sie geh\u00f6rt zu einem Prim\u00e4rschl\u00fcssel oder einer eindeutigen Integrit\u00e4tsbedingung, der bzw. die keine Spalten ohne Eintragspflicht enthalten darf.

#####
# end of alter table modify constraints.
# identity error message (from 42Z21-42Z29)
#####
42837=ALTER TABLE ''{0}'' gibt Attribute f\u00fcr die Spalte ''{1}'' an, die nicht mit der vorhandenen Spalte kompatibel sind.
42Z21=F\u00fcr die Identit\u00e4t der Spalte ''{0}'' wurde ein ung\u00fcltiges Inkrement angegeben. Das Inkrement muss ungleich null sein. 
42Z22=F\u00fcr die Identit\u00e4tsspalte ''{0}'' wurde ein ung\u00fcltiger Typ angegeben. F\u00fcr Identit\u00e4tsspalten sind nur die Typen BIGINT, INT und SMALLINT g\u00fcltig.
42Z23=Es wurde versucht, die Identit\u00e4tsspalte ''{0}'' zu \u00e4ndern. 
42Z24=Beim Identit\u00e4tswert f\u00fcr die Spalte ''{1}'' in der Tabelle ''{0}'' ist es zu einem \u00dcberlauf gekommen.
42Z25=INTERNER FEHLER beim Identit\u00e4tsz\u00e4hler. UPDATE wurde ohne Argumente mit dem aktuellen Wert \= NULL aufgerufen.
42Z26=F\u00fcr die Spalte ''{0}'' mit einer Standardidentit\u00e4t kann die Eintragspflicht nicht aufgehoben werden.
42Z27=F\u00fcr die Spalte ''{0}'' ohne Eintragspflicht kann keine Standardidentit\u00e4t festgelegt werden.

#####
# end of identity error messages.

42Z30.U=Zeit f\u00fcr dieses ResultSet =
42Z31.U=Zeit f\u00fcr dieses ResultSet und folgende =
42Z32.U=Aufschl\u00fcsselung der Gesamtzeit:

42Z33.U=Konstruktorzeit (Millisekunden) =
42Z34.U=Zeit f\u00fcr open (Millisekunden) =
42Z35.U=Zeit f\u00fcr next (Millisekunden) =
42Z36.U=Zeit f\u00fcr close (Millisekunden) =
42Z37.U=Keine
42Z38.U=Es ist keine Positionierungsangabe verf\u00fcgbar, weil dieses ResultSet nie ge\u00f6ffnet wurde.
42Z39.U=Unerwartete Ausnahme {0} beim Anfordern des Positionierers.
## NOTE: In the following message, {0} will be either >= or >
42Z40.U={0} f\u00fcr die ersten {1} Spalten.
42Z41.U=Semantik mit Nullsortierung in den folgenden Spalten:

42Z42.U=Spalten-ID
42Z43.U=Operator
42Z44.U=Nullsortierung
42Z45.U=Unbekannter R\u00fcckgabewert
42Z46.U=Vergleichsergebnis negieren
42Z47.U=Das Abrufen des Abfrageplans als Zeichenfolge wird derzeit f\u00fcr {0} nicht unterst\u00fctzt
## NOTE: In the following message, {0} and {1} are integer indexes into a 2-d array
42Z48.U=ID f\u00fcr Spalte [{0}][{1}]

# matches DB2
42939=Mit dem Schemanamen ''{0}'' kann kein Objekt erstellt werden.




42Z50=INTERNER FEHLER: F\u00fcr {0} kann kein Code generiert werden.
42Z53=INTERNER FEHLER: Der f\u00fcr die Knotenauswahl {0} zu generierende Aktivierungstyp ist unbekannt.
42Z54.U=Diese Ausnahme stoppt die Anweisung nach der Syntaxanalyse. Es ist keine weitere Verarbeitung erforderlich.
42Z55.U=Die Ausf\u00fchrung wurde nach der Syntaxanalyse von der Debug-Markierung StopAfterParsing gestoppt.
42Z56.U=Die Ausf\u00fchrung wurde nach der Bindung von der Debug-Markierung StopAfterBinding gestoppt.
42Z57.U=Die Ausf\u00fchrung wurde nach der Optimierung von der Debug-Markierung StopAfterOptimizing gestoppt.
42Z58.U=Die Ausf\u00fchrung wurde nach der Generierung von der Debug-Markierung StopAfterGenerating gestoppt.

42Z60={0} ist nur zul\u00e4ssig, wenn das Datenbankmerkmal {1} den Wert ''{2}'' hat.

# Derby-specific XML compile errors (42Z70 - 42Z7Z)
42Z70=Die direkte Bindung an einen XML-Wert ist nicht zul\u00e4ssig. Versuchen Sie, XMLPARSE zu verwenden.
42Z71=In Ergebnislisten der Ausgangsebene sind keine XML-Werte zul\u00e4ssig. Versuchen Sie, XMLSERIALIZE zu verwenden.
42Z72=Fehlende SQL/XML-Schl\u00fcsselw\u00f6rter ''{0}'' in Zeile {1}, Spalte {2}
42Z73=Ung\u00fcltiger Zieltyp f\u00fcr XMLSERIALIZE: ''{0}''.
42Z74=Nicht unterst\u00fctztes XML-Feature: ''{0}''.
42Z75=Ein XML-Abfrageausdruck muss ein Zeichenfolgenliteral sein.
42Z76=Mehrere XML-Kontextelemente sind unzul\u00e4ssig.
42Z77=Ein Kontextelement muss vom Typ ''XML'' sein. ''{0}'' ist unzul\u00e4ssig.
42Z79=Der Parametertyp f\u00fcr XMLPARSE kann nicht bestimmt werden. Versuchen Sie, ein CAST zu verwenden.

## More RUNTIMESTATISTICS messages
42Z80.U=SERIALIZABLE
42Z81.U=READ COMMITED
42Z82.U=EXCLUSIVE
42Z83.U=INSTANTANEOUS SHARE
42Z84.U=SHARE
42Z85.U=TABLE
42Z86.U=ROW
42Z87.U=SHARE TABLE
42Z88.U=SHARE ROW

# More generic language stuff
42Z90=Die Klasse ''{0}'' gibt kein aktualisierbares ResultSet zur\u00fcck.
42Z91=Unterabfrage
42Z92=wiederholbares Lesen
42Z9A=unbest\u00e4tigtes Lesen

# Declare global temporary table language stuff. Matches DB2
428EK=Das Qualifikationsmerkmal f\u00fcr eine deklarierte globale tempor\u00e4re Tabelle muss SESSION sein.
42995=Die angeforderte Funktion ist nicht auf globale tempor\u00e4re Tabellen anwendbar.
42962=Die LOB-Spalte oder der Parameter ''{0}'' ist in deklarierten globalen tempor\u00e4ren Tabellen oder Prozedurdefinitionen nicht zul\u00e4ssig. 

## org.apache.derby.impl.sql.execute.rts
43X00.U=Zugeordnet zu
43X01.U=Nummer der ersten Unterabfrage
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X02.U=ANY-ResultSet
43X03.U=Anzahl der \u00d6ffnungsvorg\u00e4nge
43X04.U=Gesehene Zeilen
43X05.U=Quellenergebnisliste
43X06.U=Nummer der letzten Unterabfrage
43X07.U=Vom Optimizer gesch\u00e4tzte Zeilenzahl
43X08.U=Vom Optimizer gesch\u00e4tzte Kosten
43X09.U=Sekunden
43X10.U=Summe
43X11.U=Knoten
43X12.U={0} ist derzeit nicht f\u00fcr {1} implementiert.
# NOTE: In this case, the name of the type of ResultSet is "Any". ResultSet
# is the name of an interface, so it should not be translated.
43X13.U=DELETE-ResultSet mit
43X14.U=Tabelle wird gesperrt
43X15.U=Zeile wird gesperrt
43X16.U=verz\u00f6gert
43X17.U=Gel\u00f6schte Zeilen
43X18.U=Aktualisierte Indizes
43X19.U=L\u00f6schen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X20.U=ResultSet f\u00fcr spezifisches skalares Aggregat
# NOTE: In this message, "input" is being used as a verb
43X21.U=Eingegebene Zeilen
43X22.U=Spezifisches skalares Aggregat
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X23.U=ResultSet der spezifischen Suche f\u00fcr {0} unter Verwendung von {1} {2}
43X24.U=Integrit\u00e4tsbedingung
43X25.U=Index
43X26.U=ResultSet der spezifischen Suche f\u00fcr {0}
#NOTE: In this message, {0} will be something like "serializable" or "read
# committed", and {1} will be something like "share" or "exclusive".
43X27.U=auf der Isolationsstufe {0} unter Verwendung einer Sperre des Typs {1}
43X28.U=Suchinformationen
43X29.U=Die spezifische Spalte hat die Nummer
43X30.U=Die spezifischen Spalten haben die Nummern
43X31.U=Gr\u00f6\u00dfe der Hash-Tabelle
43X32.U=Gefilterte Zeilen
43X33.U=Zeit f\u00fcr next in Millisekunden/Zeile
43X34.U=Anfangspunkt
43X35.U=Endpunkt
43X36.U=Qualifikationsmerkmale f\u00fcr Suche
#NOTE: The message means the set of qualifiers that filter rows returned
# by the "next" operation, not the set of qualifiers that come next.
43X37.U=Qualifikationsmerkmale f\u00fcr next
#NOTE: In this message, {0} is a table name and {1} is an index name
43X38.U=f\u00fcr {0} mit {1}
43X39.U=Spezifische Suche
43X40.U=Sortierungsinformationen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X41.U=ResultSet f\u00fcr gruppiertes Aggregat
43X42.U=mit spezifischem Aggregat
43X43.U=In sortierter Reihenfolge
43X44.U=Gruppiertes Aggregat
43X45.U=EXISTS-Verkn\u00fcpfung f\u00fcr Hash-Eintr\u00e4ge
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X46.U=ResultSet f\u00fcr EXISTS-Verkn\u00fcpfung von Hash-Eintr\u00e4gen
43X47.U=Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X48.U=ResultSet f\u00fcr Verkn\u00fcpfung von Hash-Eintr\u00e4gen
43X49.U=Nach links erweiterte Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X50.U=ResultSet f\u00fcr nach links erweiterte Verkn\u00fcpfung von Hash-Eintr\u00e4gen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {1} is either "constraint" or "index", {0} is a table name, and {2} is a
# constraint or index name.
43X51.U=ResultSet der Hash-Suche f\u00fcr {0} unter Verwendung von {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X52.U=ResultSet der Hash-Suche f\u00fcr {0}
43X53.U=Der Hash-Schl\u00fcssel ist die Spaltennummer
43X54.U=Die Hash-Schl\u00fcssel sind die Spaltennummern
43X55.U=Hash-Suche
43X56.U=Zugeordnete Unterabfragen
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X57.U=ResultSet f\u00fcr Hash-Tabelle
43X58.U=Hash-Tabelle
43X59.U=alle
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X60.U=ResultSet Indexzeile zu Basiszeile f\u00fcr {0}
43X61.U=Heap-Spalten, auf die zugegriffen wurde
#NOTE: {0} is a table name
43X62.U=f\u00fcr {0}
43X63.U=Indexzeile zu Basiszeile
43X64.U=Einf\u00fcgemodus: Einf\u00fcgen von Massendaten
43X65.U=Einf\u00fcgemodus: normal (das Einf\u00fcgen von Massendaten ist nicht m\u00f6glich, da die Tabelle nicht leer ist)
43X66.U=Einf\u00fcgemodus: normal
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X67.U=INSERT-ResultSet mit
43X68.U=Eingef\u00fcgte Zeilen
43X69.U=Einf\u00fcgen
43X70.U=Verkn\u00fcpfung
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43X71.U=ResultSet der letzten Schl\u00fcsselindexsuche f\u00fcr {0} unter Verwendung von Index {1}
43X72.U=bei Isolationsstufe {0} mit {1}-Sperrung wurde vom Optimizer ausgew\u00e4hlt
43X73.U=Tabellensuche
43X74.U=Indexsuche
#NOTE: {0} is a table name or class name
43X75.U=f\u00fcr {0}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X76.U=Gespeichertes ResultSet
43X77.U=Erstellungszeit f\u00fcr tempor\u00e4res Konglomerat (Millisekunden)
43X78.U=Abrufzeit f\u00fcr tempor\u00e4res Konglomerat (Millisekunden)
43X79.U=Gesehene Zeilen von links
43X80.U=Gesehene Zeilen von rechts
43X81.U=Zur\u00fcckgegebene Zeilen
43X82.U=Linke Ergebnisliste
43X83.U=Rechte Ergebnisliste
43X84.U=Verkn\u00fcpfung \u00fcber vorhandene verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X85.U=ResultSet f\u00fcr Verkn\u00fcpfung \u00fcber vorhandene verschachtelte Schleife
43X86.U=Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X87.U=ResultSet f\u00fcr Verkn\u00fcpfung \u00fcber verschachtelte Schleife
43X88.U=Zur\u00fcckgegebene leere rechte Zeilen
43X89.U=Nach links erweiterte Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X90.U=ResultSet f\u00fcr nach links erweiterte Verkn\u00fcpfung \u00fcber verschachtelte Schleife
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X91.U=ResultSet normalisieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X92.U=Einzelwert-ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X93.U=ResultSet f\u00fcr eingeschr\u00e4nkte Projektion
43X94.U=Einschr\u00e4nkung
43X95.U=Projektion
43X96.U=Einschr\u00e4nkungszeit (Millisekunden)
43X97.U=Projektionszeit (Millisekunden)
43X98.U=Eingeschr\u00e4nkte Projektion
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43X99.U=Zeilen-ResultSet
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y00.U=ResultSet f\u00fcr skalares Aggregat
43Y01.U=Optimierung f\u00fcr Indexschl\u00fcssel
43Y02.U=Skalares Aggregat
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y03.U=Scroll-insensitives ResultSet
43Y04.U=Anzahl der Lesevorg\u00e4nge in der Hash-Tabelle
43Y05.U=Anzahl der Schreibvorg\u00e4nge in der Hash-Tabelle
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y06.U=ResultSet f\u00fcr Sortierung
43Y07.U=Duplikate eliminieren
43Y08.U=Sortieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name, {1} is either "constraint" or "index", {2} is a
# constraint or index name.
43Y09.U=ResultSet der Indexsuche f\u00fcr {0} unter Verwendung von {1} {2}
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a table name.
43Y10.U=ResultSet der Tabellensuche f\u00fcr {0}
43Y11.U=Tats\u00e4chlich verwendete Sperrung: Sperrung auf Tabellenebene.
43Y12.U=Abrufgr\u00f6\u00dfe
43Y13.U=Qualifikationsmerkmale
# NOTE: ResultSet is the name of an interface, so it should not be translated.
43Y14.U=ResultSet f\u00fcr Gesamtverkn\u00fcpfung
43Y15.U=Gesamtverkn\u00fcpfung
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is either "table" or "row"
43Y16.U=ResultSet mit Sperrung f\u00fcr {0} aktualisieren
43Y17.U=Aktualisierte Zeilen
43Y18.U=Aktualisieren
# NOTE: ResultSet is the name of an interface, so it should not be translated.
# {0} is a Java class name.
43Y19.U=VTI-ResultSet f\u00fcr {0}
43Y20.U=VTI
43Y21.U=Einbezogene Unterabfragen
43Y22.U=Name der Anweisung
43Y23.U=Text der Anweisung
# NOTE: This means the amount of time it takes to parse
43Y24.U=Zeit f\u00fcr Syntaxanalyse
# NOTE: This means the amount of time it takes to bind
43Y25.U=Bindezeit
# NOTE: This means the amount of time it takes to optimize
43Y26.U=Optimierungszeit
# NOTE: This means the amount of time it takes to generate
43Y27.U=Generierungszeit
# NOTE: This means the amount of time it takes to compile
43Y28.U=Kompilierzeit
# NOTE: This means the amount of time it takes to execute
43Y29.U=Ausf\u00fchrungszeit
43Y30.U=Anfangszeitmarke der Kompilierung
43Y31.U=Endzeitmarke der Kompilierung
43Y32.U=Anfangszeitmarke der Ausf\u00fchrung
43Y33.U=Endzeitmarke der Ausf\u00fchrung
43Y44.U=Text des Plans f\u00fcr die Anweisungsausf\u00fchrung
43Y45.U=Laufzeit 100 %, {0} Sekunden
43Y46.U=ResultSet f\u00fcr VTI einf\u00fcgen
43Y47.U=ResultSet f\u00fcr VTI l\u00f6schen
43Y49.U=VTI einf\u00fcgen
43Y50.U=VTI l\u00f6schen
43Y51.U=ResultSet f\u00fcr mehrstufiges L\u00f6schen
43Y52.U=ResultSet f\u00fcr mehrstufiges L\u00f6schen mit
43Y53.U=Referenzielle Aktionen f\u00fcr abh\u00e4ngige Tabellen
43Y54.U=Referenzielle Aktion f\u00fcr abh\u00e4ngige Tabelle beginnen
43Y55.U=Referenzielle Aktion f\u00fcr abh\u00e4ngige Tabelle beenden
43Y56.U=Der Benutzer hat f\u00fcr {0} folgende vorrangigen Optimizer-Werte angegeben: {1}
43Y57.U=Der Benutzer hat f\u00fcr join folgende vorrangigen Optimizer-Werte angegeben: {0}
43Y58.U=Intersect ResultSet
43Y59.U=Intersect
43Y60.U=Except ResultSet
43Y61.U=Except
	
54004=Die Anweisung SELECT enth\u00e4lt zu viele Elemente in GROUP BY, ORDER BY oder in der Auswahlliste.
54008=Die Anweisung CREATE INDEX gibt zu viele Spalten an. (Das Maximum liegt bei 16.)
54023=Die maximale Anzahl von Parametern f\u00fcr eine Prozedur wurde \u00fcberschritten. Die Begrenzung liegt bei {0} und die Anzahl der Parameter f\u00fcr die Prozedur {1} ist {2}.
54038=Die maximale Verschachtelungstiefe f\u00fcr Ausl\u00f6ser wurde \u00fcberschritten.

## all other org.apache.derby.catalog.types
44X00.U=Name des SQL-Typs
44X05.U=n\u00e4chster Fehler

X0A00.S=Die Auswahlliste enth\u00e4lt zweimal die Spalte ''{0}''. In Abfragen mit der Klausel GROUP BY oder HAVING ist dies nicht zul\u00e4ssig. Verwenden Sie f\u00fcr eine der in Konflikt stehenden Spalten einen Aliasnamen, um eindeutige Spaltennamen zu erhalten.

X0X02.S=Die Tabelle ''{0}'' kann nicht im Modus ''{1}'' gesperrt werden.
X0X03.S=Ung\u00fcltiger Transaktionsstatus. Der gehaltene Cursor erfordert dieselbe Isolationsstufe.
X0X05.S=Die Tabelle/Ansicht ''{0}'' ist nicht vorhanden.
X0X0E.S=Die im automatisch generierten Spaltenauswahl-Array aufgelistete Spaltenposition ''{0}'' wurde in der Einf\u00fcgetabelle nicht gefunden. 
X0X0F.S=Der im automatisch generierten Spaltenauswahl-Array aufgelistete Spaltenname ''{0}'' wurde in der Einf\u00fcgetabelle nicht gefunden.
X0X07.S=Die JAR-Datei ''{0}'' kann nicht entfernt werden, weil sie im derby.database.classpath ''{0}'' enthalten ist.
X0X10.S=Die USING-Klausel hat mehr als eine Zeile zur\u00fcckgegeben. Es sind nur aus einer Zeile bestehende ResultSets zul\u00e4ssig.
X0X11.S=Die USING-Klausel hat keine Ergebnisse geliefert. Es k\u00f6nnen keine Parameter gesetzt werden. 
X0X13.S=Die JAR-Datei ''{0}'' ist nicht im Schema ''{1}'' enthalten.
X0X57.S=Es wurde versucht, einen Java-Wert vom Typ ''{0}'' in einen SQL-Wert aufzunehmen. Es ist jedoch kein entsprechender SQL-Typ vorhanden. Der Java-Wert ist wahrscheinlich das Ergebnis eines Methodenaufrufs oder Feldzugriffs.
X0X60.S=Ein Cursor mit dem Namen ''{0}'' ist bereits vorhanden.
X0X61.S=Die Werte f\u00fcr die Spalte ''{4}'' im Index ''{0}'' und in der Tabelle ''{1}.{2}'' passen nicht zur Zeilenposition {3}. Der Wert im Index ist ''{5}'' und der Wert in der Basistabelle ist ''{6}''. Der vollst\u00e4ndige Indexschl\u00fcssel mit der Zeilenposition ist ''{7}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0X62.S=Die Tabelle ''{0}'' und der Index ''{1}'' sind inkonsistent. Bei dem Versuch, die Zeilenposition ''{2}'' aus der Tabelle abzurufen, ist ein Fehler aufgetreten. Der vollst\u00e4ndige Indexschl\u00fcssel mit der Zeilenposition ist ''{3}''. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0X63.S=IOException ''{0}'' empfangen.
X0X67.S=Spalten des Typs ''{0}'' k\u00f6nnen in den Anweisungen CREATE INDEX, ORDER BY, GROUP BY, UNION, INTERSECT, EXCEPT oder DISTINCT nicht verwendet werden, da f\u00fcr diesen Typ keine Vergleiche unterst\u00fctzt werden.
X0X81.S={0} ''{1}'' ist nicht vorhanden.
X0X85.S=Der Index ''{0}'' wurde nicht erstellt, weil ''{1}'' kein g\u00fcltiger Indextyp ist.
X0X86.S=0 ist ein ung\u00fcltiger Parameterwert f\u00fcr ResultSet.absolute(int row).
X0X87.S=ResultSet.relative(int row) kann nicht aufgerufen werden, wenn sich der Cursor nicht in einer Zeile befindet.
X0X95.S=Die Operation ''{0}'' kann f\u00fcr das Objekt ''{1}'' nicht ausgef\u00fchrt werden, weil es ein offenes ResultSet gibt, das von diesem Objekt abh\u00e4ngig ist.
X0X99.S=Der Index ''{0}'' ist nicht vorhanden.

X0Y16.S=''{0}'' ist keine Ansicht. Falls es sich um eine Tabelle handelt, verwenden Sie DROP TABLE.
X0Y23.S=Die Operation ''{0}'' kann f\u00fcr das Objekt ''{1}'' nicht ausgef\u00fchrt werden, weil die Ansicht ''{2}'' von diesem Objekt abh\u00e4ngt.
X0Y24.S=Die Operation ''{0}'' kann f\u00fcr das Objekt ''{1}'' nicht ausgef\u00fchrt werden, weil die Anweisung ''{2}'' von diesem Objekt abh\u00e4ngt.
X0Y25.S=Die Operation ''{0}'' kann f\u00fcr das Objekt ''{1}'' nicht ausgef\u00fchrt werden, weil die {2} ''{3}'' von diesem Objekt abh\u00e4ngt.
X0Y26.S=Der Index ''{0}'' muss sich in demselben Schema wie die Tabelle ''{1}'' befinden.
X0Y28.S=Der Index ''{0}'' kann f\u00fcr die Systemtabelle ''{1}'' nicht erstellt werden. Benutzer k\u00f6nnen keine Indizes f\u00fcr Systemtabellen erstellen.
# column c already exists in table t.
X0Y32.S={0} ''{1}'' ist bereits in {2} ''{3}'' vorhanden.
X0Y38.S=Der Index ''{0}'' kann nicht erstellt werden, weil die Tabelle ''{1}'' nicht vorhanden ist.
X0Y41.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig, weil die referenzierte Tabelle {1} keinen Prim\u00e4rschl\u00fcssel hat. F\u00fcgen Sie einen Prim\u00e4rschl\u00fcssel zu {1} hinzu oder geben Sie explizit die Spalten einer eindeutigen Integrit\u00e4tsbedingung an, auf die dieser Fremdschl\u00fcssel verweist. 
X0Y42.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die Spalten des Fremdschl\u00fcssels stimmen vom Typ her nicht mit den referenzierten Spalten \u00fcberein.
X0Y43.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die Anzahl der Spalten in {0}({1}) stimmt nicht mit der Anzahl der Spalten im referenzierten Schl\u00fcssel ({2}) \u00fcberein.
X0Y44.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: in der Tabelle ''{1}'' gibt es keine Integrit\u00e4tsbedingung f\u00fcr eindeutige oder Prim\u00e4rschl\u00fcssel, die nach Anzahl und Typ der Spalten mit dem Fremdschl\u00fcssel \u00fcbereinstimmt.
X0Y45.S=Die Integrit\u00e4tsbedingung ''{0}'' f\u00fcr Fremdschl\u00fcssel kann nicht zur Tabelle {1} hinzugef\u00fcgt oder f\u00fcr die Tabelle aktiviert werden, weil es f\u00fcr einen oder mehrere Fremdschl\u00fcssel keine \u00fcbereinstimmenden referenzierten Schl\u00fcssel gibt. 
X0Y46.S=Die Integrit\u00e4tsbedingung ''{0}'' ist ung\u00fcltig: die referenzierte Tabelle {1} ist nicht vorhanden.
X0Y54.S=Das Schema ''{0}'' kann nicht gel\u00f6scht werden, weil es nicht leer ist.
X0Y55.S=Die Zeilenanzahl in der Basistabelle stimmt nicht mit der Zeilenanzahl in mindestens einem der Indizes f\u00fcr die Tabelle \u00fcberein. Der Index ''{0}'' f\u00fcr Tabelle ''{1}.{2}'' hat {3} Zeilen, die Basistabelle jedoch {4} Zeilen. Zur Fehlerberichtigung wird empfohlen, den Index erneut zu erstellen.
X0Y56.S=''{0}'' ist f\u00fcr die Systemtabelle ''{1}'' unzul\u00e4ssig.
X0Y57.S=Eine Spalte mit nicht aufhebbarer Eintragspflicht kann nicht zur Tabelle ''{0}'' hinzugef\u00fcgt werden, weil die Tabelle mindestens eine Zeile enth\u00e4lt. Spalten mit nicht aufhebbarer Eintragspflicht k\u00f6nnen nur zu leeren Tabellen hinzugef\u00fcgt werden.
X0Y58.S=Der Versuch, zur Tabelle ''{0}'' eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel hinzuzuf\u00fcgen, ist gescheitert, weil es f\u00fcr die Tabelle bereits eine Integrit\u00e4tsbedingung dieses Typs gibt. F\u00fcr eine Tabelle kann es nur eine Integrit\u00e4tsbedingung f\u00fcr Prim\u00e4rschl\u00fcssel geben.
X0Y59.S=Der Versuch, Integrit\u00e4tsbedingungen zur Tabelle ''{1}'' hinzuzuf\u00fcgen bzw. f\u00fcr die Tabelle zu aktivieren, ist gescheitert, weil die Tabelle {2} Zeile(n) enth\u00e4lt, die die folgende(n) zu pr\u00fcfende(n) Integrit\u00e4tsbedingung(en) verletzt bzw. verletzen: {0}.
X0Y63.S=Der Befehl f\u00fcr die Tabelle ''{0}'' ist gescheitert, weil im Prim\u00e4rschl\u00fcssel oder den Spalten der eindeutigen Integrit\u00e4tsbedingung bzw. des Index Nulldaten gefunden wurden. Alle Spalten eines prim\u00e4ren oder eindeutigen Indexschl\u00fcssels m\u00fcssen ungleich null sein. 
X0Y66.S=In einer verschachtelten Verbindung kann keine COMMIT-Operation abgesetzt werden, solange es eine anstehende Operation in der \u00fcbergeordneten Verbindung gibt.
X0Y67.S=In einer verschachtelten Verbindung kann keine ROLLBACK-Operation abgesetzt werden, solange es eine anstehende Operation in der \u00fcbergeordneten Verbindung gibt.
X0Y68.S={0} ''{1}'' ist bereits vorhanden.
X0Y69.S={1} wird im Ausl\u00f6ser {0} nicht unterst\u00fctzt.
X0Y70.S=INSERT, UPDATE und DELETE sind f\u00fcr die Tabelle {1} unzul\u00e4ssig, weil der Ausl\u00f6ser {0} aktiv ist.
X0Y71.S=Eine Transaktionsbearbeitung wie SET ISOLATION ist unzul\u00e4ssig, weil der Ausl\u00f6ser {0} aktiv ist.
X0Y72.S=F\u00fcr ''{0}'' gibt es einen aktivierten Ausl\u00f6ser ({1}). Eine Ersetzung durch Masseneinf\u00fcgung ist deshalb unzul\u00e4ssig.
X0Y77.S=Die Anweisung set transaction isolation kann nicht f\u00fcr eine laufende globale Transaktion abgesetzt werden, weil die globale Transaktion damit implizit festgeschrieben werden w\u00fcrde.
X0Y78.S=Statement.executeQuery() kann nicht mit einer Anweisung ausgef\u00fchrt werden, die eine Zeilenanzahl zur\u00fcckgibt.
X0Y78.S.1={0}.executeQuery() kann nicht aufgerufen werden, weil mehrere Ergebnislisten zur\u00fcckgegeben wurden. Verwenden Sie zum Abrufen mehrerer Ergebnisse {1}.execute().
X0Y78.S.2={0}.executeQuery() wurde aufgerufen. Es wurde jedoch keine Ergebnisliste zur\u00fcckgegeben. Verwenden Sie f\u00fcr Nicht-Abfragen {1}.executeUpdate().
X0Y79.S=Statement.executeUpdate() kann nicht mit einer Anweisung ausgef\u00fchrt werden, die ein ResultSet zur\u00fcckgibt.
X0Y80.S=ALTER ist f\u00fcr die Tabelle ''{0}'' gescheitert. In der Spalte ''{1}'' wurden Nulldaten gefunden.
X0Y83.S=WARNUNG: Beim L\u00f6schen einer Zeile aus einer Tabelle wurde die Indexzeile f\u00fcr die Zeile {0} der Basistabelle im Index mit der Konglomerat-ID {1} nicht gefunden. Dieser Fehler wurde automatisch im Rahmen der L\u00f6schoperation behoben.
XCL01.S=Die Ergebnisliste gibt keine Zeilen zur\u00fcck. Die Operation {0} ist unzul\u00e4ssig. 
XCL05.S=Die Aktivierung wurde geschlossen. Die Operation {0} ist unzul\u00e4ssig.
XCL07.S=Der Cursor ''{0}'' wurde geschlossen. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
XCL08.S=Der Cursor ''{0}'' befindet sich nicht in einer Zeile.
XCL09.S=An die Methode ''{0}'' wurde eine Aktivierung \u00fcbergeben, die nicht mit dem PreparedStatement \u00fcbereinstimmt.
XCL10.S=Ein PreparedStatement wurde kompiliert, und die Parameter wurden ge\u00e4ndert. Wenn Sie JDBC verwenden, m\u00fcssen Sie die Anweisung erneut vorbereiten. 
XCL12.S=Es wurde versucht, einen Datenwert des Typs ''{0}'' in einen Datenwert des Typs ''{1}'' aufzunehmen.
XCL13.S=Die Parameterposition ''{0}'' liegt au\u00dferhalb des Bereichs. Die Parameteranzahl f\u00fcr diese vorbereitete Anweisung ist ''{1}''.
XCL14.S=Die Spaltenposition ''{0}'' befindet sich au\u00dferhalb des Bereichs. Die Anzahl der Spalten f\u00fcr dieses ResultSet liegt bei ''{1}''.
XCL15.S=Beim Aufrufen der Methode compareTo() f\u00fcr ein Objekt ''{0}'' ist eine ClassCastException eingetreten. Der Parameter f\u00fcr compareTo() geh\u00f6rt zur Klasse ''{1}''.
XCL16.S.0=Das ResultSet ist nicht ge\u00f6ffnet. Die Operation ''{0}'' ist unzul\u00e4ssig. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
# This one is used for the network client, where we don't know what operation is being performed.
XCL16.S.1=Das ResultSet ist nicht offen. Pr\u00fcfen Sie, ob das automatische Festschreiben inaktiviert ist.
XCL17.S=Die Anweisung ist in dieser Datenbank nicht zul\u00e4ssig.
XCL18.S=Der Datenstrom des Spaltenwertes im Ergebnis kann nicht zweimal abgerufen werden.
XCL19.S=In der Tabelle ''{0}'' fehlt die Zeile f\u00fcr den Schl\u00fcssel ''{1}''.
XCL20.S=F\u00fcr Kataloge mit dem Versionsstand ''{0}'' kann kein Upgrade auf den Versionsstand ''{1}'' durchgef\u00fchrt werden.
XCL21.S=Sie versuchen, eine Datendefinitionsanweisung (CREATE, DROP oder ALTER) auszuf\u00fchren, w\u00e4hrend Sie eine andere Anweisung vorbereiten. Dies ist unzul\u00e4ssig. Dies kann geschehen, wenn Sie eine Definitionsanweisung aus einem statischen Initialisierungsoperator f\u00fcr eine Java-Klasse heraus ausf\u00fchren, der innerhalb einer SQL-Anweisung verwendet wird.
XCL22.S=Der Parameter {0} kann nicht als OUT-Parameter registriert werden, da er ein IN-Parameter ist. 
XCL23.S=Die SQL-Typnummer ''{0}'' ist kein Typ, der von registerOutParameter() unterst\u00fctzt wird.
XCL24.S=Der Parameter {0} scheint ein Ausgabeparameter zu sein, wurde jedoch von registerOutParameter() nicht als solcher angegeben. Wenn der Parameter kein Ausgabeparameter ist, muss er auf den Typ {1} gesetzt werden.
XCL25.S=Der Parameter {0} kann nicht als Parameter des Typs {1} registriert werden, weil er dem Typ {2} zugeordnet wird und beide Typen inkompatibel sind.
XCL26.S=Der Parameter {0} ist kein Ausgabeparameter.
XCL27.S=Zur\u00fcckzugebende Ausgabeparameter k\u00f6nnen nicht festgelegt werden.
XCL30.S=Beim Lesen eines ''{0}'' von einem InputStream wurde eine IOException ausgel\u00f6st.
XCL31.S=Die Anweisung wurde geschlossen.

# Delete Rule Restrictions Violation Messages
XCL33.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung ist selbstreferenzierend. Eine solche Beziehung besteht bereits zur L\u00f6schregel SET NULL.)

XCL34.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung umfasst zwei oder mehr Tabellen, so dass die Tabelle f\u00fcr das mehrstufige L\u00f6schen auf sich selbst verweist. F\u00fcr alle \u00fcbrigen Tabellen gilt die L\u00f6schregel CASCADE.)

XCL35.S=Aufgrund von L\u00f6schregeleinschr\u00e4nkungen kann die Tabelle nicht als abh\u00e4ngig von der Tabelle {0} definiert werden. (Die Beziehung f\u00fchrt dazu, dass die Tabelle \u00fcber mehrere Beziehungen f\u00fcr das mehrstufige L\u00f6schen auf die angegebene Tabelle verweist. Die L\u00f6schregel der bestehenden Beziehung ist SET NULL.)


XCL36.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die referenzielle Integrit\u00e4tsbedingung verweist auf sich selbst. Eine vorhandene auf sich selbst verweisende referenzielle Integrit\u00e4tsbedingung hat die L\u00f6schregel NO ACTION, RESTRICT oder CASCADE.)
XCL37.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die referenzielle Integrit\u00e4tsbedingung verweist auf sich selbst, und die Tabelle befindet sich in einer Abh\u00e4ngigkeitsbeziehung mit der L\u00f6schregel CASCADE.)
XCL38.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel muss {0} sein. (Die Beziehung w\u00fcrde dazu f\u00fchren, dass die Tabelle \u00fcber mehrere Beziehungen f\u00fcr das mehrstufige L\u00f6schen auf dieselbe Tabelle verweist. Diese Beziehungen m\u00fcssen dieselbe L\u00f6schregel NO ACTION, RESTRICT oder CASCADE haben.)


XCL39.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Es liegt eine auf sich selbst verweisende Integrit\u00e4tsbedingung mit der L\u00f6schregel SET NULL, NO ACTION oder RESTRICT vor.)

XCL40.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Es w\u00fcrde eine Kreisbeziehung entstehen, in der eine Tabelle f\u00fcr das mehrstufige L\u00f6schen auf sich selbst verweisen w\u00fcrde.) Eine der vorhandenen L\u00f6schregeln in der Beziehung ist nicht CASCADE. Die Beziehung kann demzufolge definiert werden, wenn die L\u00f6schregel nicht CASCADE lautet.)

XCL41.S=Die L\u00f6schregel f\u00fcr den Fremdschl\u00fcssel darf nicht CASCADE lauten. (Die Beziehung w\u00fcrde dazu f\u00fchren, dass eine andere Tabelle \u00fcber mehrere Pfade mit verschiedenen L\u00f6schregeln oder der einheitlichen L\u00f6schregel SET NULL f\u00fcr das mehrstufige L\u00f6schen auf dieselbe Tabelle verweisen w\u00fcrde.)

XCL42.S=CASCADE
XCL43.S=SET NULL
XCL44.S=RESTRICT
XCL45.S=NO ACTION
XCL46.S=SET DEFAULT

XCL47.S=Die Verwendung von ''{0}'' setzt voraus, dass Sie ein Upgrade der Datenbank von Version {1} auf Version {2} oder eine aktuellere Version durchf\u00fchren. 
XCL48.S= F\u00fcr ''{0}'' ist TRUNCATE TABLE nicht zul\u00e4ssig, weil aktivierte Integrit\u00e4tsbedingungen f\u00fcr Fremdschl\u00fcssel in anderen Tabellen auf Integrit\u00e4tsbedingungen f\u00fcr eindeutige oder Prim\u00e4rschl\u00fcssel in dieser Tabelle verweisen. 
XCL49.S= F\u00fcr ''{0}'' ist TRUNCATE TABLE nicht zul\u00e4ssig, weil ein aktivierter DELETE-Ausl\u00f6ser vorliegt ({1}).
XCL50.S=Ein Upgrade f\u00fcr eine fr\u00fchere Version der Datenbank wird nicht unterst\u00fctzt. Die Datenbank, auf die zugegriffen wird, hat den Versionsstand ''{0}'' und diese Software den Versionsstand ''{1}''. 
XCL51.S=Die angeforderte Funktion kann keine Tabellen im Schema SESSION referenzieren.
XCL52.S=Die Anweisung wurde abgebrochen, oder das Zeitlimit f\u00fcr die Anweisung wurde \u00fcberschritten.

# Transaction states, matches DB2
25000=Ung\u00fcltiger Transaktionsstatus
25001=Eine Verbindung kann nicht beendet werden, solange noch eine Transaktion aktiv ist.


# Authorization
25501=Das Schreibschutzattribut der Verbindung kann nicht in einer aktiven Transaktion gesetzt werden.
25502=F\u00fcr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff sind \u00c4nderungen von SQL-Daten unzul\u00e4ssig.
25503=F\u00fcr eine Verbindung, einen Benutzer oder eine Datenbank mit Lesezugriff ist die DDL unzul\u00e4ssig.
25505=Ein Benutzer mit Lesezugriff oder der Benutzer einer schreibgesch\u00fctzten Datenbank ist nicht berechtigt, den Schreibschutzmodus f\u00fcr eine Verbindung zu inaktivieren.
28502.C=Der Benutzername ''{0}'' ist ung\u00fcltig. 


# Dependency Manager
XD003.S=Die Abh\u00e4ngigkeit kann nicht vom Datentr\u00e4ger zur\u00fcckgeschrieben werden. DependableFinder = ''{0}''. Weitere Informationen: ''{1}''.
XD004.S=Es k\u00f6nnen keine Abh\u00e4ngigkeiten gespeichert werden.


#../java/com/ibm/db2j/impl/Connectivity/JDBC/Local/messages.properties
24000=Ung\u00fcltiger Cursorstatus; keine aktuelle Zeile.

07000=Mindestens ein Parameter der aktuellen Anweisung wurde nicht initialisiert.

# 07004 : {0} is an number {1) is fixed text OUT or INOUT
07004=Der Parameter {0} ist ein {1}-Prozedurparameter und muss vor der Ausf\u00fchrung mit CallableStatement.registerOutParameter registriert werden.

07009=Keine Eingabeparameter.

S0022=Die Spalte ''{0}'' wurde nicht gefunden.
XJ008.S=Ein Sicherungspunkt kann im Modus f\u00fcr automatisches Festschreiben nicht zur\u00fcckgesetzt oder freigegeben werden.
XJ009.S=F\u00fcr das Aufrufen einer gespeicherten Prozedur ist die Verwendung von CallableStatement oder von Ausgabeparametern erforderlich: {0}
XJ010.S=SAVEPOINT kann nicht abgesetzt werden, wenn autoCommit aktiviert ist.
XJ011.S=Null kann nicht als Name f\u00fcr den Sicherungspunkt \u00fcbergeben werden.
XJ012.S=''{0}'' ist bereits geschlossen.
XJ013.S=Keine ID f\u00fcr benannte Sicherungspunkte.
XJ014.S=Kein Name f\u00fcr nicht benannte Sicherungspunkte.
XJ016.S=Die Methode ''{0}'' ist in einer vorbereiteten Anweisung nicht zul\u00e4ssig.
XJ017.S=Innerhalb des Ausl\u00f6secodes ist ein Sicherungspunktbefehl unzul\u00e4ssig.
XJ018.S=Der Spaltenname muss ungleich null sein.
XJ020.S=Der Objekttyp kann nicht in TYPE ''{0}'' konvertiert werden. Der Wert f\u00fcr java.sql.Types ist ung\u00fcltig oder der Objektzeiger ist ein Nullzeiger.
XJ021.S=Der Typ wird nicht unterst\u00fctzt.
XJ022.S=Der folgende Datenstrom kann nicht definiert werden: ''{0}''.
XJ023.S=die Datenmenge des Eingabedatenstroms entspricht nicht exakt der angeforderten L\u00e4nge.
XJ025.S=Ein Eingabedatenstrom kann keine negative L\u00e4nge haben.
XJ030.S=In einer verschachtelten Verbindung kann AUTOCOMMIT ON nicht gesetzt werden.
XJ042.S=''{0}'' ist kein g\u00fcltiger Wert f\u00fcr das Merkmal ''{1}''.
XJ044.S=''{0}'' ist eine ung\u00fcltige Nachkommastellenangabe.
XJ045.S=An Connection.setTransactionIsolationLevel() wurde die ung\u00fcltige oder (derzeit) nicht unterst\u00fctzte Isolationsstufe ''{0}'' \u00fcbergeben. Derzeit unterst\u00fctzte Werte sind java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED und java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.
XJ04B.S=Der Batch darf keinen Befehl enthalten, der versucht, eine Ergebnisliste zur\u00fcckzugeben.
XJ04C.S=Der CallableStatement-Batch darf keine Ausgabeparameter enthalten.
XJ056.S=In einer XA-Verbindung kann AUTOCOMMIT ON nicht gesetzt werden.
XJ057.S=Eine globale Transaktion kann nicht \u00fcber die Verbindung festgeschrieben werden. Die Verarbeitung der COMMIT-Verarbeitung muss \u00fcber die Schnittstelle XAResource erfolgen.
XJ058.S=Eine globale Transaktion kann nicht \u00fcber die Verbindung zur\u00fcckgesetzt werden. Die Verarbeitung der COMMIT-Verarbeitung muss \u00fcber die Schnittstelle XAResource erfolgen.
XJ059.S=Eine Verbindung kann nicht beendet werden, solange noch eine globale Transaktion aktiv ist.
XJ05C.S=Die Konstante ResultSet.HOLD_CURSORS_OVER_COMMIT f\u00fcr das Offenhalten kann f\u00fcr eine globale Transaktion nicht definiert werden.
XJ061.S=Die Methode ''{0}'' ist nur f\u00fcr Scroll-Cursor zul\u00e4ssig.
XJ062.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr ResultSet.setFetchSize(int rows).
XJ063.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setMaxRows(int maxRows). Der Parameterwert muss >= 0 sein.
XJ064.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr setFetchDirection(int direction).
XJ065.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setFetchSize(int rows).
XJ066.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setMaxFieldSize(int max).
XJ067.S=Der SQL-Textzeiger ist null.
XJ068.S=In der Mitte eines Batch sind nur executeBatch und clearBatch zul\u00e4ssig.
XJ069.S=F\u00fcr die Ausf\u00fchrungsanweisung USING sind keine SetXXX-Methoden zul\u00e4ssig.
XJ074.S=Ung\u00fcltiger Parameterwert ''{0}'' f\u00fcr Statement.setQueryTimeout(int seconds)
XJ070.S=In einer BLOB- oder CLOB-Methode wurde das Argument ''{0}'' mit negativer oder Nullposition \u00fcbergeben.
XJ071.S=An eine BLOB- oder CLOB-Methode wurde das negative L\u00e4ngenargument ''{0}'' \u00fcbergeben.
XJ072.S=An eine BLOB- oder CLOB-Methode wurde ein Nullmuster oder eine Nullsuchzeichenfolge \u00fcbergeben.
XJ073.S=Die Daten in diesem BLOB oder CLOB sind nicht mehr verf\u00fcgbar. M\u00f6glicherweise wurde die Transaktion des BLOB/CLOB festgeschrieben oder die Verbindung geschlossen.
XJ076.S=Das Positionsargument ''{0}'' \u00fcberschreitet die Gr\u00f6\u00dfe des BLOB/CLOB.
XJ077.S=Bei dem Versuch, mit getBytes/getSubString das erste Byte/Zeichen des BLOB/CLOB-Musters zu lesen, wurde eine Ausnahme empfangen.
XJ078.S=Die relative Position ''{0}'' ist entweder kleiner als null oder f\u00fcr das aktuelle BLOB/CLOB zu gro\u00df.
XJ079.S=Die angegebene L\u00e4nge ''{0}'' \u00fcberschreitet die Gr\u00f6\u00dfe des BLOB/CLOB.
XJ080.S=Die Ausf\u00fchrungsanweisung USING hat an Stelle von {1} Parametern {0} Parameter \u00fcbergeben.
XJ081.S=An die Methode ''{2}'' wurde der ung\u00fcltige Wert ''{0}'' als Parameter ''{1}'' \u00fcbergeben.
XJ082.U=BLOB/CLOB-Werte sind als Methodenparameter oder Empf\u00e4nger nicht zul\u00e4ssig.
XJ083.U=''{0}'' ist nicht zul\u00e4ssig, weil das ResultSet nicht aktualisierbar ist. 
XJ084.U=Die Spalte entspricht keiner Spalte in der Basistabelle. ''{0}'' kann nicht f\u00fcr diese Spalte abgesetzt werden.
XJ085.S=Der Datenstrom wurde bereits gelesen. Das Dateiende ist erreicht, und der Datenstrom kann nicht erneut verwendet werden.
XJ086.S=Wenn der Cursor nicht in der Einf\u00fcgezeile ist oder der gemeinsame Zugriff f\u00fcr dieses ResultSet-Objekt auf CONCUR_READ_ONLY gesetzt ist, kann diese Methode nicht aufgerufen werden.

XJ088.S=Ung\u00fcltige Operation: wasNull() wurde ohne abgerufene Daten aufgerufen.
XJ090.S=Ung\u00fcltiger Parameter: calendar ist null.
XJ091.S=Ung\u00fcltiges Argument: Der Parameterindex {0} ist kein OUT- oder INOUT-Parameter.
XJ093.S=Das BLOB/CLOB {0} ist zu lang. Die L\u00e4nge darf {1} nicht \u00fcberschreiten.
XJ094.S=Dieses Objekt ist bereits geschlossen.
XJ095.S=Der Versuch, eine Aktion mit erforderlicher Berechtigung auszuf\u00fchren, ist gescheitert.
XJ096.S=Im Paket {0} f\u00fcr {1} konnte ein Ressourcen-Bundle nicht gefunden werden.
XJ097.S=Ein Sicherungspunkt, der nicht von dieser Verbindung erstellt wurde, kann nicht zur\u00fcckgesetzt oder freigegeben werden.
XJ098.S=Der automatisch generierte Schl\u00fcsselwert {0} ist ung\u00fcltig.
XJ099.S=Das Reader-/Datenstromobjekt enth\u00e4lt keine L\u00e4ngenzeichen.
XJ100.S=Die von der Methode registerOutParameter angegebene Anzahl Nachkommastellen passt nicht zur setter-Methode. Ein Genauigkeitsverlust ist m\u00f6glich!
XJ102.S=An der aktuellen Position ist keine Einf\u00fcgung m\u00f6glich.
XJ103.S=Der Tabellenname muss ungleich null sein.
XJ104.S=Ung\u00fcltige L\u00e4nge des gemeinsam genutzten Schl\u00fcssels: {0}.
XJ105.S=Der DES-Schl\u00fcssel hat die falsche L\u00e4nge. Erwartete L\u00e4nge: {0}, empfangene L\u00e4nge: {1}
XJ106.S=Keine derartige Auff\u00fcllung 
XJ107.S=Falsche Auff\u00fcllung
XJ108.S=Unzul\u00e4ssige Blockgr\u00f6\u00dfe
XJ110.S=Der Name der Prim\u00e4rtabelle muss ungleich null sein.
XJ111.S=Der Name der Fremdtabelle muss ungleich null sein.
XJ112.S=Es wurde eine Sicherheitsausnahme festgestellt. Details enth\u00e4lt die n\u00e4chste Ausnahme.
XJ113.S=Die Datei {0} kann nicht ge\u00f6ffnet werden. {1}
XJ114.S=Ung\u00fcltiger Cursorname ''{0}''
XJ115.S=Das ResultSet kann nicht mit der angeforderten Offenhaltungseinstellung {0} ge\u00f6ffnet werden.
XJ116.S=Zu einem Batch k\u00f6nnen nicht mehr als {0} Befehle hinzugef\u00fcgt werden.
XJ117.S=Gem\u00e4\u00df J2EE k\u00f6nnen Abfragen nicht im Batch-Modus verarbeitet werden.
XJ118.S=F\u00fcr eine Nicht-Abfrageanweisung wurde eine Abfrage-Batch-Verarbeitung angefordert.
XJ121.S=Ung\u00fcltige Operation an der aktuellen Cursorposition
XJ122.S=F\u00fcr diese Zeile wurden keine updateXXX-Methoden aufgerufen.
XJ123.S=Diese Methode muss aufgerufen werden, um Werte in der aktuellen Zeile oder der Einf\u00fcgezeile zu aktualisieren.
XJ124.S=Die Spalte kann nicht aktualisiert werden.
XJ125.S=Diese Methode sollte nur f\u00fcr ResultSet-Objekte vom Typ TYPE_SCROLL_INSENSITIVE aufgerufen werden.
XJ126.S=Diese Methode sollte nicht f\u00fcr sensitive dynamische Cursor aufgerufen werden.
XJ128.S=F\u00fcr ''{0}'' konnte kein unwrap ausgef\u00fchrt werden.

XJ200.S=Die maximale Anzahl Abschnitte {0} wurde \u00fcberschritten.
XJ202.S=Ung\u00fcltiger Cursorname ''{0}''
XJ203.S=Der Cursorname ''{0}'' wird bereits verwendet.
XJ204.S=Die Ergebnisliste kann nicht mit der angeforderten Offenhaltungseinstellung {0} ge\u00f6ffnet werden.
XJ206.S=Der SQL-Text ''{0}'' enth\u00e4lt keine Token.
XJ207.S=Die Methode executeQuery kann nicht f\u00fcr ein Update verwendet werden.
XJ208.S=Fehler bei nicht atomarer Batch-Operation. Der Batch wurde \u00fcbergeben. Bei einem Batch-Member ist jedoch mindestens eine Ausnahme eingetreten. Mit getNextException() k\u00f6nnen Sie die Ausnahmen f\u00fcr bestimmte Batch-Elemente abrufen.
XJ209.S=Die erforderliche gespeicherte Prozedur ist nicht auf dem Server installiert.
XJ210.S=Der Name des Lademoduls f\u00fcr die gespeicherte Prozedur auf dem Server wurde nicht gefunden.
XJ211.S=W\u00e4hrend der Batch-Verarbeitung ist eine Kettenunterbrechungsausnahme eingetreten, nach der keine Wiederherstellung m\u00f6glich ist. Der Batch wird nicht atomar beendet.
XJ212.S=Ung\u00fcltige Attributsyntax: {0}
XJ213.C=Das Verbindungsmerkmal traceLevel hat kein g\u00fcltiges Format f\u00fcr eine Zahl.
XJ214.S=Beim Aufrufen von free() f\u00fcr ein CLOB oder BLOB ist ein E/A-Fehler aufgetreten.
XJ215.S=Nach dem Aufrufen der Methode free() k\u00f6nnen Sie keine anderen java.sql.Clob/java.sql.Blob-Methoden aufrufen.

#XN - Network level messages
XN001.S=Innerhalb einer Arbeitseinheit ist eine Zur\u00fccksetzung der Verbindung nicht zul\u00e4ssig.
XN002.U=SECTKN wurde nicht zur\u00fcckgegeben.
XN008.S=Die Abfrageverarbeitung wurde wegen eines Fehlers auf dem Server abgebrochen.
XN009.S=Fehler beim Abrufen der L\u00e4nge des BLOB/CLOB. Die Ausnahme folgt.
XN010.S=Der Prozedurname muss ungleich null sein.
XN011.S=Die L\u00e4nge {0} des Prozedurnamens liegt au\u00dferhalb des g\u00fcltigen Bereichs von 1 bis {1}.
XN012.S=Auf {0}-Plattformen unterst\u00fctzt XA Version {1} und aktuellere Versionen. Dies ist Version {2}.
XN013.S=Ung\u00fcltige Scroll-Richtung
XN014.S=Netzprotokollfehler: Es wurde eine IOException festgestellt (Parameter {0}). Die verbleibenden Daten wurden mit 0x0 aufgef\u00fcllt. Nachricht: {1}.
XN015.S=Netzprotokollfehler: Die angegebene Gr\u00f6\u00dfe des Eingabedatenstroms (Parameter {0}) liegt unter der tats\u00e4chlichen L\u00e4nge des Eingabedatenstroms.
XN016.S=Netzprotokollfehler: Bei der \u00dcberpr\u00fcfung der Datenstroml\u00e4nge wurde ein Fehler festgestellt (Parameter {0}). Nachricht: {1}.
XN017.S=Netzprotokollfehler: Das Ende des Datenstroms wurde vorzeitig erreicht (Parameter {0}). Die verbleibenden Daten wurden mit 0x0 aufgef\u00fcllt.
XN018.S=Netzprotokollfehler: Die angegebene Reader-Gr\u00f6\u00dfe (Parameter {0}) liegt unter der tats\u00e4chlichen Reader-L\u00e4nge.
XN019.S=Fehler beim Ausf\u00fchren von {0}. Der Server hat Folgendes zur\u00fcckgegeben: {1}

#XML - Derby-specific XML errors that are not covered by the SQL standard.
XML00=Die API oder Implementierungsklassen f\u00fcr ''{0}'' wurden nicht gefunden. XML-Operationen sind nur zul\u00e4ssig, wenn diese Klassen in Ihrem Klassenpfad enthalten sind.
XML01=Bei der XML-Verarbeitung ist ein unerwarteter Fehler aufgetreten: {0} 
# 0A - SQLState class indicating feature not supported
0A000.S=Nicht implementiertes Feature: {0}.
0A000.S.1=Die JDBC-Methode ist noch nicht implementiert.
0A000.S.2=Die JDBC-Methode {0} wird nicht vom Server unterst\u00fctzt. F\u00fchren Sie ein Serverupgrade durch.
0A000.S.3=Das resultSetHoldability-Merkmal {0} wird nicht unterst\u00fctzt.
0A000.S.4=Der Server bietet keine Unterst\u00fctzung f\u00fcr cancel().
0A000.S.5=Der Sicherheitsmechanismus ''{0}'' wird nicht unterst\u00fctzt.
0A000.C.6=Der DRDA-Befehl {0} ist derzeit nicht implementiert. Die Verbindung wurde beendet.
0A000.S.7=Der Datentyp ''{0}'' wird nicht unterst\u00fctzt. 
XJ004.C=Die Datenbank ''{0}'' wurde nicht gefunden.
A020=Ung\u00fcltige Authentifizierung.

# 08 - Connection exceptions
08003=Keine aktuelle Verbindung.
08003.C.1=getConnection() ist f\u00fcr eine geschlossene Verbindung im Pool ung\u00fcltig.
08003.C.2=Eine LOB-Methode wurde aufgerufen, nachdem die Verbindung geschlossen wurde.
08003.C.3=Die zugrunde liegende physische Verbindung ist veraltet oder geschlossen.


# NOTE - the {0} parameter needs to be internationalized too.  Don't
# just put in a hardcoded string in your exception code.
08004=Zur\u00fcckgewiesene Verbindung: {0}

# NOTE - the {0} reason needs to be internationalized too.  Don't
# just put in a hardcoded string in your exception code.
08004.C.1=Die Verbindung konnte nicht authentifiziert werden. Ursache: {0}.
08004.C.2=Die Verbindung wurde zur\u00fcckgewiesen, weil die Datenbank {0} nicht gefunden wurde.
08004.C.3=Die Datenbankverbindung wurde verweigert.

XJ028.C=Der URL ''{0}'' hat nicht das richtige Format.
XJ040.C=Die Datenbank ''{0}'' konnte nicht gestartet werden. Details k\u00f6nnen Sie der n\u00e4chsten Ausnahme entnehmen.
XJ041.C=Die Datenbank ''{0}'' konnte nicht erstellt werden. Details k\u00f6nnen Sie der n\u00e4chsten Ausnahme entnehmen.
XJ049.C=Es wurde in Konflikt stehende Erstellungsattribute angegeben.
XJ081.C=Es wurde in Konflikt stehende Erstellungs-/Wiederherstellungsattribute angegeben.
XJ05B.C=Das JDBC-Attribut ''{0}'' hat einen ung\u00fcltigen Wert (''{1}''). G\u00fcltige Werte sind: ''{2}''.

XXXXX.C.6=Normale Beendigung der Datenbanksitzung.

08001.C.1=Das erforderliche Derby-DataSource-Merkmal {0} ist nicht gesetzt.
08001.C.2={0}: Fehler beim Herstellen der Verbindung zum Server {1} am Port {2}. Nachricht: {3}.
08001.C.3=SocketException: ''{0}''
08001.C.4=Am Socket ''{0}'' kann kein Datenstrom ge\u00f6ffnet werden.
08001.C.5=Die L\u00e4nge der Benutzer-ID ({0}) liegt au\u00dferhalb des g\u00fcltigen Bereichs von 1 bis {1}.
08001.C.6=Die L\u00e4nge des Kennworts ({0}) liegt au\u00dferhalb des g\u00fcltigen Bereichs von 1 bis {1}.
08001.C.7=Die Benutzer-ID muss ungleich null sein.
08001.C.8=Das Kennwort muss ungleich null sein.
08001.C.9=Es konnte keine Verbindung hergestellt werden, weil der Datenbankname {0} l\u00e4nger als f\u00fcr das Netzprotokoll maximal zul\u00e4ssig ist.
08001.C.10=Es konnte keine Verbindung hergestellt werden, weil das Sicherheitstoken gr\u00f6\u00dfer als f\u00fcr das Netzprotokoll maximal zul\u00e4ssig ist.
08001.C.11=Es konnte keine Verbindung hergestellt werden, weil die Benutzer-ID die L\u00e4nge null hat oder l\u00e4nger als f\u00fcr das Netzprotokoll maximal zul\u00e4ssig ist.
08001.C.12=Es konnte keine Verbindung hergestellt werden, weil das Kennwort die L\u00e4nge null hat oder l\u00e4nger als f\u00fcr das Netzprotokoll maximal zul\u00e4ssig ist.


08006.D=Die Datenbank ''{0}'' wird heruntergefahren.
08006.C.1=W\u00e4hrend des Zur\u00fccksetzens einer Verbindung ist ein Fehler aufgetreten. Die Verbindung wurde beendet. Details finden Sie in den zugeh\u00f6rigen Ausnahmen.

XJ015.M=Das Derby-System wird heruntergefahren.

01J01=Die Datenbank ''{0}'' wurde nicht erstellt. Stattdessen wurde eine Verbindung zu einer vorhandenen Datenbank hergestellt.
01J02=Scroll-sensitive Cursor sind derzeit nicht implementiert.
01J04=Die Klasse ''{0}'' f\u00fcr die Spalte ''{1}'' implementiert nicht java.io.Serializable oder java.sql.SQLData. Eine dieser Schnittstellen muss von Instanzen implementiert werden, damit sie gespeichert werden k\u00f6nnen.
01J05=Der Upgrade f\u00fcr die Datenbank wurde fehlerfrei durchgef\u00fchrt. Die erweiterte Datenbank steht zur Verwendung bereit. Die gespeicherten vorbereiteten Anweisungen konnten nicht erneut ausgewertet werden. Details zu diesem Fehler enth\u00e4lt die n\u00e4chste Ausnahme.
01J06=Das ResultSet kann nicht aktualisiert werden. Die Abfrage wurde nicht f\u00fcr die Generierung eines aktualisierbaren ResultSet qualifiziert.
01J07=ResultSetHoldability wurde f\u00fcr eine globale Transaktion auf ResultSet.CLOSE_CURSORS_AT_COMMIT eingeschr\u00e4nkt.
01J08=Der ResultSet-Typ {0} kann nicht ge\u00f6ffnet werden. Es wurde der ResultSet-Typ {1} ge\u00f6ffnet.
01J10=Scroll-sensitive Ergebnislisten werden vom Server nicht unterst\u00fctzt. Es erfolgt eine Neuzuordnung zu einem Cursor, der sich nur vorw\u00e4rts durch die Ergebnisliste bewegen kann.
01J12=Vom Server kann kein Nachrichtentext abgerufen werden. Lesen Sie die n\u00e4chste Ausnahme. Die gespeicherte Prozedur SYSIBM.SQLCAMESSAGE ist nicht auf dem Server installiert. Wenden Sie sich an den Datenbankadministrator.
01J13=Es wurden zu viele Zeilen ({0}) f\u00fcr ein Integer zur\u00fcckgegeben. Der zur\u00fcckgegebene Wert wird abgeschnitten.
01J14=Die SQL-Autorisierung wird verwendet, ohne dass zuvor die Authentifizierung aktiviert wurde.


XJ001.U=Java-Ausnahme: ''{1}: {0}''.
XJ050.U=F\u00fcr die Datenbankversion {0} ist ein Upgrade erforderlich. Setzen Sie f\u00fcr den JDBC-Verbindungs-URL das Attribut ''upgrade=true'', um ein Upgrade auf Version {1} zu erm\u00f6glichen.



# org.apache.derby.database.UserUtility
#
XCZ00.S=Unbekannte Berechtigung ''{0}''.
XCZ01.S=Unbekannter Benutzer ''{0}''.
XCZ02.S=Ung\u00fcltiger Parameter ''{0}''=''{1}''.

# SQL J Jar support
46001=Ausnahme beim Zugriff auf die JAR-Datei mit dem URL ''{0}''.
46J01=Die Signatur der Java-Methode hat ein ung\u00fcltiges Format.
46J02=Die Signatur der Java-Methode enth\u00e4lt eine falsche Anzahl von Parametern ({0}). Erwartet wurden {1} Parameter.

###############################################################################
#
# Text for non-exception strings
#
###############################################################################

# Log
L001=------------  ANFANG DER FEHLERNACHRICHT -------------\n
L002=------------  ENDE DER FEHLERNACHRICHT -------------\n
L003=\n------------  ANFANG DES FEHLERBEREICHS F\u00dcR SHUTDOWN -------------\n
L004=\n------------  ENDE DES FEHLERBEREICHS F\u00dcR SHUTDOWN -------------\n
L005=\n------------  ANFANG DES FEHLERBEREICHS -------------\n
L006=\n------------  ENDE DES FEHLERBEREICHS -------------\n
L007=WARNUNG: Die Protokolldatei wurde nicht gefunden. Es wird ein neues Protokoll erstellt. M\u00f6glicherweise ist die Datenbank inkonsistent.
L008=Die inkompatible alte Protokolldatei {0} wird gel\u00f6scht
L009=Die alte Protokolldatei {0} wird gel\u00f6scht
L010=In der Datei {0} wurde ein unvollst\u00e4ndiger Protokollsatz gefunden. Der Inhalt der Protokolldatei wird von der Position {1} bis zum Dateiende bei {2} gel\u00f6scht.
L011=Der Pr\u00fcfpunktd\u00e4mon hat eine Standardausnahme abgefangen.
L012=Der Protokollsatz ist nicht als erster Satz der Transaktion markiert. Die Transaktion wurde jedoch nicht in der Transaktionstabelle gefunden. {0}
L013=Der Protokollsatz ist als erster Satz der Transaktion markiert. Die Transaktion ist jedoch bereits in der Transaktionstabelle enthalten. {0}
L014=Falsche Anfangsadresse
L015=Es ist bereits eine neue Protokolldatei vorhanden, die nicht gel\u00f6scht werden kann. {0}
L016=Die neue Protokolldatei {0} kann nicht erstellt werden.
L017=Die neue Protokolldatei {0} kann nicht erstellt werden. Grund: {1}.
L018=Das System hat m\u00f6glicherweise einen inkonsistenten Status. Fehlende Datei: {0}
L020=WARNUNG: Die Datenbank wurde mindestens einmal mit {0}={1} gebootet. Durch die Verwendung dieses Modus kann die Datenbank m\u00f6glicherweise nicht wiederhergestellt werden. Festgeschriebene Transaktionen k\u00f6nnen verloren gegangen sein. Es ist m\u00f6glich, dass die Datenbank einen inkonsistenten Status hat. Dies kann zu unerwarteten Fehlern f\u00fchren.\n
L021=WARNUNG: Die Datenbank wurde zu einem fr\u00fcheren Zeitpunkt oder jetzt mit {0} = {1} gebootet. Bei Verwendung des Modus {0}={1} ist die Wiederherstellbarkeit nicht gew\u00e4hrleistet. Wahrscheinlich ist das die Ursache f\u00fcr diesen Boot-Fehler.\n


# Class Manager
C000=Die Klasse {0} wurde in die Datei {1} geschrieben. Stellen Sie Unterst\u00fctzung f\u00fcr die Datei und die folgende Ausnahme bereit: {2}
C001=Die Klasse {0} enth\u00e4lt in der JAR-Datei {1} einen unbekannten Zertifikattyp. Es wurde ein X509-Zertifikat erwartet.
C002=Beim Zugriff auf die Klasse {0} in der JAR-Datei {1} wurde die folgende Sicherheitsausnahme ausgel\u00f6st: {2}
C003=Ausnahme beim Laden der Datenbank-JAR-Datei {0} - {1}
C004=Veraltetes Klassenladeprogramm f\u00fcr die Klasse {0}
C005=Das Ladeprogramm f\u00fcr Datenbankklassen wurde gestartet - derby.database.classpath=''{0}''
C006={0} wurde aus der Datenbank-JAR-Datei {1} geladen.
C007=Beim Laden der Klasse {0} aus der JAR-Datei {1} eingetretene Ausnahme: {2}

# RawStore Data

D001=:\nBooten von Derby Version {0}: Instanz {1}\nf\u00fcr das Datenbankverzeichnis {2} {3}\n
D002=:\nDie Instanz {0} wird heruntergefahren.
D004=Die Sicherung f\u00fcr die Datenbank in {0} wurde unter {1} gestartet.
D005=Die alte Sicherungskopie wurde von {0} nach {1} verschoben.
D006=Die Sicherung des Datensegments in {0} ist abgeschlossen. 
D007=F\u00fcr die Datenbank wurde service.properties editiert, um den Standardprotokollservice verwenden zu k\u00f6nnen.
D008=Fehler beim Editieren von service.properties f\u00fcr die Datenbank. Abgebrochene Sicherung: {0}
D009=Das Protokollverzeichnis wurde von {0} nach {1} kopiert.
D010=Die Sicherung wurde wegen eines Fehlers abgebrochen.
D011=Die alte Sicherungskopie mit der Adresse {0} wurde gel\u00f6scht.
D012=Die Sicherung ist abgeschlossen. Protokolladresse: {0} \n
D013=WARNUNG: Die Datenbank wird mit {0}={1} gebootet. Bei Verwendung dieses Modus kann die Datenbank m\u00f6glicherweise nicht wiederhergestellt werden. Festgeschriebene Transaktionen k\u00f6nnen verloren gehen. Es ist m\u00f6glich, dass die Datenbank einen inkonsistenten Status hat. Verwenden Sie diesen Modus nur, wenn Sie die genannten Folgen bewusst in Kauf nehmen m\u00f6chten. \n
D014=Lesezugriff

# Connectivity 
J004=Datenbankidentit\u00e4t
J005=Derby herunterfahren
J007=Datenbank erstellen
J008=keine Details
J010=Datenbank auf Datentr\u00e4ger verschl\u00fcsseln
J013=Datenbank erweitern
J016=Verschl\u00fcsselungsserviceprovider
J017=Verschl\u00fcsselungsalgorithmus
J018=L\u00e4nge des Chiffrierschl\u00fcssels
J019=Externer Chiffrierschl\u00fcssel
J020=Geheimer Chiffrierschl\u00fcssel
J021=Gebietsschema der Datenbank
J022=Benutzername
J023=Benutzerkennwort
J025=Verzeichnispfad protokollieren
J028=Sicherungspfad f\u00fcr aktualisierende Wiederherstellung
J100=Die Netzserverklasse {0} wurde nicht gefunden. Ihr Klassenpfad sollte derbynet.jar enthalten.
J101=Die Netzserverklasse {0} konnte nicht geladen werden. {1}. \u00dcberpr\u00fcfen Sie die Integrit\u00e4t Ihrer Datei derbynet.jar.
J102=Beim Starten des Netzservers wurde eine Ausnahme ausgel\u00f6st. {0}
J103=Beim Herunterfahren des Netzservers wurde eine Ausnahme ausgel\u00f6st. {0}
J104=Das Objekt ist bereits geschlossen.
J105=Die Genauigkeit liegt bei mehr als 31 Stellen!
J106=Ursache ist eine Ausnahme
J107=Fehler f\u00fcr das Batch-Element
J108=Der Security Manager erlaubt nicht den Zugriff auf das Systemmerkmal {0}.
J109=Es wurde eine inkorrekte TCP/IP-Client-Konfiguration festgestellt. Die IP-Adresse Ihres lokalen Hosts kann nicht bestimmt werden. ''{0}''.  Stellen Sie sicher, dass die IP-Adresse Ihrer Client-Maschine ordnungsgem\u00e4\u00df konfiguriert ist.
J110=Der Sicherheitsmechanismus wird nicht unterst\u00fctzt
J111=Das Kennwort fehlt
J112=Die Benutzer-ID fehlt
J113=Die Benutzer-ID oder das Kennwort ist ung\u00fcltig
J114=Die Benutzer-ID wurde entzogen
J115=Das neue Kennwort ist ung\u00fcltig
J116=Fehler: Die Verwendung des Security Service kann nicht erneut versucht werden
J117=Im ACCSEC-Befehl fehlt das erforderliche Sicherheitstoken (SECTKN) oder das Token ist ung\u00fcltig
J118=Das Kennwort ist abgelaufen
J120=nicht angegeben
J121=Der Benutzer ist nicht berechtigt, auf die Datenbank zuzugreifen.
J122=Vor dem Befehl, mit dem der Zugriff auf die Datenbank angefordert wird (ACCRDB), wurde ein Befehl abgesetzt, der Services der Datenbank anfordert.
J123=Der angeforderte Befehl hat eine implementierungsspezifische, nicht in der Spezifikation enthaltene Bedingung festgestellt, f\u00fcr die keine Nachricht implementiert ist.
J124=Der Befehl f\u00fcr den Zugriff auf die relationale Datenbank (ACCRDB) kann nicht abgesetzt werden, weil der Zugriff auf die Datenbank bereits erfolgte.
J125=Es wurde ein Fehler durch einen abweichenden Datendeskriptor festgestellt.
J126=Es wurde ein Dialogprotokollfehler festgestellt. Ursache: 0x{0}.
J127=parseSQLDIAGGRP ist noch nicht implementiert.
J128=Der Cursor ist nicht offen.
J129=F\u00fcr eine bereits ge\u00f6ffnete Abfrage wurde ein Befehl Open Query abgesetzt.
J130=Es wurde ein Fehler wegen einer ung\u00fcltigen FDOCA-Beschreibung festgestellt.
J131=Es wurde ein Fehler in der Datenstromsyntax festgestellt. Ursache: 0x{0}.
J132=Benutzername f\u00fcr die Verbindung
J133=Kennwort des Benutzers f\u00fcr die Verbindung


# Authentication
A001=SCHWERWIEGENDER FEHLER: Es gibt keinen Authentifizierungsservice f\u00fcr das System.
A002=SCHWERWIEGENDER FEHLER: Es gibt keinen Authentifizierungsservice f\u00fcr die Datenbank.
A011=WARNUNG: Im Merkmal {0} ist kein LDAP-Server-/Hostname angegeben. Es wird localhost:389 verwendet.

I015=org.apache.derby.jdbc.EmbeddedDriver wurde nicht im JDBC-Treibermanager registriert.
I024=Die Datenbank ist nicht verf\u00fcgbar.
I025=Der JDBC-Treiber ist nicht verf\u00fcgbar.
I026=Die JDBC-Treiberregistrierung mit java.sql.DriverManager ist gescheitert. {0} 
# Import/Export
XIE01.S=Es ist keine Verbindung vorhanden.
XIE03.S=In Zeile {0} f\u00fcr Spalte {1} wurden nach dem Endbegrenzer Daten gefunden. 
XIE04.S=Nicht gefundene Datendatei: {0}
XIE05.S=Es muss eine Datendatei angegeben werden. 
XIE06.S=Der Name der Definitionseinheit wurde nicht angegeben.
XIE07.S=Feld- und Satztrennzeichen k\u00f6nnen nicht als Unterzeichenfolge des jeweils anderen Trennzeichens verwendet werden. 
XIE08.S=Es gibt keine Spalte mit dem Namen {0}. 
XIE09.S=Summe der Spalten in der Zeile: {0}. 
XIE0B.S=Die Spalte ''{0}'' der Tabelle ist vom Typ {1}, der vom Import/Export nicht unterst\u00fctzt wird. 
XIE0D.S=Das Satztrennzeichen wurde nicht in Zeile {0} gefunden.
XIE0E.S=In Zeile {0} wurde an unerwarteter Stelle ein Dateiende gelesen.
XIE0I.S=Beim Schreiben von Daten in die Datei ist eine E/A-Ausnahme eingetreten.
XIE0J.S=Ein Begrenzer ist ung\u00fcltig oder wird mehrfach verwendet.
XIE0K.S=Als Zeichenfolgenbegrenzer wurde ein Punkt angegeben.
XIE0M.S=Die Tabelle ''{0}'' ist nicht vorhanden. 

# Monitor
M001=\n# ********************************************************************\n# ***           Diese Datei darf NICHT bearbeitet werden.          ***\n# *** BEIM \u00c4NDERN DES DATEIINHALTS K\u00d6NNEN DATEN BESCH\u00c4DIGT WERDEN. ***\n# ********************************************************************




#  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#
#  DO NOT TRANSLATE MESSAGES OR TEXT BELOW THIS LINE
#
#
# ----------------------------------------------------------------------------------------------------------



